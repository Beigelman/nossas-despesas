
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Beigelman/nossas-despesas/internal/modules/auth/auth.go (70.0%)</option>
				
				<option value="file1">github.com/Beigelman/nossas-despesas/internal/modules/auth/controller/refresh_token.go (0.0%)</option>
				
				<option value="file2">github.com/Beigelman/nossas-despesas/internal/modules/auth/controller/router.go (0.0%)</option>
				
				<option value="file3">github.com/Beigelman/nossas-despesas/internal/modules/auth/controller/sign_in_with_credentials.go (0.0%)</option>
				
				<option value="file4">github.com/Beigelman/nossas-despesas/internal/modules/auth/controller/sign_in_with_google.go (0.0%)</option>
				
				<option value="file5">github.com/Beigelman/nossas-despesas/internal/modules/auth/controller/sign_up_with_credentials.go (0.0%)</option>
				
				<option value="file6">github.com/Beigelman/nossas-despesas/internal/modules/auth/module/auth.go (0.0%)</option>
				
				<option value="file7">github.com/Beigelman/nossas-despesas/internal/modules/auth/postgres/auth_repository.go (40.5%)</option>
				
				<option value="file8">github.com/Beigelman/nossas-despesas/internal/modules/auth/postgres/mapper.go (76.9%)</option>
				
				<option value="file9">github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase/refresh_token.go (100.0%)</option>
				
				<option value="file10">github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase/sign_in_with_credentials.go (100.0%)</option>
				
				<option value="file11">github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase/sign_in_with_google.go (0.0%)</option>
				
				<option value="file12">github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase/sign_up_with_credentials.go (84.6%)</option>
				
				<option value="file13">github.com/Beigelman/nossas-despesas/internal/modules/category/category.go (100.0%)</option>
				
				<option value="file14">github.com/Beigelman/nossas-despesas/internal/modules/category/controller/create_category.go (0.0%)</option>
				
				<option value="file15">github.com/Beigelman/nossas-despesas/internal/modules/category/controller/create_category_group.go (0.0%)</option>
				
				<option value="file16">github.com/Beigelman/nossas-despesas/internal/modules/category/controller/get_categories.go (0.0%)</option>
				
				<option value="file17">github.com/Beigelman/nossas-despesas/internal/modules/category/controller/router.go (0.0%)</option>
				
				<option value="file18">github.com/Beigelman/nossas-despesas/internal/modules/category/group.go (100.0%)</option>
				
				<option value="file19">github.com/Beigelman/nossas-despesas/internal/modules/category/module/category.go (0.0%)</option>
				
				<option value="file20">github.com/Beigelman/nossas-despesas/internal/modules/category/postgres/category_group_repository.go (40.5%)</option>
				
				<option value="file21">github.com/Beigelman/nossas-despesas/internal/modules/category/postgres/category_repository.go (40.5%)</option>
				
				<option value="file22">github.com/Beigelman/nossas-despesas/internal/modules/category/postgres/get_categories.go (0.0%)</option>
				
				<option value="file23">github.com/Beigelman/nossas-despesas/internal/modules/category/postgres/mapper.go (77.8%)</option>
				
				<option value="file24">github.com/Beigelman/nossas-despesas/internal/modules/category/usecase/create_category.go (100.0%)</option>
				
				<option value="file25">github.com/Beigelman/nossas-despesas/internal/modules/category/usecase/create_category_group.go (100.0%)</option>
				
				<option value="file26">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/create_expense.go (0.0%)</option>
				
				<option value="file27">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/create_expense_from_scheduled.go (0.0%)</option>
				
				<option value="file28">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/create_scheduled_expense.go (0.0%)</option>
				
				<option value="file29">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/delete_expense.go (0.0%)</option>
				
				<option value="file30">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/generate_expenses_from_scheduled.go (0.0%)</option>
				
				<option value="file31">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/get_expense_details.go (0.0%)</option>
				
				<option value="file32">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/get_expenses.go (0.0%)</option>
				
				<option value="file33">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/get_expenses_per_category.go (0.0%)</option>
				
				<option value="file34">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/get_expenses_per_period.go (0.0%)</option>
				
				<option value="file35">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/recalculate_expenses_split_ratio.go (0.0%)</option>
				
				<option value="file36">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/router.go (0.0%)</option>
				
				<option value="file37">github.com/Beigelman/nossas-despesas/internal/modules/expense/controller/update_expense.go (0.0%)</option>
				
				<option value="file38">github.com/Beigelman/nossas-despesas/internal/modules/expense/expense.go (81.4%)</option>
				
				<option value="file39">github.com/Beigelman/nossas-despesas/internal/modules/expense/module/expense.go (0.0%)</option>
				
				<option value="file40">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/expense_repository.go (70.0%)</option>
				
				<option value="file41">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/get_expense_details.go (0.0%)</option>
				
				<option value="file42">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/get_expenses.go (0.0%)</option>
				
				<option value="file43">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/get_expenses_per_category.go (0.0%)</option>
				
				<option value="file44">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/get_expenses_per_period.go (0.0%)</option>
				
				<option value="file45">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/mapper.go (73.9%)</option>
				
				<option value="file46">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/model.go (80.0%)</option>
				
				<option value="file47">github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres/scheduled_expense_repository.go (74.2%)</option>
				
				<option value="file48">github.com/Beigelman/nossas-despesas/internal/modules/expense/scheduled_expense.go (20.7%)</option>
				
				<option value="file49">github.com/Beigelman/nossas-despesas/internal/modules/expense/split_ratio.go (58.3%)</option>
				
				<option value="file50">github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase/create_expense.go (89.6%)</option>
				
				<option value="file51">github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase/create_scheduled_expense.go (0.0%)</option>
				
				<option value="file52">github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase/delete_expense.go (100.0%)</option>
				
				<option value="file53">github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase/generate_expenses_from_scheduled.go (0.0%)</option>
				
				<option value="file54">github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase/recalculate_expenses_split_ratio.go (0.0%)</option>
				
				<option value="file55">github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase/update_expense.go (90.5%)</option>
				
				<option value="file56">github.com/Beigelman/nossas-despesas/internal/modules/group/controller/accept_group_invite.go (0.0%)</option>
				
				<option value="file57">github.com/Beigelman/nossas-despesas/internal/modules/group/controller/create_group.go (0.0%)</option>
				
				<option value="file58">github.com/Beigelman/nossas-despesas/internal/modules/group/controller/get_group.go (0.0%)</option>
				
				<option value="file59">github.com/Beigelman/nossas-despesas/internal/modules/group/controller/get_group_balance.go (0.0%)</option>
				
				<option value="file60">github.com/Beigelman/nossas-despesas/internal/modules/group/controller/invite_user_to_group.go (0.0%)</option>
				
				<option value="file61">github.com/Beigelman/nossas-despesas/internal/modules/group/controller/router.go (0.0%)</option>
				
				<option value="file62">github.com/Beigelman/nossas-despesas/internal/modules/group/group.go (50.0%)</option>
				
				<option value="file63">github.com/Beigelman/nossas-despesas/internal/modules/group/invite.go (53.3%)</option>
				
				<option value="file64">github.com/Beigelman/nossas-despesas/internal/modules/group/module/group.go (0.0%)</option>
				
				<option value="file65">github.com/Beigelman/nossas-despesas/internal/modules/group/postgres/get_group.go (0.0%)</option>
				
				<option value="file66">github.com/Beigelman/nossas-despesas/internal/modules/group/postgres/get_group_balance.go (0.0%)</option>
				
				<option value="file67">github.com/Beigelman/nossas-despesas/internal/modules/group/postgres/group_repository.go (40.5%)</option>
				
				<option value="file68">github.com/Beigelman/nossas-despesas/internal/modules/group/postgres/invite_repository.go (45.7%)</option>
				
				<option value="file69">github.com/Beigelman/nossas-despesas/internal/modules/group/postgres/mapper.go (76.5%)</option>
				
				<option value="file70">github.com/Beigelman/nossas-despesas/internal/modules/group/usecase/accept_group_invite.go (100.0%)</option>
				
				<option value="file71">github.com/Beigelman/nossas-despesas/internal/modules/group/usecase/create_group.go (100.0%)</option>
				
				<option value="file72">github.com/Beigelman/nossas-despesas/internal/modules/group/usecase/invite_user_to_group.go (64.1%)</option>
				
				<option value="file73">github.com/Beigelman/nossas-despesas/internal/modules/income/controller/create_income.go (0.0%)</option>
				
				<option value="file74">github.com/Beigelman/nossas-despesas/internal/modules/income/controller/delete_income.go (0.0%)</option>
				
				<option value="file75">github.com/Beigelman/nossas-despesas/internal/modules/income/controller/get_incomes_per_period.go (0.0%)</option>
				
				<option value="file76">github.com/Beigelman/nossas-despesas/internal/modules/income/controller/get_monthly_income.go (0.0%)</option>
				
				<option value="file77">github.com/Beigelman/nossas-despesas/internal/modules/income/controller/router.go (0.0%)</option>
				
				<option value="file78">github.com/Beigelman/nossas-despesas/internal/modules/income/controller/update_income.go (0.0%)</option>
				
				<option value="file79">github.com/Beigelman/nossas-despesas/internal/modules/income/income.go (33.3%)</option>
				
				<option value="file80">github.com/Beigelman/nossas-despesas/internal/modules/income/module/income.go (0.0%)</option>
				
				<option value="file81">github.com/Beigelman/nossas-despesas/internal/modules/income/postgres/get_incomes_per_period.go (0.0%)</option>
				
				<option value="file82">github.com/Beigelman/nossas-despesas/internal/modules/income/postgres/get_monthly_income.go (0.0%)</option>
				
				<option value="file83">github.com/Beigelman/nossas-despesas/internal/modules/income/postgres/income_repository.go (48.8%)</option>
				
				<option value="file84">github.com/Beigelman/nossas-despesas/internal/modules/income/postgres/mapper.go (75.0%)</option>
				
				<option value="file85">github.com/Beigelman/nossas-despesas/internal/modules/income/usecase/create_income.go (0.0%)</option>
				
				<option value="file86">github.com/Beigelman/nossas-despesas/internal/modules/income/usecase/delete_income.go (0.0%)</option>
				
				<option value="file87">github.com/Beigelman/nossas-despesas/internal/modules/income/usecase/update_income.go (0.0%)</option>
				
				<option value="file88">github.com/Beigelman/nossas-despesas/internal/modules/user/controller/get_me.go (0.0%)</option>
				
				<option value="file89">github.com/Beigelman/nossas-despesas/internal/modules/user/controller/router.go (0.0%)</option>
				
				<option value="file90">github.com/Beigelman/nossas-despesas/internal/modules/user/module/user.go (0.0%)</option>
				
				<option value="file91">github.com/Beigelman/nossas-despesas/internal/modules/user/postgres/get_user_by_id.go (0.0%)</option>
				
				<option value="file92">github.com/Beigelman/nossas-despesas/internal/modules/user/postgres/mapper.go (76.9%)</option>
				
				<option value="file93">github.com/Beigelman/nossas-despesas/internal/modules/user/postgres/user_repository.go (67.6%)</option>
				
				<option value="file94">github.com/Beigelman/nossas-despesas/internal/modules/user/usecase/create_user.go (100.0%)</option>
				
				<option value="file95">github.com/Beigelman/nossas-despesas/internal/modules/user/user.go (64.3%)</option>
				
				<option value="file96">github.com/Beigelman/nossas-despesas/internal/pkg/api/error_handler.go (0.0%)</option>
				
				<option value="file97">github.com/Beigelman/nossas-despesas/internal/pkg/api/module.go (0.0%)</option>
				
				<option value="file98">github.com/Beigelman/nossas-despesas/internal/pkg/api/response.go (0.0%)</option>
				
				<option value="file99">github.com/Beigelman/nossas-despesas/internal/pkg/config/biding.go (0.0%)</option>
				
				<option value="file100">github.com/Beigelman/nossas-despesas/internal/pkg/config/constructor.go (0.0%)</option>
				
				<option value="file101">github.com/Beigelman/nossas-despesas/internal/pkg/config/load.go (0.0%)</option>
				
				<option value="file102">github.com/Beigelman/nossas-despesas/internal/pkg/config/module.go (0.0%)</option>
				
				<option value="file103">github.com/Beigelman/nossas-despesas/internal/pkg/db/client.go (60.0%)</option>
				
				<option value="file104">github.com/Beigelman/nossas-despesas/internal/pkg/db/container.go (86.2%)</option>
				
				<option value="file105">github.com/Beigelman/nossas-despesas/internal/pkg/db/migration.go (44.0%)</option>
				
				<option value="file106">github.com/Beigelman/nossas-despesas/internal/pkg/db/module.go (0.0%)</option>
				
				<option value="file107">github.com/Beigelman/nossas-despesas/internal/pkg/db/options.go (48.4%)</option>
				
				<option value="file108">github.com/Beigelman/nossas-despesas/internal/pkg/db/transaction.go (44.4%)</option>
				
				<option value="file109">github.com/Beigelman/nossas-despesas/internal/pkg/dbtest/setup.go (90.9%)</option>
				
				<option value="file110">github.com/Beigelman/nossas-despesas/internal/pkg/di/container.go (87.6%)</option>
				
				<option value="file111">github.com/Beigelman/nossas-despesas/internal/pkg/di/di.go (95.2%)</option>
				
				<option value="file112">github.com/Beigelman/nossas-despesas/internal/pkg/env/environment.go (0.0%)</option>
				
				<option value="file113">github.com/Beigelman/nossas-despesas/internal/pkg/eon/app.go (44.4%)</option>
				
				<option value="file114">github.com/Beigelman/nossas-despesas/internal/pkg/eon/constructor.go (100.0%)</option>
				
				<option value="file115">github.com/Beigelman/nossas-despesas/internal/pkg/eon/hooks.go (100.0%)</option>
				
				<option value="file116">github.com/Beigelman/nossas-despesas/internal/pkg/eon/life_cycle_manager.go (52.6%)</option>
				
				<option value="file117">github.com/Beigelman/nossas-despesas/internal/pkg/eon/modules.go (100.0%)</option>
				
				<option value="file118">github.com/Beigelman/nossas-despesas/internal/pkg/except/http.go (72.7%)</option>
				
				<option value="file119">github.com/Beigelman/nossas-despesas/internal/pkg/except/http_errors.go (66.7%)</option>
				
				<option value="file120">github.com/Beigelman/nossas-despesas/internal/pkg/logger/log.go (0.0%)</option>
				
				<option value="file121">github.com/Beigelman/nossas-despesas/internal/pkg/validator/validator.go (0.0%)</option>
				
				<option value="file122">github.com/Beigelman/nossas-despesas/internal/shared/infra/email/mailtrap_email_provider.go (0.0%)</option>
				
				<option value="file123">github.com/Beigelman/nossas-despesas/internal/shared/infra/email/resend_email_provider.go (0.0%)</option>
				
				<option value="file124">github.com/Beigelman/nossas-despesas/internal/shared/infra/jwt/provider.go (0.0%)</option>
				
				<option value="file125">github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub/publishers.go (0.0%)</option>
				
				<option value="file126">github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub/subscribers.go (0.0%)</option>
				
				<option value="file127">github.com/Beigelman/nossas-despesas/internal/shared/middleware/auth.go (0.0%)</option>
				
				<option value="file128">github.com/Beigelman/nossas-despesas/internal/shared/middleware/log.go (0.0%)</option>
				
				<option value="file129">github.com/Beigelman/nossas-despesas/internal/shared/module.go (0.0%)</option>
				
				<option value="file130">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_auth_Repository.go (45.2%)</option>
				
				<option value="file131">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_category_GroupRepository.go (45.2%)</option>
				
				<option value="file132">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_category_Repository.go (61.9%)</option>
				
				<option value="file133">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_expense_Repository.go (38.0%)</option>
				
				<option value="file134">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_group_InviteRepository.go (48.6%)</option>
				
				<option value="file135">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_group_Repository.go (45.2%)</option>
				
				<option value="file136">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_income_Repository.go (23.8%)</option>
				
				<option value="file137">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_service_EmailProvider.go (22.7%)</option>
				
				<option value="file138">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_service_TokenProvider.go (46.2%)</option>
				
				<option value="file139">github.com/Beigelman/nossas-despesas/internal/tests/mocks/mock_user_Repository.go (61.9%)</option>
				
				<option value="file140">github.com/Beigelman/nossas-despesas/main.go (0.0%)</option>
				
				<option value="file141">github.com/Beigelman/nossas-despesas/scripts/cmd/createusers/cmd.go (0.0%)</option>
				
				<option value="file142">github.com/Beigelman/nossas-despesas/scripts/cmd/importincomes/cmd.go (0.0%)</option>
				
				<option value="file143">github.com/Beigelman/nossas-despesas/scripts/cmd/importsplit/categories_mapper.ts.go (0.0%)</option>
				
				<option value="file144">github.com/Beigelman/nossas-despesas/scripts/cmd/importsplit/cmd.go (0.0%)</option>
				
				<option value="file145">github.com/Beigelman/nossas-despesas/scripts/cmd/importsplit/expense_extractor.go (0.0%)</option>
				
				<option value="file146">github.com/Beigelman/nossas-despesas/scripts/cmd/root.go (0.0%)</option>
				
				<option value="file147">github.com/Beigelman/nossas-despesas/scripts/main.go (0.0%)</option>
				
				<option value="file148">github.com/Beigelman/nossas-despesas/scripts/utils/file.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
        "golang.org/x/crypto/bcrypt"
)

type Type string

var Types = struct {
        Credentials Type
        Google      Type
        MagicLink   Type
}{
        Credentials: "credentials",
        Google:      "google",
        MagicLink:   "magic_link",
}

type ID struct{ Value int }

type Auth struct {
        ddd.Entity[ID]
        Email      string
        Password   *string
        ProviderID *string
        Type       Type
}

type CredentialsAttributes struct {
        ID       ID
        Email    string
        Password string
}

func NewCredentialAuth(attr CredentialsAttributes) (*Auth, error) <span class="cov10" title="8">{
        hashPassword, err := bcrypt.GenerateFromPassword([]byte(attr.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bcrypt.GenerateFromPassword: %w", err)
        }</span>

        <span class="cov10" title="8">sHashPassword := string(hashPassword)

        return &amp;Auth{
                Entity: ddd.Entity[ID]{
                        ID:        attr.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                Email:    attr.Email,
                Password: &amp;sHashPassword,
                Type:     Types.Credentials,
        }, nil</span>
}

type GoogleAuthAttributes struct {
        ID         ID
        Email      string
        ProviderID string
}

func NewGoogleAuth(attr GoogleAuthAttributes) *Auth <span class="cov0" title="0">{
        return &amp;Auth{
                Entity: ddd.Entity[ID]{
                        ID:        attr.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                Email:      attr.Email,
                ProviderID: &amp;attr.ProviderID,
                Type:       Types.Google,
        }
}</span>

func (a *Auth) CheckPassword(password string) bool <span class="cov7" title="5">{
        if a.Password == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov7" title="5">err := bcrypt.CompareHashAndPassword([]byte(*a.Password), []byte(password))
        return err == nil</span>
}

type Claims struct {
        UserID  int
        GroupID *int
        Email   string
}

type Token struct {
        Raw     string
        Claims  Claims
        IsValid bool
}

type Repository interface {
        ddd.Repository[ID, Auth]
        GetByEmail(ctx context.Context, email string, authType Type) (*Auth, error)
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        RefreshAuthTokenRequest struct {
                RefreshToken string `json:"refresh_token" validate:"required"`
        }

        RefreshAuthToken func(ctx *fiber.Ctx) error
)

func NewRefreshAuthToken(refreshAuthToken usecase.RefreshAuthToken) RefreshAuthToken <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req RefreshAuthTokenRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ctx.BodyParser: %w", err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">result, err := refreshAuthToken(ctx.Context(), usecase.RefreshAuthTokenParams{
                        RefreshToken: req.RefreshToken,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("refreshAuthToken: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, UserLogIn{
                                User: UserResponse{
                                        ID:             result.User.ID.Value,
                                        Name:           result.User.Name,
                                        Email:          result.User.Email,
                                        ProfilePicture: result.User.ProfilePicture,
                                        GroupID: func() *int </span><span class="cov0" title="0">{
                                                if result.User.GroupID == nil </span><span class="cov0" title="0">{
                                                        return nil
                                                }</span>
                                                <span class="cov0" title="0">return &amp;result.User.GroupID.Value</span>
                                        }(),
                                        CreatedAt: result.User.CreatedAt,
                                        UpdatedAt: result.User.UpdatedAt,
                                },
                                Token:        result.Token,
                                RefreshToken: result.RefreshToken,
                        }),
                )
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "github.com/gofiber/fiber/v2"
)

func Router(
        server *fiber.App,
        signInWithCredentialsHandler SignInWithCredentials,
        signUpWithCredentialsHandler SignUpWithCredentials,
        signInWithGoogleHandler SignInWithGoogle,
        refreshAuthTokenHandler RefreshAuthToken,
) <span class="cov0" title="0">{
        // Api group
        api := server.Group("api")
        // Api version V1

        v1 := api.Group("v1")
        // Auth routes
        auth := v1.Group("auth")
        auth.Post("/sign-in/credentials", signInWithCredentialsHandler)
        auth.Post("/sign-in/google", signInWithGoogleHandler)
        auth.Post("/sign-up/credentials", signUpWithCredentialsHandler)
        auth.Post("refresh-token", refreshAuthTokenHandler)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        SignInWithCredentialsRequest struct {
                Email    string `json:"email" validate:"required,email"`
                Password string `json:"password" validate:"required"`
        }

        UserResponse struct {
                ID             int         `json:"id"`
                Name           string      `json:"name"`
                Email          string      `json:"email"`
                ProfilePicture *string     `json:"profile_picture,omitempty"`
                GroupID        *int        `json:"group_id,omitempty"`
                Flags          []user.Flag `json:"flags"`
                CreatedAt      time.Time   `json:"created_at"`
                UpdatedAt      time.Time   `json:"updated_at"`
        }

        UserLogIn struct {
                User         UserResponse `json:"user"`
                Token        string       `json:"token"`
                RefreshToken string       `json:"refresh_token"`
        }

        SignInWithCredentials func(ctx *fiber.Ctx) error
)

func NewSignInWithCredentials(signUpWithCredentials usecase.SignInWithCredentials) SignInWithCredentials <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req SignInWithCredentialsRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ctx.BodyParser: %w", err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">result, err := signUpWithCredentials(ctx.Context(), usecase.SignInWithCredentialsParams{
                        Email:    req.Email,
                        Password: req.Password,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("signUpWithCredentials: %w", err)
                }</span>

                <span class="cov0" title="0">var groupID *int
                if result.User.GroupID != nil </span><span class="cov0" title="0">{
                        groupID = &amp;result.User.GroupID.Value
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, UserLogIn{
                                User: UserResponse{
                                        ID:             result.User.ID.Value,
                                        Name:           result.User.Name,
                                        Email:          result.User.Email,
                                        ProfilePicture: result.User.ProfilePicture,
                                        GroupID:        groupID,
                                        Flags:          result.User.Flags,
                                        CreatedAt:      result.User.CreatedAt,
                                        UpdatedAt:      result.User.UpdatedAt,
                                },
                                Token:        result.Token,
                                RefreshToken: result.RefreshToken,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        SignInWithGoogleRequest struct {
                Token string `token:"email" validate:"required"`
        }

        SignInWithGoogle func(ctx *fiber.Ctx) error
)

func NewSignInWithGoogle(signInWithGoogle usecase.SignInWithGoogle) SignInWithGoogle <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req SignInWithGoogleRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ctx.BodyParser: %w", err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">result, err := signInWithGoogle(ctx.Context(), usecase.SignInWithGoogleParams{
                        IdToken: req.Token,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("signInWithGoogle: %w", err)
                }</span>

                <span class="cov0" title="0">var groupID *int
                if result.User.GroupID != nil </span><span class="cov0" title="0">{
                        groupID = &amp;result.User.GroupID.Value
                }</span>
                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, UserLogIn{
                                User: UserResponse{
                                        ID:             result.User.ID.Value,
                                        Name:           result.User.Name,
                                        Email:          result.User.Email,
                                        ProfilePicture: result.User.ProfilePicture,
                                        GroupID:        groupID,
                                        Flags:          result.User.Flags,
                                        CreatedAt:      result.User.CreatedAt,
                                        UpdatedAt:      result.User.UpdatedAt,
                                },
                                Token:        result.Token,
                                RefreshToken: result.RefreshToken,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        SignUpWithCredentialsRequest struct {
                Name            string  `json:"name" validate:"required"`
                Email           string  `json:"email" validate:"required,email"`
                Password        string  `json:"password" validate:"required,min=8"`
                ConfirmPassword string  `json:"confirm_password" validate:"required,min=8"`
                ProfilePicture  *string `json:"profile_picture"`
                GroupID         *int    `json:"group_id"`
        }

        SignUpWithCredentials func(ctx *fiber.Ctx) error
)

func NewSignUpWithCredentials(signUpWithCredentials usecase.SignUpWithCredentials) SignUpWithCredentials <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req SignUpWithCredentialsRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ctx.BodyParser: %w", err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">result, err := signUpWithCredentials(ctx.Context(), usecase.SignUpWithCredentialsParams{
                        Name:                 req.Name,
                        Email:                req.Email,
                        Password:             req.Password,
                        ConfirmationPassword: req.ConfirmPassword,
                        ProfilePicture:       req.ProfilePicture,
                        GroupID: func() *group.ID </span><span class="cov0" title="0">{
                                if req.GroupID == nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return &amp;group.ID{Value: *req.GroupID}</span>
                        }(),
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("signInWithCredentials: %w", err)
                }</span>

                <span class="cov0" title="0">var groupID *int
                if result.User.GroupID != nil </span><span class="cov0" title="0">{
                        groupID = &amp;result.User.GroupID.Value
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, UserLogIn{
                                User: UserResponse{
                                        ID:             result.User.ID.Value,
                                        Name:           result.User.Name,
                                        Email:          result.User.Email,
                                        ProfilePicture: result.User.ProfilePicture,
                                        GroupID:        groupID,
                                        Flags:          result.User.Flags,
                                        CreatedAt:      result.User.CreatedAt,
                                        UpdatedAt:      result.User.UpdatedAt,
                                },
                                Token:        result.Token,
                                RefreshToken: result.RefreshToken,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "context"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth/controller"
        "github.com/Beigelman/nossas-despesas/internal/modules/auth/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/auth/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
)

var Module = eon.NewModule("Auth", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        di.Provide(c, postgres.NewAuthRepository)
        di.Provide(c, usecase.NewSignUpWithCredentials)
        di.Provide(c, usecase.NewSignInWithCredentials)
        di.Provide(c, usecase.NewRefreshAuthToken)
        di.Provide(c, usecase.NewSignInWithGoogle)
        di.Provide(c, controller.NewSignUpWithCredentials)
        di.Provide(c, controller.NewSignInWithCredentials)
        di.Provide(c, controller.NewRefreshAuthToken)
        di.Provide(c, controller.NewSignInWithGoogle)
        // Register Routes
        lc.OnBooted(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{ return di.Call(c, controller.Router) }</span>)
})
</pre>
		
		<pre class="file" id="file7" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type AuthRepository struct {
        db *sqlx.DB
}

func NewAuthRepository(db *db.Client) auth.Repository <span class="cov1" title="1">{
        return &amp;AuthRepository{db: db.Conn()}
}</span>

func (repo *AuthRepository) GetNextID() auth.ID <span class="cov10" title="3">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('authentications_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.Select: %w", err))</span>
        }

        <span class="cov10" title="3">return auth.ID{Value: nextValue}</span>
}

func (repo *AuthRepository) GetByID(ctx context.Context, id auth.ID) (*auth.Auth, error) <span class="cov1" title="1">{
        var model AuthModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, email, password, provider_id, type, created_at, updated_at, deleted_at, version
                FROM authentications WHERE id = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return toEntity(model), nil</span>
}

func (repo *AuthRepository) GetByEmail(ctx context.Context, email string, authType auth.Type) (*auth.Auth, error) <span class="cov1" title="1">{
        var model AuthModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, email, password, provider_id, type, created_at, updated_at, deleted_at, version
                FROM authentications WHERE email = $1 and type = $2
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, email, string(authType)).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return toEntity(model), nil</span>
}

func (repo *AuthRepository) Store(ctx context.Context, entity *auth.Auth) error <span class="cov10" title="3">{
        model := toModel(entity)
        if err := repo.create(ctx, model); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov0" title="0">{
                        if err := repo.update(ctx, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("repo.update: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("repo.create: %w", err)</span>
        }

        <span class="cov10" title="3">return nil</span>
}

func (repo *AuthRepository) create(ctx context.Context, model AuthModel) error <span class="cov10" title="3">{
        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO authentications (id, email, password, provider_id, type, created_at, updated_at, deleted_at, version)
                VALUES (:id, :email, :password, :provider_id, :type, :created_at, :updated_at, :deleted_at, :version)
        `, model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Insert: %w", err)
        }</span>

        <span class="cov10" title="3">return nil</span>
}

func (repo *AuthRepository) update(ctx context.Context, model AuthModel) error <span class="cov0" title="0">{
        result, err := repo.db.NamedExecContext(ctx, `
                UPDATE authentications SET password = :password, updated_at = :updated_at, deleted_at = :deleted_at, version = version + 1
                WHERE id = :id and version = :version
        `, model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: sql: no rows affected")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package postgres

import (
        "database/sql"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

func toEntity(model AuthModel) *auth.Auth <span class="cov6" title="2">{
        var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov6" title="2">var providerID *string
        if model.ProviderID.Valid </span><span class="cov0" title="0">{
                providerID = &amp;model.ProviderID.String
        }</span>

        <span class="cov6" title="2">var password *string
        if model.Password.Valid </span><span class="cov6" title="2">{
                password = &amp;model.Password.String
        }</span>

        <span class="cov6" title="2">return &amp;auth.Auth{
                Entity: ddd.Entity[auth.ID]{
                        ID:        auth.ID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                Email:      model.Email,
                Password:   password,
                ProviderID: providerID,
                Type: func() auth.Type </span><span class="cov6" title="2">{
                        if model.Type == "credentials" </span><span class="cov6" title="2">{
                                return auth.Types.Credentials
                        }</span> else<span class="cov0" title="0"> {
                                return auth.Types.Google
                        }</span>
                }(),
        }
}

func toModel(entity *auth.Auth) AuthModel <span class="cov10" title="3">{
        deletedAt := sql.NullTime{Time: time.Time{}, Valid: false}
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span>

        <span class="cov10" title="3">providerID := sql.NullString{String: "", Valid: false}
        if entity.ProviderID != nil </span><span class="cov0" title="0">{
                providerID = sql.NullString{String: *entity.ProviderID, Valid: true}
        }</span>

        <span class="cov10" title="3">password := sql.NullString{String: "", Valid: false}
        if entity.Password != nil </span><span class="cov10" title="3">{
                password = sql.NullString{String: *entity.Password, Valid: true}
        }</span>

        <span class="cov10" title="3">return AuthModel{
                ID:         entity.ID.Value,
                Email:      entity.Email,
                Password:   password,
                ProviderID: providerID,
                Type: func() string </span><span class="cov10" title="3">{
                        if entity.Type == "credentials" </span><span class="cov10" title="3">{
                                return "credentials"
                        }</span> else<span class="cov0" title="0"> {
                                return "google"
                        }</span>
                }(),
                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: deletedAt,
                Version:   entity.Version,
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/shared/service"
)

type RefreshAuthTokenParams struct {
        RefreshToken string
}

type RefreshAuthTokenResponse struct {
        User         *user.User
        Token        string
        RefreshToken string
}

type RefreshAuthToken func(ctx context.Context, p RefreshAuthTokenParams) (*RefreshAuthTokenResponse, error)

func NewRefreshAuthToken(userRepo user.Repository, tokenProvider service.TokenProvider) RefreshAuthToken <span class="cov1" title="1">{
        return func(ctx context.Context, p RefreshAuthTokenParams) (*RefreshAuthTokenResponse, error) </span><span class="cov10" title="5">{
                token, err := tokenProvider.ParseRefreshToken(p.RefreshToken)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("tokenProvider.ParseToken: %w", err)
                }</span>

                <span class="cov8" title="4">usr, err := userRepo.GetByID(ctx, user.ID{Value: token.Claims.UserID})
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                }</span>

                <span class="cov7" title="3">if usr == nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("user not found")
                }</span>

                <span class="cov4" title="2">authToken, refreshToken, err := tokenProvider.GenerateUserTokens(*usr)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("tokenProvider.GenerateUserTokens: %w", err)
                }</span>

                <span class="cov1" title="1">return &amp;RefreshAuthTokenResponse{
                        User:         usr,
                        Token:        authToken,
                        RefreshToken: refreshToken,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecase

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/shared/service"
)

type SignInWithCredentialsParams struct {
        Email    string
        Password string
}

type SignInWithCredentialsResponse struct {
        User         *user.User
        Token        string
        RefreshToken string
}

type SignInWithCredentials func(ctx context.Context, p SignInWithCredentialsParams) (*SignInWithCredentialsResponse, error)

func NewSignInWithCredentials(userRepo user.Repository, authRepo auth.Repository, tokenProvider service.TokenProvider) SignInWithCredentials <span class="cov1" title="1">{
        return func(ctx context.Context, p SignInWithCredentialsParams) (*SignInWithCredentialsResponse, error) </span><span class="cov10" title="7">{
                credentialAuth, err := authRepo.GetByEmail(ctx, p.Email, auth.Types.Credentials)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("authRepo.GetByEmail: %w", err)
                }</span>

                <span class="cov9" title="6">if credentialAuth == nil </span><span class="cov1" title="1">{
                        return nil, except.BadRequestError("incorrect email or password")
                }</span>

                <span class="cov8" title="5">if !credentialAuth.CheckPassword(p.Password) </span><span class="cov1" title="1">{
                        return nil, except.BadRequestError("incorrect email or password")
                }</span>

                <span class="cov7" title="4">usr, err := userRepo.GetByEmail(ctx, credentialAuth.Email)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.GetByEmail: %w", err)
                }</span>

                <span class="cov6" title="3">if usr == nil </span><span class="cov1" title="1">{
                        slog.Warn("token with user not found", slog.String("email", credentialAuth.Email))
                        return nil, except.NotFoundError("user not found")
                }</span>

                <span class="cov4" title="2">authToken, refreshToken, err := tokenProvider.GenerateUserTokens(*usr)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("tokenProvider.GenerateUserTokens: %w", err)
                }</span>

                <span class="cov1" title="1">return &amp;SignInWithCredentialsResponse{
                        User:         usr,
                        Token:        authToken,
                        RefreshToken: refreshToken,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/shared/service"
        "google.golang.org/api/idtoken"
)

type SignInWithGoogleParams struct {
        IdToken string
}

type SignInWithGoogleResponse struct {
        User         *user.User
        Token        string
        RefreshToken string
}

type SignInWithGoogle func(ctx context.Context, p SignInWithGoogleParams) (*SignInWithGoogleResponse, error)

func NewSignInWithGoogle(userRepo user.Repository, authRepo auth.Repository, tokenProvider service.TokenProvider) SignInWithGoogle <span class="cov0" title="0">{
        return func(ctx context.Context, p SignInWithGoogleParams) (*SignInWithGoogleResponse, error) </span><span class="cov0" title="0">{
                token, err := idtoken.Validate(ctx, p.IdToken, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("idtoken.Validate: %w", err)
                }</span>

                <span class="cov0" title="0">email, ok := token.Claims["email"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, except.UnprocessableEntityError("email not found in token")
                }</span>

                <span class="cov0" title="0">name, ok := token.Claims["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, except.UnprocessableEntityError("user name not found in token")
                }</span>

                <span class="cov0" title="0">providerId, ok := token.Claims["sub"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, except.UnprocessableEntityError("sub not found in token")
                }</span>

                <span class="cov0" title="0">var profilePicture *string
                picture, ok := token.Claims["picture"].(string)
                if !ok </span><span class="cov0" title="0">{
                        profilePicture = nil
                }</span> else<span class="cov0" title="0"> {
                        profilePicture = &amp;picture
                }</span>

                // Check se o usurio j existe
                <span class="cov0" title="0">existingUser, err := userRepo.GetByEmail(ctx, email)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("userRepo.GetByEmail: %w", err)
                }</span>

                <span class="cov0" title="0">var usr *user.User
                if existingUser != nil </span><span class="cov0" title="0">{
                        if existingUser.ProfilePicture == nil &amp;&amp; profilePicture != nil </span><span class="cov0" title="0">{
                                existingUser.ProfilePicture = profilePicture
                                if err := userRepo.Store(ctx, existingUser); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("userRepo.Store: %w", err)
                                }</span>
                        }
                        <span class="cov0" title="0">usr = existingUser</span>
                } else<span class="cov0" title="0"> {
                        usr = user.New(user.Attributes{
                                ID:             userRepo.GetNextID(),
                                Name:           name,
                                Email:          email,
                                ProfilePicture: profilePicture,
                        })

                        if err := userRepo.Store(ctx, usr); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("userRepo.Store: %w", err)
                        }</span>
                }

                // Check se a autenticao j existe
                <span class="cov0" title="0">existingAuth, err := authRepo.GetByEmail(ctx, email, auth.Types.Google)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("authRepo.GetByEmail: %w", err)
                }</span>
                // TODO: isso aqui faz sentido?? No deveria ser == nil?
                <span class="cov0" title="0">if existingAuth != nil </span><span class="cov0" title="0">{
                        authentic := auth.NewGoogleAuth(auth.GoogleAuthAttributes{
                                ID:         authRepo.GetNextID(),
                                Email:      email,
                                ProviderID: providerId,
                        })

                        if err := authRepo.Store(ctx, authentic); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("authRepo.Store: %w", err)
                        }</span>
                }

                // Gerao do token de autenticao
                <span class="cov0" title="0">authToken, refreshToken, err := tokenProvider.GenerateUserTokens(*usr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("tokenProvider.GenerateUserTokens: %w", err)
                }</span>

                <span class="cov0" title="0">return &amp;SignInWithGoogleResponse{
                        User:         usr,
                        Token:        authToken,
                        RefreshToken: refreshToken,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/shared/service"
)

type SignUpWithCredentialsParams struct {
        Name                 string
        Email                string
        Password             string
        ConfirmationPassword string
        ProfilePicture       *string
        GroupID              *group.ID
}

type SignUpWithCredentialsResponse struct {
        User         *user.User
        Token        string
        RefreshToken string
}

type SignUpWithCredentials func(ctx context.Context, p SignUpWithCredentialsParams) (*SignUpWithCredentialsResponse, error)

func NewSignUpWithCredentials(userRepo user.Repository, authRepo auth.Repository, tokenProvider service.TokenProvider) SignUpWithCredentials <span class="cov1" title="1">{
        return func(ctx context.Context, p SignUpWithCredentialsParams) (*SignUpWithCredentialsResponse, error) </span><span class="cov10" title="7">{
                existingAuth, err := authRepo.GetByEmail(ctx, p.Email, auth.Types.Credentials)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("authRepo.GetByEmail: %w", err)
                }</span>

                <span class="cov9" title="6">if existingAuth != nil </span><span class="cov1" title="1">{
                        return nil, except.BadRequestError("email already registered")
                }</span>

                <span class="cov8" title="5">if p.Password != p.ConfirmationPassword </span><span class="cov1" title="1">{
                        return nil, except.UnprocessableEntityError("passwords do not match")
                }</span>

                <span class="cov7" title="4">existingUser, err := userRepo.GetByEmail(ctx, p.Email)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.GetByEmail: %w", err)
                }</span>

                <span class="cov6" title="3">var usr *user.User
                if existingUser != nil </span><span class="cov6" title="3">{
                        usr = existingUser
                }</span> else<span class="cov0" title="0"> {
                        usr = user.New(user.Attributes{
                                ID:             userRepo.GetNextID(),
                                Name:           p.Name,
                                Email:          p.Email,
                                ProfilePicture: p.ProfilePicture,
                                GroupID:        p.GroupID,
                        })

                        if err := userRepo.Store(ctx, usr); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("userRepo.Store: %w", err)
                        }</span>
                }

                <span class="cov6" title="3">authentic, err := auth.NewCredentialAuth(auth.CredentialsAttributes{
                        ID:       authRepo.GetNextID(),
                        Email:    usr.Email,
                        Password: p.Password,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("auth.NewCredentialAuth: %w", err)
                }</span>

                <span class="cov6" title="3">if err := authRepo.Store(ctx, authentic); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("authRepo.Store: %w", err)
                }</span>

                <span class="cov4" title="2">authToken, refreshToken, err := tokenProvider.GenerateUserTokens(*usr)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("tokenProvider.GenerateUserTokens: %w", err)
                }</span>

                <span class="cov1" title="1">return &amp;SignUpWithCredentialsResponse{
                        User:         usr,
                        Token:        authToken,
                        RefreshToken: refreshToken,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package category

import (
        "context"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type ID struct{ Value int }

type Category struct {
        ddd.Entity[ID]
        Name            string
        Icon            string
        GroupCategoryID GroupID
}

type Attributes struct {
        ID              ID
        Name            string
        Icon            string
        CategoryGroupID GroupID
}

func New(p Attributes) *Category <span class="cov10" title="9">{
        return &amp;Category{
                Entity: ddd.Entity[ID]{
                        ID:        p.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        DeletedAt: nil,
                },
                Name:            p.Name,
                Icon:            p.Icon,
                GroupCategoryID: p.CategoryGroupID,
        }
}</span>

type Repository interface {
        ddd.Repository[ID, Category]
        GetByName(ctx context.Context, name string) (*Category, error)
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/category/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        CreateCategory func(ctx *fiber.Ctx) error

        CreateCategoryRequest struct {
                Icon            string `json:"icon" validate:"required"`
                Name            string `json:"name" validate:"required"`
                CategoryGroupID int    `json:"category_group_id" validate:"required"`
        }

        CreateCategoryResponse struct {
                ID   int    `json:"id"`
                Name string `json:"name"`
        }
)

func NewCreateCategory(createCategory usecase.CreateCategory) CreateCategory <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req CreateCategoryRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">group, err := createCategory(ctx.Context(), usecase.CreateCategoryInput{
                        Name:            req.Name,
                        Icon:            req.Icon,
                        CategoryGroupID: category.GroupID{Value: req.CategoryGroupID},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("createCategory: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, CreateCategoryResponse{
                                ID:   group.ID.Value,
                                Name: group.Name,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/category/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        CreateCategoryGroup func(ctx *fiber.Ctx) error

        CreateCategoryGroupRequest struct {
                Icon string `json:"icon" validate:"required"`
                Name string `json:"name" validate:"required"`
        }

        CreateCategoryGroupResponse struct {
                ID   int    `json:"id"`
                Name string `json:"name"`
        }
)

func NewCreateCategoryGroup(createCategoryGroup usecase.CreateCategoryGroup) CreateCategoryGroup <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req CreateCategoryGroupRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">categoryGroup, err := createCategoryGroup(ctx.Context(), usecase.CreateCategoryGroupInput{
                        Name: req.Name,
                        Icon: req.Icon,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("createCategoryGroup: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, CreateCategoryGroupResponse{
                                ID:   categoryGroup.ID.Value,
                                Name: categoryGroup.Name,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/category/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/gofiber/fiber/v2"
)

type GetCategories func(ctx *fiber.Ctx) error

func NewGetCategories(getCategories postgres.GetCategories) GetCategories <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                categories, err := getCategories(ctx.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.getCategories: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, categories))</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package controller

import (
        "github.com/Beigelman/nossas-despesas/internal/shared/middleware"
        "github.com/gofiber/fiber/v2"
)

func Router(
        server *fiber.App,
        createCategoryHandler CreateCategory,
        createCategoryGroupHandler CreateCategoryGroup,
        getCategoriesHandler GetCategories,
        authMiddleware middleware.AuthMiddleware,
) <span class="cov0" title="0">{
        // Api group
        api := server.Group("api")
        // Api version V1
        v1 := api.Group("v1")
        // Category routes
        category := v1.Group("category", authMiddleware)
        category.Get("/", getCategoriesHandler)
        category.Post("/", createCategoryHandler)
        category.Post("/group", createCategoryGroupHandler)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package category

import (
        "context"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type GroupID struct{ Value int }

type Group struct {
        ddd.Entity[GroupID]
        Name string
        Icon string
}

type GroupAttributes struct {
        ID   GroupID
        Name string
        Icon string
}

func NewGroup(p GroupAttributes) *Group <span class="cov10" title="7">{
        return &amp;Group{
                Entity: ddd.Entity[GroupID]{
                        ID:        p.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                Name: p.Name,
                Icon: p.Icon,
        }
}</span>

type GroupRepository interface {
        ddd.Repository[GroupID, Group]
        GetByName(ctx context.Context, name string) (*Group, error)
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package category

import (
        "context"

        "github.com/Beigelman/nossas-despesas/internal/modules/category/controller"
        "github.com/Beigelman/nossas-despesas/internal/modules/category/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/category/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
)

var Module = eon.NewModule("Category", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        di.Provide(c, postgres.NewCategoryRepository)
        di.Provide(c, postgres.NewCategoryGroupRepository)
        di.Provide(c, usecase.NewCreateCategory)
        di.Provide(c, usecase.NewCreateCategoryGroup)
        di.Provide(c, postgres.NewGetCategories)
        di.Provide(c, controller.NewGetCategories)
        di.Provide(c, controller.NewCreateCategory)
        di.Provide(c, controller.NewCreateCategoryGroup)
        // Register routes
        lc.OnBooted(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{ return di.Call(c, controller.Router) }</span>)
})
</pre>
		
		<pre class="file" id="file20" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type CategoryGroupRepository struct {
        db *sqlx.DB
}

func NewCategoryGroupRepository(db *db.Client) category.GroupRepository <span class="cov1" title="1">{
        return &amp;CategoryGroupRepository{db: db.Conn()}
}</span>

func (repo *CategoryGroupRepository) GetNextID() category.GroupID <span class="cov10" title="3">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('category_groups_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.QueryRow: %w", err))</span>
        }

        <span class="cov10" title="3">return category.GroupID{Value: nextValue}</span>
}

func (repo *CategoryGroupRepository) GetByName(ctx context.Context, name string) (*category.Group, error) <span class="cov1" title="1">{
        var model CategoryGroupModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, icon, created_at, updated_at, deleted_at, version
                FROM category_groups WHERE name = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, name).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.QueryRowContext: %w", err)</span>
        }

        <span class="cov1" title="1">return groupCategoryToEntity(model), nil</span>
}

func (repo *CategoryGroupRepository) GetByID(ctx context.Context, id category.GroupID) (*category.Group, error) <span class="cov1" title="1">{
        var model CategoryGroupModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, icon, created_at, updated_at, deleted_at, version
                FROM category_groups WHERE id = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.QueryRowContext: %w", err)</span>
        }

        <span class="cov1" title="1">return groupCategoryToEntity(model), nil</span>
}

func (repo *CategoryGroupRepository) Store(ctx context.Context, entity *category.Group) error <span class="cov10" title="3">{
        model := groupCategoryToModel(entity)
        if err := repo.create(ctx, model); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov0" title="0">{
                        if err := repo.update(ctx, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("repo.update: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("repo.create: %w", err)</span>
        }

        <span class="cov10" title="3">return nil</span>
}

func (repo *CategoryGroupRepository) create(ctx context.Context, model CategoryGroupModel) error <span class="cov10" title="3">{
        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO category_groups (id, name, icon, created_at, updated_at, deleted_at, version)
                VALUES (:id, :name, :icon, :created_at, :updated_at, :deleted_at, :version)
        `, model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Insert: %w", err)
        }</span>

        <span class="cov10" title="3">return nil</span>
}

func (repo *CategoryGroupRepository) update(ctx context.Context, model CategoryGroupModel) error <span class="cov0" title="0">{
        result, err := repo.db.NamedExecContext(ctx, `
                UPDATE category_groups SET name = :name, icon = :icon, updated_at = :updated_at, deleted_at = :deleted_at, version = version + 1
                WHERE id = :id and version = :version
        `, model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: sql: no rows affected")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type CategoryRepository struct {
        db *sqlx.DB
}

func NewCategoryRepository(db *db.Client) category.Repository <span class="cov1" title="1">{
        return &amp;CategoryRepository{db: db.Conn()}
}</span>

func (repo *CategoryRepository) GetNextID() category.ID <span class="cov10" title="3">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('categories_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.QueryRow: %w", err))</span>
        }

        <span class="cov10" title="3">return category.ID{Value: nextValue}</span>
}

func (repo *CategoryRepository) GetByName(ctx context.Context, name string) (*category.Category, error) <span class="cov1" title="1">{
        var model CategoryModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, icon, category_group_id,created_at, updated_at, deleted_at, version
                FROM categories WHERE name = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, name).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.QueryRowContext: %w", err)</span>
        }

        <span class="cov1" title="1">return categoryToEntity(model), nil</span>
}

func (repo *CategoryRepository) GetByID(ctx context.Context, id category.ID) (*category.Category, error) <span class="cov1" title="1">{
        var model CategoryModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, icon, category_group_id, created_at, updated_at, deleted_at, version
                FROM categories WHERE id = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.QueryRowContext: %w", err)</span>
        }

        <span class="cov1" title="1">return categoryToEntity(model), nil</span>
}

func (repo *CategoryRepository) Store(ctx context.Context, entity *category.Category) error <span class="cov10" title="3">{
        model := categoryToModel(entity)
        if err := repo.create(ctx, model); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov0" title="0">{
                        if err := repo.update(ctx, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("repo.update: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("repo.create: %w", err)</span>
        }

        <span class="cov10" title="3">return nil</span>
}

func (repo *CategoryRepository) create(ctx context.Context, model CategoryModel) error <span class="cov10" title="3">{
        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO categories (id, name, icon, category_group_id, created_at, updated_at, deleted_at, version)
                VALUES (:id, :name, :icon, :category_group_id,  :created_at, :updated_at, :deleted_at, :version)
        `, model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Insert: %w", err)
        }</span>

        <span class="cov10" title="3">return nil</span>
}

func (repo *CategoryRepository) update(ctx context.Context, model CategoryModel) error <span class="cov0" title="0">{
        result, err := repo.db.NamedExecContext(ctx, `
                UPDATE categories SET name = :name, icon = :icon, category_group_id = :category_group_id, updated_at = :updated_at, deleted_at = :deleted_at, version = version + 1
                WHERE id = :id and version = :version
        `, model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: sql: no rows affected")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        Category struct {
                ID              int    `db:"id" json:"id"`
                Name            string `db:"name" json:"name"`
                Icon            string `db:"icon" json:"icon"`
                CategoryGroupID int    `db:"category_group_id" json:"-"`
        }

        CategoryGroup struct {
                ID         int        `db:"id" json:"id"`
                Name       string     `db:"name" json:"name"`
                Icon       string     `db:"icon" json:"icon"`
                Categories []Category `json:"categories"`
        }

        GetCategories func(ctx context.Context) ([]CategoryGroup, error)
)

func NewGetCategories(db *db.Client) GetCategories <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context) ([]CategoryGroup, error) </span><span class="cov0" title="0">{
                var categories []Category
                if err := dbClient.SelectContext(ctx, &amp;categories, `
                        select
                            id,
                                name,
                                icon,
                                category_group_id
                        from categories c
                        where c.deleted_at is null
                `); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">var categoryGroups []CategoryGroup
                if err := dbClient.SelectContext(ctx, &amp;categoryGroups, `
                        select
                            id,
                                name,
                                icon
                        from category_groups c
                        where c.deleted_at is null
                `); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">for i, categoryGroup := range categoryGroups </span><span class="cov0" title="0">{
                        for _, category := range categories </span><span class="cov0" title="0">{
                                if category.CategoryGroupID == categoryGroup.ID </span><span class="cov0" title="0">{
                                        categoryGroups[i].Categories = append(categoryGroups[i].Categories, category)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return categoryGroups, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package postgres

import (
        "database/sql"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

func categoryToEntity(model CategoryModel) *category.Category <span class="cov6" title="2">{
        var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov6" title="2">return &amp;category.Category{
                Entity: ddd.Entity[category.ID]{
                        ID:        category.ID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                Name:            model.Name,
                Icon:            model.Icon,
                GroupCategoryID: category.GroupID{Value: model.CategoryGroupID},
        }</span>
}

func categoryToModel(entity *category.Category) CategoryModel <span class="cov10" title="3">{
        var deletedAt sql.NullTime
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span> else<span class="cov10" title="3"> {
                deletedAt = sql.NullTime{Time: time.Time{}, Valid: false}
        }</span>

        <span class="cov10" title="3">return CategoryModel{
                ID:              entity.ID.Value,
                Name:            entity.Name,
                Icon:            entity.Icon,
                CategoryGroupID: entity.GroupCategoryID.Value,
                CreatedAt:       entity.CreatedAt,
                UpdatedAt:       entity.UpdatedAt,
                DeletedAt:       deletedAt,
                Version:         entity.Version,
        }</span>
}

func groupCategoryToEntity(model CategoryGroupModel) *category.Group <span class="cov6" title="2">{
        var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov6" title="2">return &amp;category.Group{
                Entity: ddd.Entity[category.GroupID]{
                        ID:        category.GroupID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                Name: model.Name,
                Icon: model.Icon,
        }</span>
}

func groupCategoryToModel(entity *category.Group) CategoryGroupModel <span class="cov10" title="3">{
        var deletedAt sql.NullTime
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span> else<span class="cov10" title="3"> {
                deletedAt = sql.NullTime{Time: time.Time{}, Valid: false}
        }</span>

        <span class="cov10" title="3">return CategoryGroupModel{
                ID:        entity.ID.Value,
                Name:      entity.Name,
                Icon:      entity.Icon,
                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: deletedAt,
                Version:   entity.Version,
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type CreateCategoryInput struct {
        Name            string
        Icon            string
        CategoryGroupID category.GroupID
}

type CreateCategory func(ctx context.Context, input CreateCategoryInput) (*category.Category, error)

func NewCreateCategory(categoryRepo category.Repository) CreateCategory <span class="cov1" title="1">{
        return func(ctx context.Context, input CreateCategoryInput) (*category.Category, error) </span><span class="cov10" title="4">{
                alreadyExists, err := categoryRepo.GetByName(ctx, input.Name)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("categoryRepo.GetByName: %w", err)
                }</span>

                <span class="cov8" title="3">if alreadyExists != nil </span><span class="cov1" title="1">{
                        return nil, except.ConflictError("category already exists")
                }</span>

                <span class="cov5" title="2">categoryID := categoryRepo.GetNextID()

                newCategory := category.New(category.Attributes{
                        ID:              categoryID,
                        Name:            input.Name,
                        Icon:            input.Icon,
                        CategoryGroupID: input.CategoryGroupID,
                })

                if err := categoryRepo.Store(ctx, newCategory); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("categoryRepo.Store: %w", err)
                }</span>

                <span class="cov1" title="1">return newCategory, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type CreateCategoryGroupInput struct {
        Name string
        Icon string
}

type CreateCategoryGroup func(ctx context.Context, input CreateCategoryGroupInput) (*category.Group, error)

func NewCreateCategoryGroup(categoryGroupRepo category.GroupRepository) CreateCategoryGroup <span class="cov1" title="1">{
        return func(ctx context.Context, input CreateCategoryGroupInput) (*category.Group, error) </span><span class="cov10" title="4">{
                alreadyExists, err := categoryGroupRepo.GetByName(ctx, input.Name)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("categoryGroupRepo.GetByName: %w", err)
                }</span>

                <span class="cov8" title="3">if alreadyExists != nil </span><span class="cov1" title="1">{
                        return nil, except.ConflictError("category already exists")
                }</span>

                <span class="cov5" title="2">categoryGroupID := categoryGroupRepo.GetNextID()

                categoryGroup := category.NewGroup(category.GroupAttributes{
                        ID:   categoryGroupID,
                        Name: input.Name,
                        Icon: input.Icon,
                })

                if err := categoryGroupRepo.Store(ctx, categoryGroup); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("categoryGroupRepo.Store: %w", err)
                }</span>

                <span class="cov1" title="1">return categoryGroup, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        vo "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        CreateExpense func(ctx *fiber.Ctx) error

        CreateExpenseRequest struct {
                Name        string     `json:"name" validate:"required"`
                Amount      int        `json:"amount" validate:"required"`
                Description string     `json:"description"`
                CategoryID  int        `json:"category_id" validate:"required"`
                SplitType   string     `json:"split_type" validate:"required,oneof=equal proportional transfer"`
                PayerID     int        `json:"payer_id" validate:"required"`
                ReceiverID  int        `json:"receiver_id" validate:"required"`
                CreatedAt   *time.Time `json:"created_at"`
        }

        CreateExpenseResponse struct {
                ID         int     `json:"id"`
                Name       string  `json:"name"`
                Amount     float32 `json:"amount"`
                PayerID    int     `json:"payer_id"`
                ReceiverID int     `json:"receiver_id"`
        }
)

func NewCreateExpense(createExpense usecase.CreateExpense) CreateExpense <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req CreateExpenseRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError("group_id not found in context")
                }</span>

                <span class="cov0" title="0">expense, err := createExpense(ctx.Context(), usecase.CreateExpenseParams{
                        GroupID:     group.ID{Value: groupID},
                        Name:        req.Name,
                        Amount:      req.Amount,
                        Description: req.Description,
                        CategoryID:  category.ID{Value: req.CategoryID},
                        SplitType:   vo.SplitType(req.SplitType),
                        PayerID:     user.ID{Value: req.PayerID},
                        ReceiverID:  user.ID{Value: req.ReceiverID},
                        CreatedAt:   req.CreatedAt,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("CreateExpense: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, CreateExpenseResponse{
                                ID:         expense.ID.Value,
                                Name:       expense.Name,
                                Amount:     float32(expense.Amount) / 100,
                                PayerID:    expense.PayerID.Value,
                                ReceiverID: expense.ReceiverID.Value,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub"
)

type CreateExpenseFromScheduled func(ctx context.Context) error

func NewCreateExpenseFromScheduled(
        subscriber pubsub.Subscriber,
        createExpense usecase.CreateExpense,
) CreateExpenseFromScheduled <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                messages, err := subscriber.Subscribe(ctx, pubsub.ExpensesTopic)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("subscriber.Subscribe: %w", err)
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        slog.InfoContext(ctx, "Listening to expenses topic...")
                        for msg := range messages </span><span class="cov0" title="0">{
                                var payload pubsub.ExpenseEvent
                                if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                                        msg.Nack()
                                        continue</span>
                                }

                                <span class="cov0" title="0">if _, err := createExpense(ctx, usecase.CreateExpenseParams{
                                        GroupID:     payload.GroupID,
                                        Name:        payload.Expense.Name,
                                        Amount:      payload.Expense.Amount,
                                        Description: payload.Expense.Description,
                                        CategoryID:  payload.Expense.CategoryID,
                                        SplitType:   payload.Expense.SplitType,
                                        PayerID:     payload.Expense.PayerID,
                                        ReceiverID:  payload.Expense.ReceiverID,
                                        CreatedAt:   &amp;payload.Expense.CreatedAt,
                                }); err != nil </span><span class="cov0" title="0">{
                                        slog.ErrorContext(ctx, "failed to create expense from scheduled", "error", err)
                                        msg.Nack()
                                        continue</span>
                                }

                                <span class="cov0" title="0">msg.Ack()</span>
                        }
                }()

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "cloud.google.com/go/civil"
        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        vo "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type CreateScheduledExpenseRequest struct {
        Name            string     `json:"name" validate:"required"`
        Amount          int        `json:"amount" validate:"required"`
        Description     string     `json:"description" validate:"required"`
        CategoryID      int        `json:"category_id" validate:"required"`
        SplitType       string     `json:"split_type" validate:"required"`
        PayerID         int        `json:"payer_id" validate:"required"`
        ReceiverID      int        `json:"receiver_id" validate:"required"`
        FrequencyInDays int        `json:"frequency_in_days" validate:"required"`
        LastGeneratedAt *time.Time `json:"last_generated_at"`
}

type CreateScheduledExpense func(ctx *fiber.Ctx) error

func NewCreateScheduledExpense(createScheduledExpense usecase.CreateScheduledExpense) CreateScheduledExpense <span class="cov0" title="0">{
        valid := validator.New()
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req CreateScheduledExpenseRequest
                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">groupID, ok := c.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError("group_id not found in context")
                }</span>

                <span class="cov0" title="0">var lastGeneratedAt *civil.Date
                if req.LastGeneratedAt != nil </span><span class="cov0" title="0">{
                        date := civil.DateOf(*req.LastGeneratedAt)
                        lastGeneratedAt = &amp;date
                }</span>

                <span class="cov0" title="0">err := createScheduledExpense(c.Context(), usecase.CreateScheduledExpenseInput{
                        Name:            req.Name,
                        Amount:          req.Amount,
                        Description:     req.Description,
                        GroupID:         group.ID{Value: groupID},
                        CategoryID:      category.ID{Value: req.CategoryID},
                        SplitType:       vo.SplitType(req.SplitType),
                        PayerID:         user.ID{Value: req.PayerID},
                        ReceiverID:      user.ID{Value: req.ReceiverID},
                        FrequencyInDays: req.FrequencyInDays,
                        LastGeneratedAt: lastGeneratedAt,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("CreateScheduledExpense: %w", err)
                }</span>

                <span class="cov0" title="0">return c.SendStatus(http.StatusCreated)</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "strconv"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        DeleteExpense func(ctx *fiber.Ctx) error

        DeleteExpenseRequest struct {
                GroupID     int    `json:"group_id" validate:"required"`
                Name        string `json:"name" validate:"required"`
                Amount      int    `json:"amount" validate:"required"`
                Description string `json:"description"`
                CategoryID  int    `json:"category_id" validate:"required"`
                SplitRatio  struct {
                        Payer    int `json:"payer" validate:"required"`
                        Receiver int `json:"receiver" validate:"required"`
                } `json:"split_ratio" validate:"required"`
                PayerID    int `json:"payer_id" validate:"required"`
                ReceiverID int `json:"receiver_id" validate:"required"`
        }

        DeleteExpenseResponse struct {
                ID int `json:"id"`
        }
)

func NewDeleteExpense(deleteExpense usecase.DeleteExpense) DeleteExpense <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                expenseID, err := strconv.Atoi(ctx.Params("expense_id"))
                if err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid expense id")
                }</span>

                <span class="cov0" title="0">expns, err := deleteExpense(ctx.Context(), expense.ID{Value: expenseID})
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("DeleteExpense: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(
                        api.NewResponse(http.StatusOK, DeleteExpenseResponse{
                                ID: expns.ID.Value,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package controller

import (
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/gofiber/fiber/v2"
)

type GenerateExpensesFromScheduled func(ctx *fiber.Ctx) error

func NewGenerateExpensesFromScheduled(generateExpensesFromScheduled usecase.GenerateExpensesFromScheduledUseCase) GenerateExpensesFromScheduled <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                ctx := c.Context()
                expensesCreated, err := generateExpensesFromScheduled(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("GenerateExpensesFromScheduled: %w", err)
                }</span>

                <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(fiber.Map{
                        "expenses_created": expensesCreated,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "strconv"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        GetExpenseDetails func(ctx *fiber.Ctx) error
)

func NewGetExpenseDetails(getExpenseDetails postgres.GetExpenseDetails) GetExpenseDetails <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">expenseID, err := strconv.Atoi(ctx.Params("expense_id"))
                if err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid expense id")
                }</span>

                <span class="cov0" title="0">expenseDetails, err := getExpenseDetails(ctx.Context(), expenseID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.GetExpenseDetails: %w", err)
                }</span>

                <span class="cov0" title="0">if len(expenseDetails) == 0 </span><span class="cov0" title="0">{
                        return except.NotFoundError("expense not found")
                }</span>

                <span class="cov0" title="0">if expenseDetails[0].GroupID != groupID </span><span class="cov0" title="0">{
                        return except.ForbiddenError("group mismatch")
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, expenseDetails))</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package controller

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        GetExpenses func(ctx *fiber.Ctx) error

        GetExpensesCursor struct {
                LastExpenseID   int       `json:"last_expense_id"`
                LastExpenseDate time.Time `json:"last_expense_date"`
        }

        GetExpensesResponse struct {
                Expenses  []postgres.ExpenseDetails `json:"expenses"`
                NextToken string                    `json:"next_token"`
        }
)

func NewGetExpenses(getGroupExpenses postgres.GetExpenses) GetExpenses <span class="cov0" title="0">{
        const defaultLimit = 25

        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">token, err := decodeCursor(ctx.Query("next_token", ""))
                if err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid next token").SetInternal(err)
                }</span>

                <span class="cov0" title="0">search := ctx.Query("search")

                expenses, err := getGroupExpenses(ctx.Context(), postgres.GetExpensesInput{
                        GroupID:         groupID,
                        LastExpenseDate: token.LastExpenseDate,
                        LastExpenseID:   token.LastExpenseID,
                        Limit:           defaultLimit,
                        Search:          search,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.GetExpenses: %w", err)
                }</span>

                <span class="cov0" title="0">nextToken := ""
                if len(expenses) == defaultLimit </span><span class="cov0" title="0">{
                        lastExpense := expenses[len(expenses)-1]
                        nextToken, err = encodeCursor(&amp;GetExpensesCursor{
                                LastExpenseDate: lastExpense.CreatedAt,
                                LastExpenseID:   lastExpense.ID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("encodeCursor: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, GetExpensesResponse{
                        Expenses:  expenses,
                        NextToken: nextToken,
                }))</span>
        }
}

func encodeCursor(cursor *GetExpensesCursor) (string, error) <span class="cov0" title="0">{
        serializedCursor, err := json.Marshal(cursor)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(serializedCursor), nil</span>
}

func decodeCursor(cursor string) (*GetExpensesCursor, error) <span class="cov0" title="0">{
        decodedCursor, err := base64.StdEncoding.DecodeString(cursor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if string(decodedCursor) == "" </span><span class="cov0" title="0">{
                return &amp;GetExpensesCursor{
                        LastExpenseDate: time.Now().AddDate(0, 2, 0),
                }, nil
        }</span>

        <span class="cov0" title="0">var cur *GetExpensesCursor
        if err := json.Unmarshal(decodedCursor, &amp;cur); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cur, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type GetExpensesPerCategory func(ctx *fiber.Ctx) error

type GetExpensesPerCategoryReq struct {
        StartDate time.Time `query:"start_date"`
        EndDate   time.Time `query:"end_date"`
}

func NewGetExpensesPerCategory(getExpensesPerCategory postgres.GetExpensesPerCategory) GetExpensesPerCategory <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">var params GetExpensesPerCategoryReq
                if err := ctx.QueryParser(&amp;params); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">expensesPerCategory, err := getExpensesPerCategory(ctx.Context(), postgres.GetExpensesPerCategoryInput{
                        GroupID:   groupID,
                        StartDate: params.StartDate,
                        EndDate:   params.EndDate,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.getExpensesPerCategory: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, expensesPerCategory))</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type GetExpensesPerPeriod func(ctx *fiber.Ctx) error

type GetExpensesPerPeriodReq struct {
        Aggregate string    `query:"aggregate"`
        StartDate time.Time `query:"start_date"`
        EndDate   time.Time `query:"end_date"`
}

func NewGetExpensesPerPeriod(getExpensesPerCategory postgres.GetExpensesPerPeriod) GetExpensesPerPeriod <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">var params GetExpensesPerPeriodReq
                if err := ctx.QueryParser(&amp;params); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">expensesPerPeriod, err := getExpensesPerCategory(ctx.Context(), postgres.GetExpensesPerPeriodInput{
                        GroupID:   groupID,
                        Aggregate: params.Aggregate,
                        StartDate: params.StartDate,
                        EndDate:   params.EndDate,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.GetExpensesPerPeriod: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, expensesPerPeriod))</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub"
)

type RecalculateExpensesSplitRatio func(ctx context.Context) error

func NewRecalculateExpensesSplitRatio(
        subscriber pubsub.Subscriber,
        recalculateExpenses usecase.RecalculateExpensesSplitRatio,
) RecalculateExpensesSplitRatio <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                messages, err := subscriber.Subscribe(ctx, pubsub.IncomesTopic)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("subscriber.Subscribe: %w", err)
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        slog.InfoContext(ctx, "Listening to incomes topic...")
                        for msg := range messages </span><span class="cov0" title="0">{
                                var payload pubsub.IncomeEvent
                                if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                                        msg.Nack()
                                        continue</span>
                                }

                                <span class="cov0" title="0">if err := recalculateExpenses(ctx, usecase.RecalculateExpensesSplitRatioInput{
                                        EventName: payload.Type,
                                        GroupID:   payload.GroupID,
                                        Date:      payload.Income.CreatedAt,
                                }); err != nil </span><span class="cov0" title="0">{
                                        slog.ErrorContext(ctx, "failed to recalculate expenses spit ratio", "error", err)
                                        msg.Nack()
                                        continue</span>
                                }

                                <span class="cov0" title="0">msg.Ack()</span>
                        }
                }()

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package controller

import (
        "github.com/Beigelman/nossas-despesas/internal/shared/middleware"
        "github.com/gofiber/fiber/v2"
)

func Router(
        server *fiber.App,
        createExpenseHandler CreateExpense,
        getExpensesHandler GetExpenses,
        updateExpenseHandler UpdateExpense,
        deleteExpenseHandler DeleteExpense,
        getExpensesPerCategoryHandler GetExpensesPerCategory,
        getExpensesPerPeriodHandler GetExpensesPerPeriod,
        getExpenseDetailsHandler GetExpenseDetails,
        generateExpensesFromScheduledHandler GenerateExpensesFromScheduled,
        createScheduledExpenseHandler CreateScheduledExpense,
        authMiddleware middleware.AuthMiddleware,
) <span class="cov0" title="0">{
        // Api group
        api := server.Group("api")
        // Api version V1
        v1 := api.Group("v1")
        // Expense routes
        expense := v1.Group("expenses")
        expense.Post("/", authMiddleware, createExpenseHandler)
        expense.Get("/", authMiddleware, getExpensesHandler)
        expense.Get("/:expense_id/details", authMiddleware, getExpenseDetailsHandler)
        expense.Patch("/:expense_id", authMiddleware, updateExpenseHandler)
        expense.Delete("/:expense_id", authMiddleware, deleteExpenseHandler)
        expense.Post("/scheduled", authMiddleware, createScheduledExpenseHandler)
        // Generate expenses from scheduled does not need auth
        expense.Post("/scheduled/generate", generateExpensesFromScheduledHandler)

        // Expenses insights routes
        insights := expense.Group("insights", authMiddleware)
        insights.Get("/", getExpensesPerPeriodHandler)
        insights.Get("/category", getExpensesPerCategoryHandler)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        UpdateExpense func(ctx *fiber.Ctx) error

        UpdateExpenseRequest struct {
                Name         *string    `json:"name"`
                Amount       *int       `json:"amount"`
                RefundAmount *int       `json:"refund_amount"`
                Description  *string    `json:"description"`
                CategoryID   *int       `json:"category_id"`
                SplitType    *string    `json:"split_type" validate:"omitempty,oneof=equal proportional transfer"`
                PayerID      *int       `json:"payer_id"`
                ReceiverID   *int       `json:"receiver_id"`
                CreatedAt    *time.Time `json:"created_at"`
        }

        UpdateExpenseResponse struct {
                ID         int     `json:"id"`
                Name       string  `json:"name"`
                Amount     float32 `json:"amount"`
                PayerID    int     `json:"payer_id"`
                ReceiverID int     `json:"receiver_id"`
        }
)

func NewUpdateExpense(updateExpense usecase.UpdateExpense) UpdateExpense <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                expenseID, err := strconv.Atoi(ctx.Params("expense_id"))
                if err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid expense id")
                }</span>

                <span class="cov0" title="0">var req UpdateExpenseRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">expns, err := updateExpense(ctx.Context(), usecase.UpdateExpenseParams{
                        ID:           expense.ID{Value: expenseID},
                        Name:         req.Name,
                        Amount:       req.Amount,
                        RefundAmount: req.RefundAmount,
                        Description:  req.Description,
                        CategoryID: func() *category.ID </span><span class="cov0" title="0">{
                                if req.CategoryID != nil </span><span class="cov0" title="0">{
                                        return &amp;category.ID{Value: *req.CategoryID}
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        SplitType: func() *expense.SplitType <span class="cov0" title="0">{
                                if req.SplitType != nil </span><span class="cov0" title="0">{
                                        splitType := expense.SplitType(*req.SplitType)
                                        return &amp;splitType
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        PayerID: func() *user.ID <span class="cov0" title="0">{
                                if req.PayerID != nil </span><span class="cov0" title="0">{
                                        return &amp;user.ID{Value: *req.PayerID}
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        ReceiverID: func() *user.ID <span class="cov0" title="0">{
                                if req.ReceiverID != nil </span><span class="cov0" title="0">{
                                        return &amp;user.ID{Value: *req.ReceiverID}
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        CreatedAt: req.CreatedAt,
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("UpdateExpense: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, UpdateExpenseResponse{
                                ID:         expns.ID.Value,
                                Name:       expns.Name,
                                Amount:     float32(expns.Amount) / 100,
                                PayerID:    expns.PayerID.Value,
                                ReceiverID: expns.ReceiverID.Value,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package expense

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type ID struct{ Value int }

type Expense struct {
        ddd.Entity[ID]
        Name         string
        Amount       int
        RefundAmount *int
        Description  string
        GroupID      group.ID
        CategoryID   category.ID
        SplitRatio   SplitRatio
        SplitType    SplitType
        PayerID      user.ID
        ReceiverID   user.ID
}

type Attributes struct {
        ID          ID
        Name        string
        Amount      int
        Description string
        GroupID     group.ID
        CategoryID  category.ID
        SplitRatio  SplitRatio
        SplitType   SplitType
        PayerID     user.ID
        ReceiverID  user.ID
        CreatedAt   *time.Time
}

type UpdateAttributes struct {
        Name         *string
        Amount       *int
        RefundAmount *int
        Description  *string
        CategoryID   *category.ID
        SplitRatio   *SplitRatio
        SplitType    *SplitType
        PayerID      *user.ID
        ReceiverID   *user.ID
        CreatedAt    *time.Time
}

func New(attr Attributes) (*Expense, error) <span class="cov9" title="11">{
        createdAt := time.Now()
        if attr.CreatedAt != nil </span><span class="cov0" title="0">{
                createdAt = *attr.CreatedAt
        }</span>
        <span class="cov9" title="11">expense := Expense{
                Entity: ddd.Entity[ID]{
                        ID:        attr.ID,
                        CreatedAt: createdAt,
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                Name:        attr.Name,
                Amount:      attr.Amount,
                Description: attr.Description,
                GroupID:     attr.GroupID,
                CategoryID:  attr.CategoryID,
                SplitRatio:  attr.SplitRatio,
                SplitType:   attr.SplitType,
                PayerID:     attr.PayerID,
                ReceiverID:  attr.ReceiverID,
        }

        if err := expense.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expense.Validate: %w", err)
        }</span>

        <span class="cov9" title="11">return &amp;expense, nil</span>
}

func (e *Expense) Update(p UpdateAttributes) error <span class="cov4" title="3">{
        if p.Name != nil </span><span class="cov3" title="2">{
                e.Name = *p.Name
        }</span>
        <span class="cov4" title="3">if p.Amount != nil </span><span class="cov3" title="2">{
                e.Amount = *p.Amount
        }</span>
        <span class="cov4" title="3">if p.RefundAmount != nil </span><span class="cov0" title="0">{
                e.RefundAmount = p.RefundAmount
        }</span>
        <span class="cov4" title="3">if p.Description != nil </span><span class="cov3" title="2">{
                e.Description = *p.Description
        }</span>
        <span class="cov4" title="3">if p.CategoryID != nil </span><span class="cov4" title="3">{
                e.CategoryID = *p.CategoryID
        }</span>
        <span class="cov4" title="3">if p.SplitRatio != nil </span><span class="cov4" title="3">{
                e.SplitRatio = *p.SplitRatio
        }</span>
        <span class="cov4" title="3">if p.SplitType != nil </span><span class="cov4" title="3">{
                e.SplitType = *p.SplitType
        }</span>
        <span class="cov4" title="3">if p.PayerID != nil </span><span class="cov4" title="3">{
                e.PayerID = *p.PayerID
        }</span>
        <span class="cov4" title="3">if p.ReceiverID != nil </span><span class="cov4" title="3">{
                e.ReceiverID = *p.ReceiverID
        }</span>
        <span class="cov4" title="3">if p.CreatedAt != nil </span><span class="cov0" title="0">{
                e.CreatedAt = *p.CreatedAt
        }</span>
        <span class="cov4" title="3">e.UpdatedAt = time.Now()
        e.Version++

        if err := e.validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("expense.Validate: %w", err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

func (e *Expense) Delete() <span class="cov3" title="2">{
        now := time.Now()
        e.DeletedAt = &amp;now
        e.UpdatedAt = now
        e.Version++
}</span>

func (e *Expense) validate() error <span class="cov10" title="14">{
        if e.SplitRatio.Payer+e.SplitRatio.Receiver != 100 || e.SplitRatio.Payer &gt; 99 </span><span class="cov0" title="0">{
                return ErrInvalidSplitRatio
        }</span>

        <span class="cov10" title="14">if e.SplitType == SplitTypes.Equal &amp;&amp; e.SplitRatio.Payer != 50 </span><span class="cov0" title="0">{
                return ErrInvalidSplitRatio
        }</span>

        <span class="cov10" title="14">if e.RefundAmount != nil &amp;&amp; *e.RefundAmount &gt; e.Amount </span><span class="cov0" title="0">{
                return ErrInvalidRefundAmount
        }</span>

        <span class="cov10" title="14">return nil</span>
}

type Repository interface {
        ddd.Repository[ID, Expense]
        GetByGroupDate(ctx context.Context, groupId group.ID, date time.Time) ([]Expense, error)
        BulkStore(ctx context.Context, expenses []Expense) error
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package expense

import (
        "context"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/controller"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
)

var Module = eon.NewModule("Expense", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        // expense
        di.Provide(c, postgres.NewExpenseRepository)
        di.Provide(c, postgres.NewScheduledExpenseRepository)
        di.Provide(c, usecase.NewCreateExpense)
        di.Provide(c, usecase.NewUpdateExpense)
        di.Provide(c, usecase.NewDeleteExpense)
        di.Provide(c, usecase.NewRecalculateExpensesSplitRatio)
        di.Provide(c, usecase.NewCreateScheduledExpense)
        di.Provide(c, usecase.NewGenerateExpensesFromScheduledUseCase)
        di.Provide(c, postgres.NewGetExpenses)
        di.Provide(c, postgres.NewGetExpenseDetails)
        di.Provide(c, postgres.NewGetExpensesPerPeriod)
        di.Provide(c, postgres.NewGetExpensesPerCategory)
        di.Provide(c, controller.NewGetExpenses)
        di.Provide(c, controller.NewCreateExpense)
        di.Provide(c, controller.NewUpdateExpense)
        di.Provide(c, controller.NewDeleteExpense)
        di.Provide(c, controller.NewGetExpenseDetails)
        di.Provide(c, controller.NewGetExpensesPerPeriod)
        di.Provide(c, controller.NewGetExpensesPerCategory)
        di.Provide(c, controller.NewRecalculateExpensesSplitRatio)
        di.Provide(c, controller.NewGenerateExpensesFromScheduled)
        di.Provide(c, controller.NewCreateScheduledExpense)
        di.Provide(c, controller.NewCreateExpenseFromScheduled)
        // Register routes
        lc.OnBooted(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{
                return di.Call(c, controller.Router)
        }</span>)
        // Listen to subscriber
        <span class="cov0" title="0">lc.OnRunning(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{
                recalculate := di.Resolve[controller.RecalculateExpensesSplitRatio](c)
                return recalculate(ctx)
        }</span>)

        // Listen to subscriber
        <span class="cov0" title="0">lc.OnRunning(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{
                createExpenseFromScheduled := di.Resolve[controller.CreateExpenseFromScheduled](c)
                return createExpenseFromScheduled(ctx)
        }</span>)
})
</pre>
		
		<pre class="file" id="file40" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type ExpenseRepository struct {
        db *sqlx.DB
}

func (repo *ExpenseRepository) BulkStore(ctx context.Context, expenses []expense.Expense) error <span class="cov1" title="1">{
        var models []ExpenseModel
        for _, expns := range expenses </span><span class="cov7" title="3">{
                models = append(models, ToModel(&amp;expns))
        }</span>

        <span class="cov1" title="1">if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO expenses (id, name, amount_cents, refund_amount_cents, description, group_id, category_id, split_ratio, split_type, payer_id, receiver_id, created_at, updated_at, deleted_at, version)
    VALUES (:id, :name, :amount_cents, :refund_amount_cents, :description, :group_id, :category_id, :split_ratio, :split_type, :payer_id, :receiver_id, :created_at, :updated_at, :deleted_at, :version)
        `, models); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.ExecContext: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (repo *ExpenseRepository) GetByGroupDate(ctx context.Context, groupId group.ID, date time.Time) ([]expense.Expense, error) <span class="cov1" title="1">{
        var models []ExpenseModel
        if err := repo.db.SelectContext(ctx, &amp;models, ` 
    with base as (
                select
                    e.id,
                    name, 
                  amount_cents, 
                  refund_amount_cents, 
                  description, 
                  group_id, 
                  category_id, 
                  payer_id,   
                  receiver_id, 
                  split_ratio, 
                  split_type, 
                  created_at, 
                  updated_at, 
                  deleted_at, 
                  version
                from expenses e
                join (select id, MAX(version) as latest_version from expenses where group_id = $1 group by id) lv 
                  on e.id = lv.id and e.version = lv.latest_version
                where group_id = $1
        and extract(month from created_at) = $2
                and extract(year from created_at) = $3
                order by id desc, version desc
        )
        select * from base where deleted_at is null
    `, groupId.Value, date.Month(), date.Year()); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("db.SelectContext: :%w", err)</span>
        }

        <span class="cov1" title="1">var expenses []expense.Expense
        for _, model := range models </span><span class="cov7" title="3">{
                expenses = append(expenses, *ToEntity(model))
        }</span>

        <span class="cov1" title="1">return expenses, nil</span>
}

func (repo *ExpenseRepository) GetNextID() expense.ID <span class="cov10" title="5">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('expenses_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.QueryRow: %w", err))</span>
        }

        <span class="cov10" title="5">return expense.ID{Value: nextValue}</span>
}

func (repo *ExpenseRepository) GetByID(ctx context.Context, id expense.ID) (*expense.Expense, error) <span class="cov1" title="1">{
        var model ExpenseModel

        if err := repo.db.QueryRowxContext(ctx, `
                WITH base AS (
                        SELECT 
        id, 
        name, 
        amount_cents, 
        refund_amount_cents, 
        description, 
        group_id, 
        category_id, 
        payer_id,   
        receiver_id, 
        split_ratio, 
        split_type, 
        created_at, 
        updated_at, 
        deleted_at, 
        version
                        FROM expenses WHERE id = $1
                        ORDER BY version DESC
                        LIMIT 1
                )
                SELECT * FROM base WHERE deleted_at IS NULL
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.SelectContext: %w", err)</span>
        }

        <span class="cov1" title="1">return ToEntity(model), nil</span>
}

func (repo *ExpenseRepository) Store(ctx context.Context, entity *expense.Expense) error <span class="cov4" title="2">{
        model := ToModel(entity)

        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO expenses (id, name, amount_cents, refund_amount_cents, description, group_id, category_id, split_ratio, split_type, payer_id, receiver_id, created_at, updated_at, deleted_at, version)
    VALUES (:id, :name, :amount_cents, :refund_amount_cents, :description, :group_id, :category_id, :split_ratio, :split_type, :payer_id, :receiver_id, :created_at, :updated_at, :deleted_at, :version)
        `, &amp;model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.ExecContext: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func NewExpenseRepository(db *db.Client) expense.Repository <span class="cov1" title="1">{
        return &amp;ExpenseRepository{db: db.Conn()}
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        ExpenseDetails struct {
                ID           int        `db:"id" json:"id"`
                Name         string     `db:"name" json:"name"`
                Amount       float32    `db:"amount" json:"amount"`
                RefundAmount *float32   `db:"refund_amount" json:"refund_amount"`
                Description  string     `db:"description" json:"description"`
                CategoryID   int        `db:"category_id" json:"category_id"`
                PayerID      int        `db:"payer_id" json:"payer_id"`
                ReceiverID   int        `db:"receiver_id" json:"receiver_id"`
                GroupID      int        `db:"group_id" json:"group_id"`
                SplitRatio   SplitRatio `db:"split_ratio" json:"split_ratio"`
                SplitType    string     `db:"split_type" json:"split_type"`
                CreatedAt    time.Time  `db:"created_at" json:"created_at"`
                UpdatedAt    time.Time  `db:"updated_at" json:"updated_at"`
                DeletedAt    *time.Time `db:"deleted_at" json:"deleted_at"`
        }

        GetExpenseDetails func(ctx context.Context, expenseID int) ([]ExpenseDetails, error)
)

func NewGetExpenseDetails(db *db.Client) GetExpenseDetails <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, expenseID int) ([]ExpenseDetails, error) </span><span class="cov0" title="0">{
                var expenseDetails []ExpenseDetails
                if err := dbClient.SelectContext(ctx, &amp;expenseDetails, `
                            select
                                    id,
                                    name,
                                    amount_cents as amount,
                                    refund_amount_cents as refund_amount,
                                    description,
                                    payer_id,
                                    group_id,
                                    receiver_id,
                                          category_id,
                                    split_ratio,
            split_type,
                                          created_at,
                                          updated_at,
                                          deleted_at
                            from expenses
                                  where id = $1
                                  order by version 
                `, expenseID); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">return expenseDetails, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        GetExpenses func(ctx context.Context, input GetExpensesInput) ([]ExpenseDetails, error)

        GetExpensesInput struct {
                GroupID         int
                LastExpenseDate time.Time
                LastExpenseID   int
                Limit           int
                Search          string
        }
)

var (
        expensesQueryWithSearch = `
      with base as (
                                select
                                    distinct on (ex.id) ex.id as id,
                                    ex.name as name,
                                    ex.amount_cents amount,
                                    ex.refund_amount_cents as refund_amount,
                                    ex.description as description,
                                    ex.group_id as group_id,
                                    cat.id as category_id,
                                          cat.icon as category_icon,
                                    ex.payer_id as payer_id,
                                    ex.receiver_id as receiver_id,
                                    ex.split_ratio as split_ratio,
            ex.split_type as split_type,
                                          ex.created_at as created_at,
                                          ex.updated_at as updated_at,
                                          ex.deleted_at as deleted_at,
            ts_rank(ex.document_search, websearch_to_tsquery('portuguese', $5)) as rank
                                from expenses ex inner join categories cat on ex.category_id = cat.id
                                where ex.group_id = $1
                                and (ex.created_at &lt; $2 or (ex.created_at = $2 and ex.id &lt; $3))
                                and ex.document_search @@ websearch_to_tsquery('portuguese', $5)
                                order by ex.id desc, ex.version desc
                        )
                        select id, name, amount, refund_amount, description, category_id, payer_id, receiver_id, group_id, split_ratio, split_type, created_at, updated_at, deleted_at from base b
                        where b.deleted_at is null
                        order by b.created_at desc, b.id desc, b.rank desc
                        limit $4
                `
        expensesQuery = `
    with base as (
                                select
                                    distinct on (ex.id) ex.id as id,
                                    ex.name as name,
                                    ex.amount_cents amount,
                                    ex.refund_amount_cents as refund_amount,
                                    ex.description as description,
                                    ex.group_id as group_id,
                                    cat.id as category_id,
                                          cat.icon as category_icon,
                                    ex.payer_id as payer_id,
                                    ex.receiver_id as receiver_id,
                                    ex.split_ratio as split_ratio,
            ex.split_type as split_type,
                                          ex.created_at as created_at,
                                          ex.updated_at as updated_at,
                                          ex.deleted_at as deleted_at
                                from expenses ex inner join categories cat on ex.category_id = cat.id
                                where ex.group_id = $1
                                and (ex.created_at &lt; $2 or (ex.created_at = $2 and ex.id &lt; $3))
                                order by ex.id desc, ex.version desc
                        )
                        select id, name, amount, refund_amount, description, category_id, payer_id, receiver_id, group_id, split_ratio, split_type, created_at, updated_at, deleted_at from base b
                        where b.deleted_at is null
                        order by b.created_at desc, b.id desc
                        limit $4
  `
)

func NewGetExpenses(db *db.Client) GetExpenses <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, input GetExpensesInput) ([]ExpenseDetails, error) </span><span class="cov0" title="0">{
                var expenses []ExpenseDetails

                query := expensesQuery
                args := []any{input.GroupID, input.LastExpenseDate, input.LastExpenseID, input.Limit}

                if input.Search != "" </span><span class="cov0" title="0">{
                        query = expensesQueryWithSearch
                        args = append(args, input.Search)
                }</span>
                <span class="cov0" title="0">if err := dbClient.SelectContext(ctx, &amp;expenses, query, args...); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">return expenses, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        expensesPerCategoryInfo struct {
                CategoryGroup string `db:"category_group_name"`
                Category      string `db:"category_name" `
                Amount        int    `db:"amount"`
        }

        expensesPerInnerCategory struct {
                Category string `json:"name"`
                Amount   int    `json:"amount"`
        }

        ExpensesPerCategory struct {
                CategoryGroup string                     `json:"name"`
                Amount        int                        `json:"amount"`
                Categories    []expensesPerInnerCategory `json:"categories"`
        }

        GetExpensesPerCategoryInput struct {
                GroupID   int       `json:"group_id"`
                StartDate time.Time `json:"start_date"`
                EndDate   time.Time `json:"end_date"`
        }

        GetExpensesPerCategory func(ctx context.Context, params GetExpensesPerCategoryInput) ([]ExpensesPerCategory, error)
)

func NewGetExpensesPerCategory(db *db.Client) GetExpensesPerCategory <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, params GetExpensesPerCategoryInput) ([]ExpensesPerCategory, error) </span><span class="cov0" title="0">{
                var info []expensesPerCategoryInfo
                if err := dbClient.SelectContext(ctx, &amp;info, `
                        with base as (
                            select
                                distinct on (ex.id) ex.id as id,
                                ex.amount_cents amount,
                                ex.category_id  as category_id,
                                ex.deleted_at as deleted_at
                            from expenses ex
                            where ex.group_id = $1
                            and ex.created_at &gt;= $2
                            and ex.created_at &lt;= $3
                            order by ex.id desc, ex.version desc
                        )
                        select 
                                cat.name as category_name, 
                                cg.name as category_group_name, 
                                sum(amount) as amount 
                        from base b
                        inner join categories cat on b.category_id = cat.id
                        inner join category_groups cg on cg.id = cat.category_group_id
                        where b.deleted_at is null
                        and cg.deleted_at is null
                        and cat.deleted_at is null
                        group by 1, 2 
                        order by 2 desc;
                `, params.GroupID, params.StartDate, params.EndDate); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">var categoriesGroups = make(map[string]ExpensesPerCategory)
                for _, e := range info </span><span class="cov0" title="0">{
                        if _, ok := categoriesGroups[e.CategoryGroup]; !ok </span><span class="cov0" title="0">{
                                categoriesGroups[e.CategoryGroup] = ExpensesPerCategory{
                                        CategoryGroup: e.CategoryGroup,
                                        Amount:        e.Amount,
                                        Categories:    []expensesPerInnerCategory{{Category: e.Category, Amount: e.Amount}},
                                }
                        }</span> else<span class="cov0" title="0"> {
                                categoriesGroups[e.CategoryGroup] = ExpensesPerCategory{
                                        CategoryGroup: e.CategoryGroup,
                                        Amount:        categoriesGroups[e.CategoryGroup].Amount + e.Amount,
                                        Categories: append(categoriesGroups[e.CategoryGroup].Categories, expensesPerInnerCategory{
                                                Category: e.Category,
                                                Amount:   e.Amount,
                                        }),
                                }
                        }</span>
                }

                <span class="cov0" title="0">var expensesPerCategory []ExpensesPerCategory
                for _, cg := range categoriesGroups </span><span class="cov0" title="0">{
                        expensesPerCategory = append(expensesPerCategory, cg)
                }</span>

                <span class="cov0" title="0">return expensesPerCategory, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        ExpensesPerPeriod struct {
                Date   string `db:"date" json:"date"`
                Amount int    `db:"amount" json:"amount"`
                Count  int    `db:"quantity" json:"quantity"`
        }

        GetExpensesPerPeriodInput struct {
                GroupID   int       `json:"group_id"`
                Aggregate string    `json:"aggregate"`
                StartDate time.Time `json:"start_date"`
                EndDate   time.Time `json:"end_date"`
        }

        GetExpensesPerPeriod func(ctx context.Context, params GetExpensesPerPeriodInput) ([]ExpensesPerPeriod, error)
)

func NewGetExpensesPerPeriod(db *db.Client) GetExpensesPerPeriod <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, params GetExpensesPerPeriodInput) ([]ExpensesPerPeriod, error) </span><span class="cov0" title="0">{
                var expensesPerPeriod []ExpensesPerPeriod

                trunc, format := "day", "YYYY-MM-DD"
                switch params.Aggregate </span>{
                case "month":<span class="cov0" title="0">
                        trunc = "month"
                        format = "YYYY-MM"</span>
                case "day":<span class="cov0" title="0">
                        trunc = "day"
                        format = "YYYY-MM-DD"</span>
                }

                <span class="cov0" title="0">query := fmt.Sprintf(`
                        with base as (
                    select
                        distinct on (ex.id) ex.id as id,
                        ex.amount_cents amount,
                                ex.category_id  as category_id,
                        ex.created_at as created_at,
                        ex.deleted_at as deleted_at
                    from expenses ex
                            where ex.group_id = $1
                            and ex.created_at &gt;= $2
                            and ex.created_at &lt;= $3
                            order by ex.id desc, ex.version desc
                        )
                        select 
                                to_char(date_trunc('%s', b.created_at), '%s') as date, 
                                sum(amount) as amount, 
                                count(1) as quantity 
                        from base b
                        where b.deleted_at is null
                        group by 1
                        order by 1;
                `, trunc, format)

                if err := dbClient.SelectContext(ctx, &amp;expensesPerPeriod, query, params.GroupID, params.StartDate, params.EndDate); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">return expensesPerPeriod, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package postgres

import (
        "database/sql"
        "time"

        "cloud.google.com/go/civil"
        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

func ToEntity(model ExpenseModel) *expense.Expense <span class="cov8" title="4">{
        var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov8" title="4">var refundAmount *int
        if model.RefundAmountCents.Valid </span><span class="cov0" title="0">{
                parsedRefundAmount := int(model.RefundAmountCents.Int64)
                refundAmount = &amp;parsedRefundAmount
        }</span>

        <span class="cov8" title="4">return &amp;expense.Expense{
                Entity: ddd.Entity[expense.ID]{
                        ID:        expense.ID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                Name:         model.Name,
                Amount:       model.AmountCents,
                RefundAmount: refundAmount,
                Description:  model.Description,
                GroupID:      group.ID{Value: model.GroupID},
                CategoryID:   category.ID{Value: model.CategoryID},
                SplitRatio: expense.SplitRatio{
                        Payer:    model.SplitRatio.Payer,
                        Receiver: model.SplitRatio.Receiver,
                },
                SplitType:  expense.SplitType(model.SplitType),
                PayerID:    user.ID{Value: model.PayerID},
                ReceiverID: user.ID{Value: model.ReceiverID},
        }</span>
}

func ToModel(entity *expense.Expense) ExpenseModel <span class="cov10" title="5">{
        var deletedAt sql.NullTime
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span>

        <span class="cov10" title="5">var refundAmount sql.NullInt64
        if entity.RefundAmount != nil </span><span class="cov0" title="0">{
                refundAmount = sql.NullInt64{Int64: int64(*entity.RefundAmount), Valid: true}
        }</span>

        <span class="cov10" title="5">return ExpenseModel{
                ID:                entity.ID.Value,
                Name:              entity.Name,
                AmountCents:       entity.Amount,
                RefundAmountCents: refundAmount,
                Description:       entity.Description,
                GroupID:           entity.GroupID.Value,
                CategoryID:        entity.CategoryID.Value,
                SplitRatio: SplitRatio{
                        Payer:    entity.SplitRatio.Payer,
                        Receiver: entity.SplitRatio.Receiver,
                },
                SplitType:  entity.SplitType.String(),
                PayerID:    entity.PayerID.Value,
                ReceiverID: entity.ReceiverID.Value,
                CreatedAt:  entity.CreatedAt,
                UpdatedAt:  entity.UpdatedAt,
                DeletedAt:  deletedAt,
                Version:    entity.Version,
        }</span>
}

func ToScheduledExpenseModel(entity expense.ScheduledExpense) ScheduledExpenseModel <span class="cov10" title="5">{
        var lastGeneratedAt sql.Null[civil.Date]
        if entity.LastGeneratedAt != nil </span><span class="cov7" title="3">{
                lastGeneratedAt = sql.Null[civil.Date]{V: *entity.LastGeneratedAt, Valid: true}
        }</span>

        <span class="cov10" title="5">return ScheduledExpenseModel{
                ID:              entity.ID.Value,
                Name:            entity.Name,
                AmountCents:     entity.Amount,
                Description:     entity.Description,
                GroupID:         entity.GroupID.Value,
                CategoryID:      entity.CategoryID.Value,
                SplitType:       entity.SplitType.String(),
                PayerID:         entity.PayerID.Value,
                ReceiverID:      entity.ReceiverID.Value,
                FrequencyInDays: entity.FrequencyInDays,
                LastGeneratedAt: lastGeneratedAt,
                IsActive:        entity.IsActive,
                CreatedAt:       entity.CreatedAt,
                UpdatedAt:       entity.UpdatedAt,
                Version:         entity.Version,
        }</span>
}

func ToScheduledExpenseEntity(model ScheduledExpenseModel) expense.ScheduledExpense <span class="cov4" title="2">{
        var lastGeneratedAt *civil.Date
        if model.LastGeneratedAt.Valid </span><span class="cov0" title="0">{
                lastGeneratedAt = &amp;model.LastGeneratedAt.V
        }</span>

        <span class="cov4" title="2">return expense.ScheduledExpense{
                Entity: ddd.Entity[expense.ScheduledExpenseID]{
                        ID:        expense.ScheduledExpenseID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        Version:   model.Version,
                },
                Name:            model.Name,
                Amount:          model.AmountCents,
                Description:     model.Description,
                GroupID:         group.ID{Value: model.GroupID},
                CategoryID:      category.ID{Value: model.CategoryID},
                SplitType:       expense.SplitType(model.SplitType),
                PayerID:         user.ID{Value: model.PayerID},
                ReceiverID:      user.ID{Value: model.ReceiverID},
                FrequencyInDays: model.FrequencyInDays,
                LastGeneratedAt: lastGeneratedAt,
                IsActive:        model.IsActive,
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package postgres

import (
        "database/sql"
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"

        "cloud.google.com/go/civil"
)

type ExpenseModel struct {
        ID                int           `db:"id"`
        Name              string        `db:"name"`
        AmountCents       int           `db:"amount_cents"`
        RefundAmountCents sql.NullInt64 `db:"refund_amount_cents"`
        Description       string        `db:"description"`
        GroupID           int           `db:"group_id"`
        CategoryID        int           `db:"category_id"`
        SplitRatio        SplitRatio    `db:"split_ratio"`
        SplitType         string        `db:"split_type"`
        PayerID           int           `db:"payer_id"`
        ReceiverID        int           `db:"receiver_id"`
        CreatedAt         time.Time     `db:"created_at"`
        UpdatedAt         time.Time     `db:"updated_at"`
        DeletedAt         sql.NullTime  `db:"deleted_at"`
        Version           int           `db:"version"`
}

type SplitRatio struct {
        Payer    int `db:"payer" json:"payer"`
        Receiver int `db:"receiver" json:"receiver"`
}

func (sr SplitRatio) Value() (driver.Value, error) <span class="cov10" title="5">{
        return json.Marshal(sr)
}</span>

func (sr *SplitRatio) Scan(value any) error <span class="cov8" title="4">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>

        <span class="cov8" title="4">return json.Unmarshal(b, &amp;sr)</span>
}

type ScheduledExpenseModel struct {
        ID              int                  `db:"id"`
        Name            string               `db:"name"`
        AmountCents     int                  `db:"amount_cents"`
        Description     string               `db:"description"`
        GroupID         int                  `db:"group_id"`
        CategoryID      int                  `db:"category_id"`
        SplitType       string               `db:"split_type"`
        PayerID         int                  `db:"payer_id"`
        ReceiverID      int                  `db:"receiver_id"`
        FrequencyInDays int                  `db:"frequency_in_days"`
        LastGeneratedAt sql.Null[civil.Date] `db:"last_generated_at"`
        IsActive        bool                 `db:"is_active"`
        CreatedAt       time.Time            `db:"created_at"`
        UpdatedAt       time.Time            `db:"updated_at"`
        Version         int                  `db:"version"`
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type ScheduledExpenseRepository struct {
        db *db.Client
}

func (repo *ScheduledExpenseRepository) GetNextID() expense.ScheduledExpenseID <span class="cov10" title="5">{
        var nextValue int

        conn := repo.db.Conn()

        if err := conn.QueryRowx("SELECT nextval('scheduled_expenses_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.QueryRow: %w", err))</span>
        }

        <span class="cov10" title="5">return expense.ScheduledExpenseID{Value: nextValue}</span>
}

func (repo *ScheduledExpenseRepository) GetByID(ctx context.Context, id expense.ScheduledExpenseID) (*expense.ScheduledExpense, error) <span class="cov1" title="1">{
        var model ScheduledExpenseModel

        conn := repo.db.Conn()

        if err := conn.QueryRowxContext(ctx, `
                SELECT 
                        id,
                        name,
                        amount_cents,
                        description,
                        group_id,
                        category_id,
                        split_type,
                        payer_id,
                        receiver_id,
                        frequency_in_days,
                        last_generated_at,
                        is_active,
                        created_at,
                        updated_at,
                        version
                FROM scheduled_expenses 
                WHERE id = $1
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.SelectContext: %w", err)</span>
        }

        <span class="cov1" title="1">entity := ToScheduledExpenseEntity(model)

        return &amp;entity, nil</span>
}

func (repo *ScheduledExpenseRepository) GetActiveScheduledExpenses(ctx context.Context) ([]expense.ScheduledExpense, error) <span class="cov1" title="1">{
        conn := repo.db.Conn()
        var models []ScheduledExpenseModel

        if err := conn.SelectContext(ctx, &amp;models, `
                SELECT 
                        id,
                        name,
                        amount_cents,
                        description,
                        group_id,
                        category_id,
                        split_type,
                        payer_id,
                        receiver_id,
                        frequency_in_days,
                        last_generated_at,
                        is_active,
                        created_at,
                        updated_at,
                        version
                FROM scheduled_expenses
                WHERE is_active = true
                AND (
                        last_generated_at IS NULL
                        OR (last_generated_at + INTERVAL '1 day' * frequency_in_days &lt;= CURRENT_DATE)
                )
        `); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.SelectContext: %w", err)</span>
        }

        <span class="cov1" title="1">var entities []expense.ScheduledExpense
        for _, model := range models </span><span class="cov1" title="1">{
                entities = append(entities, ToScheduledExpenseEntity(model))
        }</span>

        <span class="cov1" title="1">return entities, nil</span>
}

func (repo *ScheduledExpenseRepository) Store(ctx context.Context, entity *expense.ScheduledExpense) error <span class="cov7" title="3">{
        return repo.BulkStore(ctx, []expense.ScheduledExpense{*entity})
}</span>

func (repo *ScheduledExpenseRepository) BulkStore(ctx context.Context, entities []expense.ScheduledExpense) error <span class="cov8" title="4">{
        return repo.db.Transaction(ctx, func(ctx context.Context, tx *sqlx.Tx) error </span><span class="cov8" title="4">{
                for _, entity := range entities </span><span class="cov10" title="5">{
                        model := ToScheduledExpenseModel(entity)

                        if _, err := tx.NamedExecContext(ctx, `
                                INSERT INTO scheduled_expenses (id, name, amount_cents, description, group_id, category_id, split_type, payer_id, receiver_id, frequency_in_days, last_generated_at, is_active, created_at, updated_at, version) 
                                VALUES (:id, :name, :amount_cents, :description, :group_id, :category_id, :split_type, :payer_id, :receiver_id, :frequency_in_days, :last_generated_at, :is_active, :created_at, :updated_at, :version)
                                ON CONFLICT (id) DO UPDATE SET
                                        name = :name,
                                        amount_cents = :amount_cents,
                                        description = :description,
                                        category_id = :category_id,
                                        split_type = :split_type,
                                        payer_id = :payer_id,
                                        receiver_id = :receiver_id,
                                        frequency_in_days = :frequency_in_days,
                                        last_generated_at = :last_generated_at,
                                        is_active = :is_active,
                                        updated_at = :updated_at,
                                        version = :version
                        `, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("db.ExecContext: %w", err)
                        }</span>
                }

                <span class="cov8" title="4">return nil</span>
        })
}

func NewScheduledExpenseRepository(db *db.Client) expense.ScheduledExpenseRepository <span class="cov1" title="1">{
        return &amp;ScheduledExpenseRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package expense

import (
        "context"
        "fmt"
        "time"

        "cloud.google.com/go/civil"
        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type ScheduledExpenseID struct{ Value int }

type ScheduledExpense struct {
        ddd.Entity[ScheduledExpenseID]
        Name            string
        Amount          int
        Description     string
        GroupID         group.ID
        CategoryID      category.ID
        SplitType       SplitType
        PayerID         user.ID
        ReceiverID      user.ID
        FrequencyInDays int
        LastGeneratedAt *civil.Date
        IsActive        bool
}

type ScheduledExpenseAttributes struct {
        ID              ScheduledExpenseID
        Name            string
        Amount          int
        Description     string
        GroupID         group.ID
        CategoryID      category.ID
        SplitType       SplitType
        PayerID         user.ID
        ReceiverID      user.ID
        LastGeneratedAt *civil.Date
        FrequencyInDays int
}

func NewScheduledExpense(attr ScheduledExpenseAttributes) (*ScheduledExpense, error) <span class="cov10" title="3">{
        scheduledExpense := &amp;ScheduledExpense{
                Entity: ddd.Entity[ScheduledExpenseID]{
                        ID:        attr.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                Name:            attr.Name,
                Amount:          attr.Amount,
                Description:     attr.Description,
                GroupID:         attr.GroupID,
                CategoryID:      attr.CategoryID,
                SplitType:       attr.SplitType,
                PayerID:         attr.PayerID,
                ReceiverID:      attr.ReceiverID,
                FrequencyInDays: attr.FrequencyInDays,
                LastGeneratedAt: attr.LastGeneratedAt,
                IsActive:        true,
        }

        if err := scheduledExpense.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scheduled expense validation failed: %w", err)
        }</span>

        <span class="cov10" title="3">return scheduledExpense, nil</span>
}

func (s *ScheduledExpense) validate() error <span class="cov10" title="3">{
        if s.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("name is required")
        }</span>

        <span class="cov10" title="3">if s.Amount &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("amount must be greater than zero")
        }</span>

        <span class="cov10" title="3">return nil</span>
}

func (s *ScheduledExpense) ToExpense() (*Expense, error) <span class="cov0" title="0">{
        createdAt := time.Now()

        return New(Attributes{
                Name:        s.Name,
                Amount:      s.Amount,
                Description: s.Description,
                GroupID:     s.GroupID,
                CategoryID:  s.CategoryID,
                SplitRatio:  NewEqualSplitRatio(), // This is a temporary value, it will be updated when the expense is created
                SplitType:   s.SplitType,
                PayerID:     s.PayerID,
                ReceiverID:  s.ReceiverID,
                CreatedAt:   &amp;createdAt,
        })
}</span>

func (se *ScheduledExpense) ShouldGenerateExpense() bool <span class="cov0" title="0">{
        if !se.IsActive </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if se.LastGeneratedAt == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">today := civil.DateOf(time.Now())
        nextGeneration := se.calculateNextGenerationDate()
        return today == nextGeneration || today.After(nextGeneration)</span>
}

func (se *ScheduledExpense) calculateNextGenerationDate() civil.Date <span class="cov0" title="0">{
        lastGen := se.LastGeneratedAt
        if lastGen == nil </span><span class="cov0" title="0">{
                return civil.DateOf(se.CreatedAt)
        }</span>

        <span class="cov0" title="0">return lastGen.AddDays(se.FrequencyInDays)</span>
}

func (se *ScheduledExpense) UpdateLastGeneratedAt() <span class="cov0" title="0">{
        today := civil.DateOf(time.Now())
        se.LastGeneratedAt = &amp;today
        se.UpdatedAt = time.Now()
        se.Version++
}</span>

func (se *ScheduledExpense) Deactivate() <span class="cov0" title="0">{
        se.IsActive = false
        se.UpdatedAt = time.Now()
        se.Version++
}</span>

type ScheduledExpenseRepository interface {
        ddd.Repository[ScheduledExpenseID, ScheduledExpense]
        GetActiveScheduledExpenses(ctx context.Context) ([]ScheduledExpense, error)
        BulkStore(ctx context.Context, scheduledExpenses []ScheduledExpense) error
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package expense

import "math"

type SplitType string

var SplitTypes = struct {
        Equal        SplitType
        Proportional SplitType
        Transfer     SplitType
}{
        Equal:        "equal",
        Proportional: "proportional",
        Transfer:     "transfer",
}

func (s SplitType) String() string <span class="cov10" title="38">{
        return string(s)
}</span>

type SplitRatio struct {
        Payer    int `json:"payer"`
        Receiver int `json:"receiver"`
}

func (s SplitRatio) Type() SplitType <span class="cov0" title="0">{
        if s.Payer == 0 </span><span class="cov0" title="0">{
                return SplitTypes.Transfer
        }</span>

        <span class="cov0" title="0">if s.Payer == 50 </span><span class="cov0" title="0">{
                return SplitTypes.Equal
        }</span>

        <span class="cov0" title="0">return SplitTypes.Proportional</span>
}

func NewEqualSplitRatio() SplitRatio <span class="cov5" title="6">{
        return SplitRatio{
                Payer:    50,
                Receiver: 50,
        }
}</span>

func NewProportionalSplitRatio(payerIncome, receiverIncome int) SplitRatio <span class="cov3" title="3">{
        totalIncome := payerIncome + receiverIncome
        payerRatio := int(math.Round(float64(payerIncome) * 100.0 / float64(totalIncome)))

        receiverRatio := 100 - payerRatio

        return SplitRatio{
                Payer:    payerRatio,
                Receiver: receiverRatio,
        }
}</span>

func NewTransferRatio() SplitRatio <span class="cov3" title="3">{
        return SplitRatio{
                Payer:    0,
                Receiver: 100,
        }
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package usecase

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type (
        CreateExpenseParams struct {
                GroupID     group.ID
                Name        string
                Amount      int
                Description string
                CategoryID  category.ID
                SplitType   expense.SplitType
                PayerID     user.ID
                ReceiverID  user.ID
                CreatedAt   *time.Time
        }
        CreateExpense func(ctx context.Context, p CreateExpenseParams) (*expense.Expense, error)
)

func NewCreateExpense(
        expenseRepo expense.Repository,
        userRepo user.Repository,
        groupRepo group.Repository,
        categoryRepo category.Repository,
        incomeRepo income.Repository,
) CreateExpense <span class="cov1" title="1">{
        return func(ctx context.Context, p CreateExpenseParams) (*expense.Expense, error) </span><span class="cov10" title="12">{
                payer, err := userRepo.GetByID(ctx, p.PayerID)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                }</span>

                <span class="cov9" title="11">if payer == nil </span><span class="cov1" title="1">{
                        return nil, except.NotFoundError("payer not found")
                }</span>

                <span class="cov9" title="10">receiver, err := userRepo.GetByID(ctx, p.ReceiverID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                }</span>

                <span class="cov9" title="10">if receiver == nil </span><span class="cov1" title="1">{
                        return nil, except.NotFoundError("receiver not found")
                }</span>

                <span class="cov8" title="9">grp, err := groupRepo.GetByID(ctx, p.GroupID)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("groupRepo.GetByID: %w", err)
                }</span>

                <span class="cov8" title="8">if grp == nil </span><span class="cov1" title="1">{
                        return nil, except.NotFoundError("group not found")
                }</span>

                <span class="cov8" title="7">if payer.GroupID == nil || receiver.GroupID == nil || grp.ID != *payer.GroupID || grp.ID != *receiver.GroupID </span><span class="cov1" title="1">{
                        return nil, except.UnprocessableEntityError("group mismatch")
                }</span>

                <span class="cov7" title="6">cat, err := categoryRepo.GetByID(ctx, p.CategoryID)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("categoryRepo.GetByID: %w", err)
                }</span>

                <span class="cov6" title="5">if cat == nil </span><span class="cov1" title="1">{
                        return nil, except.NotFoundError("category not found")
                }</span>

                <span class="cov6" title="4">var splitRatio expense.SplitRatio
                switch p.SplitType </span>{
                case expense.SplitTypes.Proportional:<span class="cov1" title="1">
                        payerIncomes, err := incomeRepo.GetUserMonthlyIncomes(ctx, payer.ID, p.CreatedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("incomeRepo.GetUserMonthlyIncomes: %w", err)
                        }</span>

                        <span class="cov1" title="1">receiverIncomes, err := incomeRepo.GetUserMonthlyIncomes(ctx, receiver.ID, p.CreatedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("incomeRepo.GetUserMonthlyIncomes: %w", err)
                        }</span>

                        <span class="cov1" title="1">if receiverIncomes == nil || payerIncomes == nil </span><span class="cov0" title="0">{
                                splitRatio = expense.NewEqualSplitRatio()
                        }</span> else<span class="cov1" title="1"> {
                                totalPayerIncome := 0
                                for _, incm := range payerIncomes </span><span class="cov1" title="1">{
                                        totalPayerIncome += incm.Amount
                                }</span>

                                <span class="cov1" title="1">totalReceiverIncome := 0
                                for _, incm := range receiverIncomes </span><span class="cov1" title="1">{
                                        totalReceiverIncome += incm.Amount
                                }</span>

                                <span class="cov1" title="1">splitRatio = expense.NewProportionalSplitRatio(totalPayerIncome, totalReceiverIncome)</span>
                        }
                case expense.SplitTypes.Transfer:<span class="cov1" title="1">
                        splitRatio = expense.NewTransferRatio()</span>
                default:<span class="cov3" title="2">
                        splitRatio = expense.NewEqualSplitRatio()</span>
                }

                <span class="cov6" title="4">newExpense, err := expense.New(expense.Attributes{
                        ID:          expenseRepo.GetNextID(),
                        Name:        p.Name,
                        Amount:      p.Amount,
                        Description: p.Description,
                        GroupID:     p.GroupID,
                        CategoryID:  p.CategoryID,
                        SplitRatio:  splitRatio,
                        SplitType:   p.SplitType,
                        PayerID:     p.PayerID,
                        ReceiverID:  p.ReceiverID,
                        CreatedAt:   p.CreatedAt,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, except.UnprocessableEntityError().SetInternal(fmt.Errorf("entity.New: %w", err))
                }</span>

                <span class="cov6" title="4">if err := expenseRepo.Store(ctx, newExpense); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("expenseRepo.Store: %w", err)
                }</span>

                <span class="cov4" title="3">return newExpense, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package usecase

import (
        "context"
        "fmt"

        "cloud.google.com/go/civil"
        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
)

type CreateScheduledExpenseInput struct {
        Name            string            `json:"name" validate:"required"`
        Amount          int               `json:"amount" validate:"required"`
        Description     string            `json:"description" validate:"required"`
        GroupID         group.ID          `json:"group_id" validate:"required"`
        CategoryID      category.ID       `json:"category_id" validate:"required"`
        SplitType       expense.SplitType `json:"split_type" validate:"required"`
        PayerID         user.ID           `json:"payer_id" validate:"required"`
        ReceiverID      user.ID           `json:"receiver_id" validate:"required"`
        FrequencyInDays int               `json:"frequency_in_days" validate:"required"`
        LastGeneratedAt *civil.Date       `json:"last_generated_at" validate:"required"`
}

type CreateScheduledExpense func(ctx context.Context, input CreateScheduledExpenseInput) error

func NewCreateScheduledExpense(
        scheduledExpenseRepo expense.ScheduledExpenseRepository,
) CreateScheduledExpense <span class="cov0" title="0">{
        return func(ctx context.Context, input CreateScheduledExpenseInput) error </span><span class="cov0" title="0">{
                // Criar a despesa agendada
                scheduledExpense, err := expense.NewScheduledExpense(expense.ScheduledExpenseAttributes{
                        ID:              scheduledExpenseRepo.GetNextID(),
                        Name:            input.Name,
                        Amount:          input.Amount,
                        Description:     input.Description,
                        GroupID:         input.GroupID,
                        CategoryID:      input.CategoryID,
                        SplitType:       input.SplitType,
                        PayerID:         input.PayerID,
                        ReceiverID:      input.ReceiverID,
                        FrequencyInDays: input.FrequencyInDays,
                        LastGeneratedAt: input.LastGeneratedAt,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create scheduled expense: %w", err)
                }</span>

                // Salvar a despesa agendada
                <span class="cov0" title="0">if err := scheduledExpenseRepo.Store(ctx, scheduledExpense); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to store scheduled expense: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type DeleteExpense func(ctx context.Context, expenseID expense.ID) (*expense.Expense, error)

func NewDeleteExpense(expenseRepo expense.Repository) DeleteExpense <span class="cov1" title="1">{
        return func(ctx context.Context, expenseID expense.ID) (*expense.Expense, error) </span><span class="cov10" title="4">{
                expns, err := expenseRepo.GetByID(ctx, expenseID)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("expenseRepo.GetByID: %w", err)
                }</span>

                <span class="cov8" title="3">if expns == nil </span><span class="cov1" title="1">{
                        return nil, except.NotFoundError("expense not found")
                }</span>

                <span class="cov5" title="2">expns.Delete()

                if err := expenseRepo.Store(ctx, expns); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("expenseRepo.Store: %w", err)
                }</span>

                <span class="cov1" title="1">return expns, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package usecase

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub"
)

type GenerateExpensesFromScheduledUseCase func(ctx context.Context) (expensesCreated int, err error)

func NewGenerateExpensesFromScheduledUseCase(
        scheduledExpenseRepo expense.ScheduledExpenseRepository,
        publisher pubsub.Publisher,
) GenerateExpensesFromScheduledUseCase <span class="cov0" title="0">{
        return func(ctx context.Context) (expensesCreated int, err error) </span><span class="cov0" title="0">{
                activeScheduledExpenses, err := scheduledExpenseRepo.GetActiveScheduledExpenses(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to get active scheduled expenses: %w", err)
                }</span>

                <span class="cov0" title="0">var (
                        expenses                 []expense.Expense
                        scheduledExpensesCreated []expense.ScheduledExpense
                )
                for _, scheduledExpense := range activeScheduledExpenses </span><span class="cov0" title="0">{
                        if !scheduledExpense.ShouldGenerateExpense() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">exp, err := scheduledExpense.ToExpense()
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("failed to convert scheduled expense to expense: %w", err)
                        }</span>
                        <span class="cov0" title="0">expenses = append(expenses, *exp)

                        scheduledExpense.UpdateLastGeneratedAt()
                        scheduledExpensesCreated = append(scheduledExpensesCreated, scheduledExpense)</span>
                }

                <span class="cov0" title="0">if len(scheduledExpensesCreated) &gt; 0 </span><span class="cov0" title="0">{
                        if err := scheduledExpenseRepo.BulkStore(ctx, scheduledExpensesCreated); err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("failed to store scheduled expenses: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">for _, exp := range expenses </span><span class="cov0" title="0">{
                        if err := publisher.Publish(ctx, pubsub.ExpensesTopic, pubsub.ExpenseEvent{
                                Event: pubsub.Event{
                                        Type:    "expense.created",
                                        GroupID: exp.GroupID,
                                        UserID:  exp.PayerID,
                                        SentAt:  time.Now(),
                                },
                                Expense: exp,
                        }); err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("failed to publish expense created event: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return len(expenses), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package usecase

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
)

type (
        RecalculateExpensesSplitRatioInput struct {
                EventName string
                GroupID   group.ID
                Date      time.Time
        }

        RecalculateExpensesSplitRatio func(ctx context.Context, input RecalculateExpensesSplitRatioInput) error
)

func NewRecalculateExpensesSplitRatio(
        expenseRepo expense.Repository,
        incomeRepo income.Repository,
) RecalculateExpensesSplitRatio <span class="cov0" title="0">{
        return func(ctx context.Context, input RecalculateExpensesSplitRatioInput) error </span><span class="cov0" title="0">{
                slog.InfoContext(ctx, "Recalculating expenses split ratio", slog.Int("group", input.GroupID.Value), slog.Time("date", input.Date), slog.String("event", input.EventName))
                expenses, err := expenseRepo.GetByGroupDate(ctx, input.GroupID, input.Date)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("expensesRepo.GetByGroupDate: %w", err)
                }</span>

                <span class="cov0" title="0">var proportionalExpenses []expense.Expense
                for _, expns := range expenses </span><span class="cov0" title="0">{
                        if expns.SplitType == expense.SplitTypes.Proportional </span><span class="cov0" title="0">{
                                proportionalExpenses = append(proportionalExpenses, expns)
                        }</span>
                }

                <span class="cov0" title="0">if len(proportionalExpenses) == 0 </span><span class="cov0" title="0">{
                        slog.InfoContext(ctx, "no expenses to update")
                        return nil
                }</span>

                <span class="cov0" title="0">usersIDs := []user.ID{proportionalExpenses[0].PayerID, proportionalExpenses[0].ReceiverID}
                usersIncomes := map[user.ID]int{}
                for _, userID := range usersIDs </span><span class="cov0" title="0">{
                        incomes, err := incomeRepo.GetUserMonthlyIncomes(ctx, userID, &amp;input.Date)
                        if err != nil || incomes == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("no incomes found for user %d", userID.Value)
                        }</span>

                        <span class="cov0" title="0">totalIncome := 0
                        for _, incm := range incomes </span><span class="cov0" title="0">{
                                totalIncome += incm.Amount
                        }</span>

                        <span class="cov0" title="0">usersIncomes[userID] = totalIncome</span>
                }

                <span class="cov0" title="0">for i, expns := range proportionalExpenses </span><span class="cov0" title="0">{
                        newSplitRatio := expense.NewProportionalSplitRatio(usersIncomes[expns.PayerID], usersIncomes[expns.ReceiverID])
                        if err := proportionalExpenses[i].Update(expense.UpdateAttributes{SplitRatio: &amp;newSplitRatio}); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("proportionalExpenses[%d]: %w", i, err)
                        }</span>
                }

                <span class="cov0" title="0">if err := expenseRepo.BulkStore(ctx, proportionalExpenses); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("expense.BulkStore: %w", err)
                }</span>

                <span class="cov0" title="0">slog.InfoContext(ctx, "Expenses split ratio recalculated successfully", slog.Int("count", len(proportionalExpenses)))

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package usecase

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type (
        UpdateExpenseParams struct {
                ID           expense.ID
                Name         *string
                Amount       *int
                RefundAmount *int
                Description  *string
                CategoryID   *category.ID
                SplitType    *expense.SplitType
                PayerID      *user.ID
                ReceiverID   *user.ID
                CreatedAt    *time.Time
        }
        UpdateExpense func(ctx context.Context, p UpdateExpenseParams) (*expense.Expense, error)
)

func NewUpdateExpense(
        expenseRepo expense.Repository,
        userRepo user.Repository,
        categoryRepo category.Repository,
        incomeRepo income.Repository,
) UpdateExpense <span class="cov1" title="1">{
        return func(ctx context.Context, p UpdateExpenseParams) (*expense.Expense, error) </span><span class="cov10" title="11">{
                expns, err := expenseRepo.GetByID(ctx, p.ID)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("expenseRepo.GetByID: %w", err)
                }</span>

                <span class="cov9" title="10">if expns == nil </span><span class="cov1" title="1">{
                        return nil, except.NotFoundError("expense not found")
                }</span>

                <span class="cov9" title="9">if p.PayerID != nil </span><span class="cov9" title="9">{
                        payer, err := userRepo.GetByID(ctx, *p.PayerID)
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                        }</span>

                        <span class="cov8" title="8">if payer == nil </span><span class="cov1" title="1">{
                                return nil, except.NotFoundError("payer not found")
                        }</span>

                        <span class="cov8" title="7">if payer.GroupID == nil || expns.GroupID != *payer.GroupID </span><span class="cov1" title="1">{
                                return nil, except.UnprocessableEntityError("group mismatch")
                        }</span>
                }

                <span class="cov7" title="6">if p.ReceiverID != nil </span><span class="cov7" title="6">{
                        receiver, err := userRepo.GetByID(ctx, *p.ReceiverID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                        }</span>

                        <span class="cov7" title="6">if receiver == nil </span><span class="cov1" title="1">{
                                return nil, except.NotFoundError("receiver not found")
                        }</span>

                        <span class="cov7" title="5">if receiver.GroupID == nil || expns.GroupID != *receiver.GroupID </span><span class="cov0" title="0">{
                                return nil, except.UnprocessableEntityError("group mismatch")
                        }</span>
                }

                <span class="cov7" title="5">if p.CategoryID != nil </span><span class="cov7" title="5">{
                        catgry, err := categoryRepo.GetByID(ctx, *p.CategoryID)
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("categoryRepo.GetByID: %w", err)
                        }</span>

                        <span class="cov6" title="4">if catgry == nil </span><span class="cov1" title="1">{
                                return nil, except.NotFoundError("category not found")
                        }</span>
                }

                <span class="cov5" title="3">var splitRatio *expense.SplitRatio
                if p.SplitType != nil &amp;&amp; *p.SplitType != expns.SplitType </span><span class="cov5" title="3">{
                        switch *p.SplitType </span>{
                        case expense.SplitTypes.Proportional:<span class="cov1" title="1">
                                createdAt := &amp;expns.CreatedAt
                                if p.CreatedAt != nil </span><span class="cov0" title="0">{
                                        createdAt = p.CreatedAt
                                }</span>

                                <span class="cov1" title="1">payerID := expns.PayerID
                                if p.PayerID != nil </span><span class="cov1" title="1">{
                                        payerID = *p.PayerID
                                }</span>

                                <span class="cov1" title="1">payerIncomes, err := incomeRepo.GetUserMonthlyIncomes(ctx, payerID, createdAt)
                                if err != nil || payerIncomes == nil </span><span class="cov0" title="0">{
                                        return nil, except.UnprocessableEntityError("payer income not found").SetInternal(fmt.Errorf("incomeRepo.GetUserMonthlyIncomes: %w", err))
                                }</span>

                                <span class="cov1" title="1">receiverID := expns.ReceiverID
                                if p.ReceiverID != nil </span><span class="cov1" title="1">{
                                        receiverID = *p.ReceiverID
                                }</span>
                                <span class="cov1" title="1">receiverIncomes, err := incomeRepo.GetUserMonthlyIncomes(ctx, receiverID, createdAt)
                                if err != nil || receiverIncomes == nil </span><span class="cov0" title="0">{
                                        return nil, except.UnprocessableEntityError("receiver income not found").SetInternal(fmt.Errorf("incomeRepo.GetUserMonthlyIncomes: %w", err))
                                }</span>

                                <span class="cov1" title="1">totalPayerIncome := 0
                                for _, incm := range payerIncomes </span><span class="cov1" title="1">{
                                        totalPayerIncome += incm.Amount
                                }</span>

                                <span class="cov1" title="1">totalReceiverIncome := 0
                                for _, incm := range receiverIncomes </span><span class="cov1" title="1">{
                                        totalReceiverIncome += incm.Amount
                                }</span>

                                <span class="cov1" title="1">split := expense.NewProportionalSplitRatio(totalPayerIncome, totalReceiverIncome)
                                splitRatio = &amp;split</span>
                        case expense.SplitTypes.Transfer:<span class="cov1" title="1">
                                split := expense.NewTransferRatio()
                                splitRatio = &amp;split</span>
                        default:<span class="cov1" title="1">
                                split := expense.NewEqualSplitRatio()
                                splitRatio = &amp;split</span>
                        }
                }

                <span class="cov5" title="3">if err := expns.Update(expense.UpdateAttributes{
                        Name:         p.Name,
                        Amount:       p.Amount,
                        RefundAmount: p.RefundAmount,
                        Description:  p.Description,
                        CategoryID:   p.CategoryID,
                        SplitRatio:   splitRatio,
                        SplitType:    p.SplitType,
                        PayerID:      p.PayerID,
                        ReceiverID:   p.ReceiverID,
                        CreatedAt:    p.CreatedAt,
                }); err != nil </span><span class="cov0" title="0">{
                        return nil, except.UnprocessableEntityError().SetInternal(fmt.Errorf("expense.Update: %w", err))
                }</span>

                <span class="cov5" title="3">if err := expenseRepo.Store(ctx, expns); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("expenseRepo.Store: %w", err)
                }</span>

                <span class="cov3" title="2">return expns, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/group/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        AcceptGroupInvite func(ctx *fiber.Ctx) error

        AcceptGroupInviteResponse struct{}
)

func NewAcceptGroupInvite(acceptGroupInvite usecase.AcceptGroupInvite) AcceptGroupInvite <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                email, ok := ctx.Locals("email").(string)
                if !ok </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(fmt.Errorf("email not found in context"))
                }</span>

                <span class="cov0" title="0">token := ctx.Params("token")

                if token == "" </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(fmt.Errorf("token not found in params"))
                }</span>

                <span class="cov0" title="0">if err := acceptGroupInvite(ctx.Context(), usecase.AcceptGroupInviteInput{
                        Email: email,
                        Token: token,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("usecase.AcceptGroupInvite: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).SendString("Invite accepted successfully!")</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/group/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        CreateGroup func(ctx *fiber.Ctx) error

        CreateGroupRequest struct {
                Name string `json:"name" validate:"required,min=3,max=50"`
        }

        CreateGroupResponse struct {
                ID   int    `json:"id"`
                Name string `json:"name"`
        }
)

func NewCreateGroup(createGroup usecase.CreateGroup) CreateGroup <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req CreateGroupRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">userID, ok := ctx.Locals("user_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(fmt.Errorf("user_id not found in context"))
                }</span>

                <span class="cov0" title="0">group, err := createGroup(ctx.Context(), usecase.CreateGroupInput{
                        Name:   req.Name,
                        UserID: user.ID{Value: userID},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("createGroup: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, CreateGroupResponse{
                                ID:   group.ID.Value,
                                Name: group.Name,
                        }),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/group/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        GetGroup func(ctx *fiber.Ctx) error
)

func NewGetGroup(getGroup postgres.GetGroup) GetGroup <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">group, err := getGroup(ctx.Context(), groupID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.getGroup: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, group))</span>
        }
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/group/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        GetGroupBalance func(ctx *fiber.Ctx) error

        GetGroupBalanceResponse struct {
                GroupID  int                    `json:"group_id"`
                Balances []postgres.UserBalance `json:"balances,omitempty"`
        }
)

func NewGetGroupBalance(getGroupBalance postgres.GetGroupBalance) GetGroupBalance <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">balances, err := getGroupBalance(ctx.Context(), groupID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.GetGroupBalance: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, GetGroupBalanceResponse{
                        GroupID:  groupID,
                        Balances: balances,
                }))</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/group/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        InviteUserToGroup func(ctx *fiber.Ctx) error

        InviteUserToGroupRequest struct {
                Email   string `json:"email" validate:"required"`
                BaseURL string `json:"base_url" validate:"required"`
        }

        InviteUserToGroupResponse struct {
                Link string `json:"link"`
        }
)

func NewInviteUserToGroup(inviteUserToGroup usecase.InviteUserToGroup) InviteUserToGroup <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var request InviteUserToGroupRequest
                if err := ctx.BodyParser(&amp;request); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(request); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(fmt.Errorf("group_id not found in context"))
                }</span>

                <span class="cov0" title="0">invite, err := inviteUserToGroup(ctx.Context(), usecase.InviteUserToGroupInput{
                        GroupID: group.ID{Value: groupID},
                        Email:   request.Email,
                        BaseURL: request.BaseURL,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("usecase.InviteUserToGroup: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, invite))</span>
        }
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package controller

import (
        "github.com/Beigelman/nossas-despesas/internal/shared/middleware"
        "github.com/gofiber/fiber/v2"
)

func Router(
        server *fiber.App,
        createGroupHandler CreateGroup,
        getGroupHandler GetGroup,
        authMiddleware middleware.AuthMiddleware,
        inviteUserToGroupHandler InviteUserToGroup,
        acceptGroupInviteHandler AcceptGroupInvite,
        getGroupBalanceHandler GetGroupBalance,
) <span class="cov0" title="0">{
        // Api group
        api := server.Group("api")
        // Api version V1
        v1 := api.Group("v1")
        // Group routes
        group := v1.Group("group", authMiddleware)
        group.Get("/", getGroupHandler)
        group.Post("/", createGroupHandler)
        group.Get("/balance", getGroupBalanceHandler)
        // Invite Router
        invite := group.Group("invite", authMiddleware)
        invite.Post("/", inviteUserToGroupHandler)
        invite.Post("/:token/accept", acceptGroupInviteHandler)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package group

import (
        "context"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type ID struct{ Value int }

type Group struct {
        ddd.Entity[ID]
        Name string
}

type Attributes struct {
        ID   ID
        Name string
}

func New(p Attributes) *Group <span class="cov10" title="12">{
        return &amp;Group{
                Entity: ddd.Entity[ID]{
                        ID:        p.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                Name: p.Name,
        }
}</span>

func (g *Group) SetName(name string) <span class="cov0" title="0">{
        g.Name = name
}</span>

type Repository interface {
        ddd.Repository[ID, Group]
        GetByName(ctx context.Context, name string) (*Group, error)
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package group

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type InviteStatus string

var InviteStatuses = struct {
        Pending  InviteStatus
        Sent     InviteStatus
        Accepted InviteStatus
}{
        Pending:  "pending",
        Sent:     "sent",
        Accepted: "accepted",
}

type InviteID struct{ Value int }

type Invite struct {
        ddd.Entity[InviteID]
        GroupID   ID
        Token     string
        Email     string
        ExpiresAt time.Time
        Status    InviteStatus
}

type InviteAttributes struct {
        ID        InviteID
        GroupID   ID
        Token     string
        Email     string
        ExpiresAt time.Time
}

func NewInvite(params InviteAttributes) *Invite <span class="cov10" title="12">{
        return &amp;Invite{
                Entity: ddd.Entity[InviteID]{
                        ID:        params.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                GroupID:   params.GroupID,
                Token:     params.Token,
                Email:     params.Email,
                ExpiresAt: params.ExpiresAt,
                Status:    InviteStatuses.Pending,
        }
}</span>

func (g *Invite) Url(basePath string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/group/%s/accept", basePath, g.Token)
}</span>

func (g *Invite) CheckStatus() error <span class="cov6" title="4">{
        if g.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return fmt.Errorf("group invite expired")
        }</span>

        <span class="cov6" title="4">if g.Status != InviteStatuses.Sent </span><span class="cov1" title="1">{
                return fmt.Errorf("group invite status is %s and not sent", g.Status)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

func (g *Invite) Accept() error <span class="cov0" title="0">{
        if g.Status != InviteStatuses.Sent </span><span class="cov0" title="0">{
                return fmt.Errorf("group invite was not sent")
        }</span>

        <span class="cov0" title="0">g.Status = InviteStatuses.Accepted
        return nil</span>
}

func (g *Invite) Sent() error <span class="cov4" title="3">{
        if g.Status != InviteStatuses.Pending &amp;&amp; g.Status != InviteStatuses.Sent </span><span class="cov0" title="0">{
                return fmt.Errorf("group invite is not pending")
        }</span>

        <span class="cov4" title="3">g.Status = InviteStatuses.Sent
        return nil</span>
}

type InviteRepository interface {
        ddd.Repository[InviteID, Invite]
        GetGroupInvitesByEmail(ctx context.Context, groupID ID, email string) ([]Invite, error)
        GetByToken(ctx context.Context, token string) (*Invite, error)
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package group

import (
        "context"

        "github.com/Beigelman/nossas-despesas/internal/modules/group/controller"
        "github.com/Beigelman/nossas-despesas/internal/modules/group/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/group/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
)

var Module = eon.NewModule("Group", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        // group
        di.Provide(c, postgres.NewGroupRepository)
        di.Provide(c, postgres.NewGroupInviteRepository)
        di.Provide(c, usecase.NewCreateGroup)
        di.Provide(c, usecase.NewInviteUserToGroup)
        di.Provide(c, usecase.NewAcceptGroupInvite)
        di.Provide(c, postgres.NewGetGroup)
        di.Provide(c, postgres.NewGetGroupBalance)
        di.Provide(c, controller.NewInviteUserToGroup)
        di.Provide(c, controller.NewAcceptGroupInvite)
        di.Provide(c, controller.NewGetGroupBalance)
        di.Provide(c, controller.NewCreateGroup)
        di.Provide(c, controller.NewGetGroup)
        // Register routes
        lc.OnBooted(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{ return di.Call(c, controller.Router) }</span>)
})
</pre>
		
		<pre class="file" id="file65" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type (
        Member struct {
                ID             int       `db:"id" json:"id"`
                Name           string    `db:"name" json:"name"`
                Email          string    `db:"email" json:"email"`
                GroupID        int       `db:"group_id" json:"group_id"`
                ProfilePicture *string   `db:"profile_picture" json:"profile_picture,omitempty"`
                CreatedAt      time.Time `db:"created_at" json:"created_at"`
                UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
        }

        Group struct {
                ID        int       `db:"id" json:"id"`
                Name      string    `db:"name" json:"name"`
                Members   []Member  `json:"members"`
                CreatedAt time.Time `db:"created_at" json:"created_at"`
                UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
        }

        GetGroup func(ctx context.Context, groupID int) (*Group, error)
)

func NewGetGroup(db *db.Client) GetGroup <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, groupID int) (*Group, error) </span><span class="cov0" title="0">{
                var group Group

                if err := dbClient.GetContext(ctx, &amp;group, `
                        select
                    id,
                        name,
                        created_at,
                        updated_at 
                        from groups
                        where id = $1
                `, groupID); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                                return nil, except.NotFoundError("group not found")
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("db.GetContext: %w", err)</span>
                }

                <span class="cov0" title="0">var members []Member
                if err := dbClient.SelectContext(ctx, &amp;members, `
                        select
                    id,
                        name,
                        email,
                        group_id,
                        profile_picture,
                        created_at,
                        updated_at 
                        from users
                        where group_id = $1
                `, groupID); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.Select: %w", err)
                }</span>

                <span class="cov0" title="0">group.Members = members

                return &amp;group, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        UserBalance struct {
                UserID  int     `db:"user_id" json:"user_id"`
                Balance float32 `db:"balance" json:"balance"`
        }

        GetGroupBalance func(ctx context.Context, groupID int) ([]UserBalance, error)
)

func NewGetGroupBalance(db *db.Client) GetGroupBalance <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, groupID int) ([]UserBalance, error) </span><span class="cov0" title="0">{
                var balances []UserBalance
                if err := dbClient.SelectContext(ctx, &amp;balances, `
                        WITH base AS (
                            SELECT
                                distinct on (id) id as id,
                                case when refund_amount_cents is null then amount_cents else amount_cents - refund_amount_cents end as amount_cents,
                                group_id,
                                split_ratio,
                                payer_id,
                                receiver_id,
                                deleted_at
                            FROM expenses
                            WHERE group_id = $1
                            ORDER BY id desc, version DESC
                        ), balances AS (
                            SELECT
                                user_id,
                                balance,
                                type
                            FROM (
                                        SELECT payer_id AS user_id, SUM((amount_cents * (split_ratio-&gt;&gt;'receiver')::numeric / 100)) AS balance, 'payer' as type
                                        FROM base
                                        WHERE deleted_at IS NULL
                                        GROUP BY payer_id
        
                                        UNION ALL
        
                                        SELECT receiver_id AS user_id, SUM((amount_cents * (split_ratio-&gt;&gt;'receiver')::numeric / 100)) AS balance, 'receiver' as type
                                        FROM base
                                        WHERE deleted_at IS NULL
                                        GROUP BY receiver_id
                                 ) AS balances
                        )
                        SELECT
                            user_id,
                            SUM(CASE WHEN type = 'payer' THEN balance ELSE balance * -1 END) AS balance
                        FROM balances
                        GROUP BY user_id
                `, &amp;groupID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">return balances, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type GroupRepository struct {
        db *sqlx.DB
}

func NewGroupRepository(db *db.Client) group.Repository <span class="cov1" title="1">{
        return &amp;GroupRepository{db: db.Conn()}
}</span>

// GetNextID implements group.UserRepository.
func (repo *GroupRepository) GetNextID() group.ID <span class="cov10" title="3">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('groups_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.Select: %w", err))</span>
        }

        <span class="cov10" title="3">return group.ID{Value: nextValue}</span>
}

// GetByID implements group.UserRepository.
func (repo *GroupRepository) GetByID(ctx context.Context, id group.ID) (*group.Group, error) <span class="cov1" title="1">{
        var model GroupModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, created_at, updated_at, deleted_at, version
                FROM groups WHERE id = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return groupToEntity(model), nil</span>
}

// GetByName implements group.UserRepository.
func (repo *GroupRepository) GetByName(ctx context.Context, name string) (*group.Group, error) <span class="cov1" title="1">{
        var model GroupModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, created_at, updated_at, deleted_at, version
                FROM groups WHERE name = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, name).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return groupToEntity(model), nil</span>
}

// Store implements group.UserRepository.
func (repo *GroupRepository) Store(ctx context.Context, entity *group.Group) error <span class="cov10" title="3">{
        model := groupToModel(entity)

        if err := repo.create(ctx, model); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov0" title="0">{
                        if err := repo.update(ctx, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("repo.update: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("repo.create: %w", err)</span>
        }

        <span class="cov10" title="3">return nil</span>
}

func (repo *GroupRepository) create(ctx context.Context, model GroupModel) error <span class="cov10" title="3">{
        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO groups (id, name, created_at, updated_at, deleted_at, version)
                VALUES (:id, :name, :created_at, :updated_at, :deleted_at, :version)
        `, &amp;model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Insert: %w", err)
        }</span>

        <span class="cov10" title="3">return nil</span>
}

func (repo *GroupRepository) update(ctx context.Context, model GroupModel) error <span class="cov0" title="0">{
        result, err := repo.db.NamedExecContext(ctx, `
                UPDATE groups SET name = :name, updated_at = :updated_at, deleted_at = :deleted_at, version = version + 1
                WHERE id = :id AND version = :version
        `, &amp;model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: sql: no rows affected")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type GroupInviteRepository struct {
        db *sqlx.DB
}

func NewGroupInviteRepository(db *db.Client) group.InviteRepository <span class="cov1" title="1">{
        return &amp;GroupInviteRepository{db: db.Conn()}
}</span>

func (repo *GroupInviteRepository) GetNextID() group.InviteID <span class="cov10" title="5">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('group_invites_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.Select: %w", err))</span>
        }

        <span class="cov10" title="5">return group.InviteID{Value: nextValue}</span>
}

func (repo *GroupInviteRepository) GetByID(ctx context.Context, id group.InviteID) (*group.Invite, error) <span class="cov1" title="1">{
        var model GroupInviteModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, email, group_id, status, token, expires_at, created_at, updated_at, deleted_at, version
                FROM group_invites WHERE id = $1
                AND deleted_at IS NULL
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return groupInviteToEntity(model), nil</span>
}

func (repo *GroupInviteRepository) GetByToken(ctx context.Context, token string) (*group.Invite, error) <span class="cov1" title="1">{
        var model GroupInviteModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, email, group_id, status, token, expires_at, created_at, updated_at, deleted_at, version
                FROM group_invites WHERE token = $1
                AND deleted_at IS NULL
        `, token).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return groupInviteToEntity(model), nil</span>
}

func (repo *GroupInviteRepository) GetGroupInvitesByEmail(ctx context.Context, groupID group.ID, email string) ([]group.Invite, error) <span class="cov1" title="1">{
        var models []GroupInviteModel

        if err := repo.db.SelectContext(ctx, &amp;models, `
                SELECT id, email, group_id, status, token, expires_at, created_at, updated_at, deleted_at, version
                FROM group_invites WHERE email = $1
                and group_id = $2
                AND deleted_at IS NULL
                ORDER BY created_at DESC
        `, email, groupID.Value); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">var entities []group.Invite
        for _, model := range models </span><span class="cov4" title="2">{
                entities = append(entities, *groupInviteToEntity(model))
        }</span>

        <span class="cov1" title="1">return entities, nil</span>
}

func (repo *GroupInviteRepository) Store(ctx context.Context, entity *group.Invite) error <span class="cov10" title="5">{
        model := groupInviteToModel(entity)
        if err := repo.create(ctx, model); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov0" title="0">{
                        if err := repo.update(ctx, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("repo.update: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("repo.create: %w", err)</span>
        }

        <span class="cov10" title="5">return nil</span>
}

func (repo *GroupInviteRepository) create(ctx context.Context, model GroupInviteModel) error <span class="cov10" title="5">{
        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO group_invites (id, email, group_id, status, token, expires_at, created_at, updated_at, deleted_at, version)
                VALUES (:id, :email, :group_id, :status, :token, :expires_at, :created_at, :updated_at, :deleted_at, :version)
        `, model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Insert: %w", err)
        }</span>

        <span class="cov10" title="5">return nil</span>
}

func (repo *GroupInviteRepository) update(ctx context.Context, model GroupInviteModel) error <span class="cov0" title="0">{
        result, err := repo.db.NamedExecContext(ctx, `
                UPDATE group_invites SET status = :status, updated_at = :updated_at, deleted_at = :deleted_at, version = version + 1
                WHERE id = :id and version = :version
        `, model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: sql: no rows affected")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package postgres

import (
        "database/sql"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

func groupToEntity(model GroupModel) *group.Group <span class="cov4" title="2">{
        var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov4" title="2">return &amp;group.Group{
                Entity: ddd.Entity[group.ID]{
                        ID:        group.ID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                Name: model.Name,
        }</span>
}

func groupToModel(entity *group.Group) GroupModel <span class="cov7" title="3">{
        var deletedAt sql.NullTime
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span> else<span class="cov7" title="3"> {
                deletedAt = sql.NullTime{Time: time.Time{}, Valid: false}
        }</span>

        <span class="cov7" title="3">return GroupModel{
                ID:        entity.ID.Value,
                Name:      entity.Name,
                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: deletedAt,
                Version:   entity.Version,
        }</span>
}

func groupInviteToEntity(model GroupInviteModel) *group.Invite <span class="cov8" title="4">{
        var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov8" title="4">return &amp;group.Invite{
                Entity: ddd.Entity[group.InviteID]{
                        ID:        group.InviteID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                GroupID:   group.ID{Value: model.GroupID},
                Token:     model.Token,
                Email:     model.Email,
                ExpiresAt: model.ExpiresAt,
                Status:    group.InviteStatus(model.Status),
        }</span>
}

func groupInviteToModel(entity *group.Invite) GroupInviteModel <span class="cov10" title="5">{
        deletedAt := sql.NullTime{Time: time.Time{}, Valid: false}
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span>

        <span class="cov10" title="5">return GroupInviteModel{
                ID:        entity.ID.Value,
                GroupID:   entity.GroupID.Value,
                Email:     entity.Email,
                Token:     entity.Token,
                Status:    string(entity.Status),
                ExpiresAt: entity.ExpiresAt,
                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: deletedAt,
                Version:   entity.Version,
        }</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type (
        AcceptGroupInviteInput struct {
                Email string
                Token string
        }

        AcceptGroupInvite func(ctx context.Context, input AcceptGroupInviteInput) error
)

func NewAcceptGroupInvite(
        userRepository user.Repository,
        groupInviteRepository group.InviteRepository,
) AcceptGroupInvite <span class="cov1" title="1">{
        return func(ctx context.Context, input AcceptGroupInviteInput) error </span><span class="cov10" title="8">{
                usr, err := userRepository.GetByEmail(ctx, input.Email)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("userRepository.GetByEmail: %w", err)
                }</span>

                <span class="cov9" title="7">if usr.GroupID != nil </span><span class="cov1" title="1">{
                        return except.UnprocessableEntityError("user already in a group")
                }</span>

                <span class="cov8" title="6">groupInvite, err := groupInviteRepository.GetByToken(ctx, input.Token)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("groupInviteRepository.GetByToken: %w", err)
                }</span>

                <span class="cov7" title="5">if groupInvite == nil </span><span class="cov1" title="1">{
                        return except.NotFoundError("invite not found")
                }</span>

                <span class="cov7" title="4">if err := groupInvite.CheckStatus(); err != nil </span><span class="cov1" title="1">{
                        return except.UnprocessableEntityError("invalid invite").SetInternal(err)
                }</span>

                <span class="cov5" title="3">if groupInvite.Email != usr.Email </span><span class="cov1" title="1">{
                        return except.UnprocessableEntityError("invalid invite email")
                }</span>

                <span class="cov4" title="2">usr.AssignGroup(groupInvite.GroupID)

                if err := userRepository.Store(ctx, usr); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("userRepository.Store: %w", err)
                }</span>

                <span class="cov1" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type CreateGroupInput struct {
        Name   string
        UserID user.ID
}

type CreateGroup func(ctx context.Context, params CreateGroupInput) (*group.Group, error)

func NewCreateGroup(userRepo user.Repository, groupRepo group.Repository) CreateGroup <span class="cov1" title="1">{
        return func(ctx context.Context, params CreateGroupInput) (*group.Group, error) </span><span class="cov10" title="5">{
                usr, err := userRepo.GetByID(ctx, params.UserID)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                }</span>

                <span class="cov8" title="4">if usr.GroupID != nil </span><span class="cov1" title="1">{
                        return nil, except.UnprocessableEntityError("user already in a group")
                }</span>

                <span class="cov7" title="3">newGroup := group.New(group.Attributes{
                        ID:   groupRepo.GetNextID(),
                        Name: params.Name,
                })

                if err := groupRepo.Store(ctx, newGroup); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("groupRepo.Store: %w", err)
                }</span>

                <span class="cov4" title="2">usr.AssignGroup(newGroup.ID)

                if err := userRepo.Store(ctx, usr); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.Store: %w", err)
                }</span>

                <span class="cov1" title="1">return newGroup, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package usecase

import (
        "context"
        "fmt"
        "html/template"
        "log/slog"
        "strings"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        vo "github.com/Beigelman/nossas-despesas/internal/shared/infra/email"
        "github.com/Beigelman/nossas-despesas/internal/shared/service"
        "github.com/google/uuid"
)

type (
        InviteUserToGroupInput struct {
                GroupID group.ID
                Email   string
                BaseURL string
        }

        InviteUserToGroup func(ctx context.Context, input InviteUserToGroupInput) (*group.Invite, error)
)

func NewInviteUserToGroup(
        userRepo user.Repository,
        groupRepo group.Repository,
        groupInviteRepo group.InviteRepository,
        emailProvider service.EmailProvider,
) InviteUserToGroup <span class="cov1" title="1">{
        return func(ctx context.Context, input InviteUserToGroupInput) (*group.Invite, error) </span><span class="cov10" title="8">{
                grp, err := groupRepo.GetByID(ctx, input.GroupID)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("groupRepo.GetByID: %w", err)
                }</span>

                <span class="cov9" title="7">if grp == nil </span><span class="cov1" title="1">{
                        return nil, except.NotFoundError("group not found")
                }</span>

                <span class="cov8" title="6">invitee, err := userRepo.GetByEmail(ctx, input.Email)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.GetByEmail: %w", err)
                }</span>

                <span class="cov7" title="5">if invitee != nil &amp;&amp; invitee.GroupID != nil </span><span class="cov1" title="1">{
                        return nil, except.UnprocessableEntityError("user already in a group")
                }</span>

                <span class="cov7" title="4">invites, err := groupInviteRepo.GetGroupInvitesByEmail(ctx, grp.ID, input.Email)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("groupInviteRepo.GetByEmail: %w", err)
                }</span>

                <span class="cov5" title="3">if len(invites) &gt; 3 &amp;&amp; invites[2].CreatedAt.After(time.Now().Add(-time.Hour*48)) </span><span class="cov1" title="1">{
                        return nil, except.NewHTTPError(429, "too many invites sent to this email recently")
                }</span>

                <span class="cov4" title="2">groupInvite := group.NewInvite(group.InviteAttributes{
                        ID:        groupInviteRepo.GetNextID(),
                        GroupID:   grp.ID,
                        Token:     uuid.NewString(),
                        Email:     input.Email,
                        ExpiresAt: time.Now().Add(time.Hour * 48),
                })

                if err := groupInviteRepo.Store(ctx, groupInvite); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("groupInviteRepo.Store: %w", err)
                }</span>

                // TODO: mudar isso para subscriber a adicionar evento de convite para grupo criado.
                <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                        tmpl, err := template.ParseFiles("./templates/group_invite.html")
                        if err != nil </span><span class="cov1" title="1">{
                                slog.Error("failed to parse template file", "error", err)
                                return
                        }</span>

                        <span class="cov0" title="0">html := strings.Builder{}
                        if err := tmpl.Execute(&amp;html, map[string]any{
                                "GroupName": grp.Name,
                                "Link":      groupInvite.Url(input.BaseURL),
                        }); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to execute template", "error", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if err := emailProvider.Send(ctx, vo.Email{
                                From:    "noreplay@nossasdespesas.com.br",
                                To:      []string{input.Email},
                                Html:    html.String(),
                                Subject: "Convite para compartilhar despesas",
                        }); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to send group invite email", "error", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if err := groupInvite.Sent(); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to update group invite status", "error", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if err := groupInviteRepo.Store(ctx, groupInvite); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to update group invite status", "error", err)
                                return
                        }</span>

                        <span class="cov0" title="0">slog.Info("group invite email sent", "email", input.Email)</span>
                }()

                <span class="cov1" title="1">return groupInvite, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/income/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        CreateIncome func(ctx *fiber.Ctx) error

        CreateIncomeRequest struct {
                Type      string     `json:"type" validate:"oneof=salary benefit vacation thirteenth_salary other"`
                Amount    int        `json:"amount" validate:"required"`
                CreatedAt *time.Time `json:"created_at"`
                UserID    *int       `json:"user_id"`
        }

        CreateIncomeResponse struct {
                ID int `json:"id"`
        }
)

func NewCreateIncome(createIncome usecase.CreateIncome) CreateIncome <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req CreateIncomeRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">var (
                        userID int
                        ok     bool
                )
                if req.UserID == nil </span><span class="cov0" title="0">{
                        userID, ok = ctx.Locals("user_id").(int)
                        if !ok </span><span class="cov0" title="0">{
                                return except.BadRequestError("invalid user id")
                        }</span>
                } else<span class="cov0" title="0"> {
                        userID = *req.UserID
                }</span>

                <span class="cov0" title="0">groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("missing context group_id")
                }</span>

                <span class="cov0" title="0">inc, err := createIncome(ctx.Context(), usecase.CreateIncomeParams{
                        UserID:    user.ID{Value: userID},
                        GroupID:   group.ID{Value: groupID},
                        Type:      income.Type(req.Type),
                        Amount:    req.Amount,
                        CreatedAt: req.CreatedAt,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("createIncome: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, CreateIncomeResponse{ID: inc.ID.Value}),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "strconv"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/income/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        DeleteIncome func(ctx *fiber.Ctx) error

        DeleteIncomeResponse struct {
                ID int `json:"id"`
        }
)

func NewDeleteIncome(deleteIncome usecase.DeleteIncome) DeleteIncome <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                userID, ok := ctx.Locals("user_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid user id")
                }</span>

                <span class="cov0" title="0">groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">incomeID, err := strconv.Atoi(ctx.Params("income_id"))
                if err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid income id")
                }</span>

                <span class="cov0" title="0">inc, err := deleteIncome(ctx.Context(), usecase.DeleteIncomeParams{
                        ID:      income.ID{Value: incomeID},
                        UserID:  user.ID{Value: userID},
                        GroupID: group.ID{Value: groupID},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("updateIncome: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, DeleteIncomeResponse{ID: inc.ID.Value}),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/income/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type GetIncomesPerPeriod func(ctx *fiber.Ctx) error

type GetIncomesPerPeriodReq struct {
        StartDate time.Time `query:"start_date"`
        EndDate   time.Time `query:"end_date"`
}

func NewGetIncomesPerPeriod(getIncomesPerMonth postgres.GetIncomesPerPeriod) GetIncomesPerPeriod <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">var params GetIncomesPerPeriodReq
                if err := ctx.QueryParser(&amp;params); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">incomesPerMonth, err := getIncomesPerMonth(ctx.Context(), postgres.GetIncomesPerPeriodInput{
                        GroupID:   groupID,
                        StartDate: params.StartDate,
                        EndDate:   params.EndDate,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.GetIncomesPerPeriod: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, incomesPerMonth))</span>
        }
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/income/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        GetMonthlyIncome func(ctx *fiber.Ctx) error

        GetMonthlyIncomeResponse struct {
                GroupID int                   `json:"group_id"`
                Incomes []postgres.UserIncome `json:"incomes"`
                Total   int                   `json:"total"`
                Month   time.Month            `json:"month"`
        }
)

func NewGetMonthlyIncome(getGroupMonthlyIncome postgres.GetMonthlyIncome) GetMonthlyIncome <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>
                <span class="cov0" title="0">date, err := time.Parse(time.DateOnly, ctx.Query("date", ""))
                if err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid date")
                }</span>

                <span class="cov0" title="0">incs, err := getGroupMonthlyIncome(ctx.Context(), groupID, date)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.GetGroupMonthlyIncome: %w", err)
                }</span>

                <span class="cov0" title="0">var totalIncome int
                for _, inc := range incs </span><span class="cov0" title="0">{
                        totalIncome += inc.Amount
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, GetMonthlyIncomeResponse{
                        GroupID: groupID,
                        Incomes: incs,
                        Total:   totalIncome,
                        Month:   date.Month(),
                }))</span>
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package controller

import (
        "github.com/Beigelman/nossas-despesas/internal/shared/middleware"
        "github.com/gofiber/fiber/v2"
)

func Router(
        server *fiber.App,
        authMiddleware middleware.AuthMiddleware,
        createIncomeHandler CreateIncome,
        updateIncomeHandler UpdateIncome,
        deleteIncomeHandler DeleteIncome,
        getMonthlyIncomeHandler GetMonthlyIncome,
        getIncomesPerPeriodHandler GetIncomesPerPeriod,
) <span class="cov0" title="0">{
        // Api group
        api := server.Group("api")
        // Api version V1
        v1 := api.Group("v1")
        // Income routes
        income := v1.Group("incomes", authMiddleware)
        income.Get("/", getMonthlyIncomeHandler)
        income.Post("/", createIncomeHandler)
        income.Patch("/:income_id", updateIncomeHandler)
        income.Delete("/:income_id", deleteIncomeHandler)
        income.Get("/insights", getIncomesPerPeriodHandler)
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/income/usecase"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/pkg/validator"
        "github.com/gofiber/fiber/v2"
)

type (
        UpdateIncome func(ctx *fiber.Ctx) error

        UpdateIncomeRequest struct {
                Type      *string    `json:"type" validate:"omitempty,oneof=salary benefit vacation thirteenth_salary other"`
                Amount    *int       `json:"amount" validate:"omitempty,gt=0"`
                CreatedAt *time.Time `json:"created_at" validate:"omitempty"`
        }

        UpdateIncomeResponse struct {
                ID int `json:"id"`
        }
)

func NewUpdateIncome(updateIncome usecase.UpdateIncome) UpdateIncome <span class="cov0" title="0">{
        valid := validator.New()
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                groupID, ok := ctx.Locals("group_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid group id")
                }</span>

                <span class="cov0" title="0">userID, ok := ctx.Locals("user_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid user id")
                }</span>

                <span class="cov0" title="0">incomeID, err := strconv.Atoi(ctx.Params("income_id"))
                if err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid income id")
                }</span>

                <span class="cov0" title="0">var req UpdateIncomeRequest
                if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return except.UnprocessableEntityError().SetInternal(err)
                }</span>

                <span class="cov0" title="0">if err := valid.Validate(req); err != nil </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid request body").SetInternal(err)
                }</span>

                <span class="cov0" title="0">inc, err := updateIncome(ctx.Context(), usecase.UpdateIncomeParams{
                        ID:      income.ID{Value: incomeID},
                        UserID:  user.ID{Value: userID},
                        GroupID: group.ID{Value: groupID},
                        Type: func() *income.Type </span><span class="cov0" title="0">{
                                if req.Type == nil </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">t := income.Type(*req.Type)
                                return &amp;t</span>
                        }(),
                        Amount:    req.Amount,
                        CreatedAt: req.CreatedAt,
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("updateIncome: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusCreated).JSON(
                        api.NewResponse(http.StatusCreated, UpdateIncomeResponse{ID: inc.ID.Value}),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package income

import (
        "context"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type Type string

func (i Type) String() string <span class="cov10" title="5">{
        return string(i)
}</span>

var Types = struct {
        Salary           Type
        Benefit          Type
        ThirteenthSalary Type
        Vacation         Type
        Other            Type
}{
        Salary:           "salary",
        Benefit:          "benefit",
        ThirteenthSalary: "thirteenth_salary",
        Vacation:         "vacation",
        Other:            "other",
}

type ID struct{ Value int }

type Income struct {
        ddd.Entity[ID]
        UserID user.ID
        Amount int
        Type   Type
}

type Attributes struct {
        ID        ID
        UserID    user.ID
        Amount    int
        Type      Type
        CreatedAt *time.Time
}

func New(params Attributes) *Income <span class="cov10" title="5">{
        createdAt := time.Now()
        if params.CreatedAt != nil </span><span class="cov7" title="3">{
                createdAt = *params.CreatedAt
        }</span>
        <span class="cov10" title="5">return &amp;Income{
                Entity: ddd.Entity[ID]{
                        ID:        params.ID,
                        CreatedAt: createdAt,
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                UserID: params.UserID,
                Amount: params.Amount,
                Type:   params.Type,
        }</span>
}

type UpdateAttributes struct {
        Amount    *int
        Type      *Type
        CreatedAt *time.Time
}

func (i *Income) Update(attr UpdateAttributes) <span class="cov0" title="0">{
        if attr.Type != nil </span><span class="cov0" title="0">{
                i.Type = *attr.Type
        }</span>

        <span class="cov0" title="0">if attr.Amount != nil </span><span class="cov0" title="0">{
                i.Amount = *attr.Amount
        }</span>

        <span class="cov0" title="0">if attr.CreatedAt != nil </span><span class="cov0" title="0">{
                i.CreatedAt = *attr.CreatedAt
        }</span>

        <span class="cov0" title="0">i.UpdatedAt = time.Now()</span>
}

func (i *Income) Delete() <span class="cov0" title="0">{
        now := time.Now()
        i.UpdatedAt = now
        i.DeletedAt = &amp;now
}</span>

type Repository interface {
        ddd.Repository[ID, Income]
        GetUserMonthlyIncomes(ctx context.Context, userID user.ID, date *time.Time) ([]Income, error)
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package income

import (
        "context"

        "github.com/Beigelman/nossas-despesas/internal/modules/income/controller"
        "github.com/Beigelman/nossas-despesas/internal/modules/income/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/income/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
)

var Module = eon.NewModule("Income", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        // income
        di.Provide(c, postgres.NewIncomeRepository)
        di.Provide(c, usecase.NewCreateIncome)
        di.Provide(c, usecase.NewUpdateIncome)
        di.Provide(c, usecase.NewDeleteIncome)
        di.Provide(c, postgres.NewGetIncomesPerPeriod)
        di.Provide(c, postgres.NewGetMonthlyIncome)
        di.Provide(c, controller.NewCreateIncome)
        di.Provide(c, controller.NewUpdateIncome)
        di.Provide(c, controller.NewDeleteIncome)
        di.Provide(c, controller.NewGetMonthlyIncome)
        di.Provide(c, controller.NewGetIncomesPerPeriod)
        // Register routes
        lc.OnBooted(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{ return di.Call(c, controller.Router) }</span>)
})
</pre>
		
		<pre class="file" id="file81" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        IncomesPerPeriod struct {
                Date   string `db:"date" json:"date"`
                Amount int    `db:"amount" json:"amount"`
                Count  int    `db:"quantity" json:"quantity"`
        }

        GetIncomesPerPeriodInput struct {
                GroupID   int       `json:"group_id"`
                Aggregate string    `json:"aggregate"`
                StartDate time.Time `json:"start_date"`
                EndDate   time.Time `json:"end_date"`
        }

        GetIncomesPerPeriod func(ctx context.Context, params GetIncomesPerPeriodInput) ([]IncomesPerPeriod, error)
)

func NewGetIncomesPerPeriod(db *db.Client) GetIncomesPerPeriod <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, params GetIncomesPerPeriodInput) ([]IncomesPerPeriod, error) </span><span class="cov0" title="0">{
                var expensesPerMonth []IncomesPerPeriod

                trunc, format := "day", "YYYY-MM-DD"
                switch params.Aggregate </span>{
                case "month":<span class="cov0" title="0">
                        trunc = "month"
                        format = "YYYY-MM"</span>
                case "day":<span class="cov0" title="0">
                        trunc = "day"
                        format = "YYYY-MM-DD"</span>
                }

                <span class="cov0" title="0">query := fmt.Sprintf(`
                        with base as (
                            select
                                amount_cents amount,
                                created_at as created_at,
                                deleted_at as deleted_at
                            from incomes
                                    where user_id in (select id from users where group_id = $1)
                                      and created_at &gt;= $2
                                      and created_at &lt;= $3
                        )
                        select 
                                to_char(date_trunc('%s', b.created_at), '%s') as date, 
                                sum(amount) as amount,
                                count(1) as quantity
                        from base b
                        where b.deleted_at is null
                        group by 1
                        order by 1;
                `, trunc, format)
                if err := dbClient.SelectContext(
                        ctx, &amp;expensesPerMonth,
                        query, params.GroupID,
                        params.StartDate, params.EndDate,
                ); err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">return expensesPerMonth, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
)

type (
        UserIncome struct {
                ID        int       `db:"id" json:"id"`
                UserID    int       `db:"user_id" json:"user_id"`
                Type      string    `db:"type" json:"type"`
                Amount    int       `db:"amount_cents" json:"amount"`
                CreatedAt time.Time `db:"created_at" json:"created_at"`
        }

        GetMonthlyIncome func(ctx context.Context, groupID int, date time.Time) ([]UserIncome, error)
)

func NewGetMonthlyIncome(db *db.Client) GetMonthlyIncome <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, groupID int, date time.Time) ([]UserIncome, error) </span><span class="cov0" title="0">{
                var balances []UserIncome
                if err := dbClient.SelectContext(ctx, &amp;balances, `
                        SELECT id, user_id, type, amount_cents, created_at 
                        FROM incomes
                        WHERE user_id IN (SELECT id FROM users WHERE group_id = $1)
                        AND extract(month from created_at) = $2
                        AND extract(year from created_at) = $3
                        AND deleted_at is null
                `, groupID, date.Month(), date.Year()); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.SelectContext: %w", err)
                }</span>

                <span class="cov0" title="0">return balances, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type IncomeRepository struct {
        db *sqlx.DB
}

func NewIncomeRepository(db *db.Client) income.Repository <span class="cov1" title="1">{
        return &amp;IncomeRepository{db: db.Conn()}
}</span>

func (repo *IncomeRepository) GetNextID() income.ID <span class="cov10" title="5">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('incomes_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.Select: %w", err))</span>
        }

        <span class="cov10" title="5">return income.ID{Value: nextValue}</span>
}

func (repo *IncomeRepository) GetByID(ctx context.Context, id income.ID) (*income.Income, error) <span class="cov1" title="1">{
        var model IncomeModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, user_id, amount_cents, type, created_at, updated_at, deleted_at, version
                FROM incomes WHERE id = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return toEntity(model), nil</span>
}

func (repo *IncomeRepository) GetUserMonthlyIncomes(ctx context.Context, userID user.ID, date *time.Time) ([]income.Income, error) <span class="cov1" title="1">{
        var incomes []IncomeModel

        d := time.Now()
        if date != nil </span><span class="cov1" title="1">{
                d = *date
        }</span>

        <span class="cov1" title="1">if err := repo.db.SelectContext(ctx, &amp;incomes, `
                SELECT id, user_id, amount_cents, type, created_at, updated_at, deleted_at, version
                FROM incomes WHERE user_id = $1
                AND EXTRACT(month FROM created_at) = $2
                AND EXTRACT(year FROM created_at) = $3
                AND deleted_at IS NULL
        `, userID.Value, d.Month(), d.Year()); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">var entities []income.Income
        for _, inc := range incomes </span><span class="cov4" title="2">{
                entities = append(entities, *toEntity(inc))
        }</span>

        <span class="cov1" title="1">return entities, nil</span>
}

func (repo *IncomeRepository) Store(ctx context.Context, entity *income.Income) error <span class="cov10" title="5">{
        model := toModel(entity)
        if err := repo.create(ctx, model); err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov0" title="0">{
                        if err := repo.update(ctx, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("repo.update: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("repo.create: %w", err)</span>
        }

        <span class="cov10" title="5">return nil</span>
}

func (repo *IncomeRepository) create(ctx context.Context, model IncomeModel) error <span class="cov10" title="5">{
        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO incomes (id, user_id, amount_cents, type, created_at, updated_at, deleted_at, version)
                VALUES (:id, :user_id, :amount_cents, :type, :created_at, :updated_at, :deleted_at, :version)
        `, model); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Insert: %w", err)
        }</span>

        <span class="cov10" title="5">return nil</span>
}

func (repo *IncomeRepository) update(ctx context.Context, model IncomeModel) error <span class="cov0" title="0">{
        result, err := repo.db.NamedExecContext(ctx, `
                UPDATE incomes SET amount_cents = :amount_cents, type = :type, created_at = :created_at, updated_at = :updated_at, deleted_at = :deleted_at, version = version + 1
                WHERE id = :id and version = :version
        `, model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: sql: no rows affected")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package postgres

import (
        "database/sql"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

func toEntity(model IncomeModel) *income.Income <span class="cov7" title="3">{
        var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov7" title="3">return &amp;income.Income{
                Entity: ddd.Entity[income.ID]{
                        ID:        income.ID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                UserID: user.ID{Value: model.UserID},
                Amount: model.Amount,
                Type:   income.Type(model.Type),
        }</span>
}

func toModel(entity *income.Income) IncomeModel <span class="cov10" title="5">{
        deletedAt := sql.NullTime{Time: time.Time{}, Valid: false}
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span>

        <span class="cov10" title="5">return IncomeModel{
                ID:        entity.ID.Value,
                UserID:    entity.UserID.Value,
                Amount:    entity.Amount,
                Type:      entity.Type.String(),
                CreatedAt: entity.CreatedAt,
                UpdatedAt: entity.UpdatedAt,
                DeletedAt: deletedAt,
                Version:   entity.Version,
        }</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package usecase

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub"
)

type (
        CreateIncomeParams struct {
                Type      income.Type
                Amount    int
                UserID    user.ID
                GroupID   group.ID
                CreatedAt *time.Time
        }

        CreateIncome func(ctx context.Context, p CreateIncomeParams) (*income.Income, error)
)

func NewCreateIncome(
        userRepo user.Repository,
        incomeRepo income.Repository,
        publisher pubsub.Publisher,
) CreateIncome <span class="cov0" title="0">{
        return func(ctx context.Context, p CreateIncomeParams) (*income.Income, error) </span><span class="cov0" title="0">{
                usr, err := userRepo.GetByID(ctx, p.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                }</span>

                <span class="cov0" title="0">if usr == nil </span><span class="cov0" title="0">{
                        return nil, except.NotFoundError("user not found")
                }</span>

                <span class="cov0" title="0">inc := income.New(income.Attributes{
                        ID:        incomeRepo.GetNextID(),
                        UserID:    usr.ID,
                        Amount:    p.Amount,
                        Type:      p.Type,
                        CreatedAt: p.CreatedAt,
                })

                if err := incomeRepo.Store(ctx, inc); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("incomeRepo.Store: %w", err)
                }</span>

                <span class="cov0" title="0">event := pubsub.IncomeEvent{
                        Event: pubsub.Event{
                                SentAt:  time.Now(),
                                Type:    "income_created",
                                UserID:  p.UserID,
                                GroupID: p.GroupID,
                        },
                        Income: *inc,
                }
                if err := publisher.Publish(ctx, pubsub.IncomesTopic, event); err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(ctx, "failed to publish income created event", "error", err)
                }</span>

                <span class="cov0" title="0">return inc, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package usecase

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub"
)

type (
        DeleteIncomeParams struct {
                ID      income.ID
                UserID  user.ID
                GroupID group.ID
        }
        DeleteIncome func(ctx context.Context, p DeleteIncomeParams) (*income.Income, error)
)

func NewDeleteIncome(
        incomeRepo income.Repository,
        userRepo user.Repository,
        publisher pubsub.Publisher,
) DeleteIncome <span class="cov0" title="0">{
        return func(ctx context.Context, p DeleteIncomeParams) (*income.Income, error) </span><span class="cov0" title="0">{
                inc, err := incomeRepo.GetByID(ctx, p.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("incomeRepo.GetByID: %w", err)
                }</span>

                <span class="cov0" title="0">usr, err := userRepo.GetByID(ctx, p.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                }</span>

                <span class="cov0" title="0">if usr == nil </span><span class="cov0" title="0">{
                        return nil, except.NotFoundError("user not found")
                }</span>

                <span class="cov0" title="0">if !usr.HasFlag(user.EDIT_PARTNER_INCOME) &amp;&amp; inc.UserID != p.UserID </span><span class="cov0" title="0">{
                        return nil, except.ForbiddenError("user mismatch")
                }</span>

                <span class="cov0" title="0">inc.Delete()

                if err := incomeRepo.Store(ctx, inc); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("incomeRepo.Store: %w", err)
                }</span>

                <span class="cov0" title="0">event := pubsub.IncomeEvent{
                        Event: pubsub.Event{
                                SentAt:  time.Now(),
                                Type:    "income_deleted",
                                UserID:  p.UserID,
                                GroupID: p.GroupID,
                        },
                        Income: *inc,
                }
                if err := publisher.Publish(ctx, pubsub.IncomesTopic, event); err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(ctx, "failed to publish income created event", "error", err)
                }</span>

                <span class="cov0" title="0">return inc, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package usecase

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub"
)

type (
        UpdateIncomeParams struct {
                ID        income.ID
                UserID    user.ID
                GroupID   group.ID
                Type      *income.Type
                Amount    *int
                CreatedAt *time.Time
        }
        UpdateIncome func(ctx context.Context, p UpdateIncomeParams) (*income.Income, error)
)

func NewUpdateIncome(
        incomeRepo income.Repository,
        userRepo user.Repository,
        publisher pubsub.Publisher,
) UpdateIncome <span class="cov0" title="0">{
        return func(ctx context.Context, p UpdateIncomeParams) (*income.Income, error) </span><span class="cov0" title="0">{
                inc, err := incomeRepo.GetByID(ctx, p.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("incomeRepo.GetByID: %w", err)
                }</span>

                <span class="cov0" title="0">usr, err := userRepo.GetByID(ctx, p.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("userRepo.GetByID: %w", err)
                }</span>

                <span class="cov0" title="0">if usr == nil </span><span class="cov0" title="0">{
                        return nil, except.NotFoundError("user not found")
                }</span>

                <span class="cov0" title="0">if !usr.HasFlag(user.EDIT_PARTNER_INCOME) &amp;&amp; inc.UserID != p.UserID </span><span class="cov0" title="0">{
                        return nil, except.ForbiddenError("user mismatch")
                }</span>

                <span class="cov0" title="0">inc.Update(income.UpdateAttributes{
                        Amount:    p.Amount,
                        Type:      p.Type,
                        CreatedAt: p.CreatedAt,
                })

                if err := incomeRepo.Store(ctx, inc); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("incomeRepo.Store: %w", err)
                }</span>

                <span class="cov0" title="0">event := pubsub.IncomeEvent{
                        Event: pubsub.Event{
                                SentAt:  time.Now(),
                                Type:    "income_updated",
                                UserID:  p.UserID,
                                GroupID: p.GroupID,
                        },
                        Income: *inc,
                }
                if err := publisher.Publish(ctx, pubsub.IncomesTopic, event); err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(ctx, "failed to publish income created event", "error", err)
                }</span>

                <span class="cov0" title="0">return inc, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package controller

import (
        "fmt"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/modules/user/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

type (
        GetMe func(ctx *fiber.Ctx) error
)

func NewGetMe(getUserID postgres.GetUserByID) GetMe <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                userID, ok := ctx.Locals("user_id").(int)
                if !ok </span><span class="cov0" title="0">{
                        return except.BadRequestError("invalid user_id")
                }</span>

                <span class="cov0" title="0">user, err := getUserID(ctx.Context(), userID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("query.getUser: %w", err)
                }</span>

                <span class="cov0" title="0">return ctx.Status(http.StatusOK).JSON(api.NewResponse(http.StatusOK, user))</span>
        }
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package controller

import (
        "github.com/Beigelman/nossas-despesas/internal/shared/middleware"
        "github.com/gofiber/fiber/v2"
)

func Router(
        server *fiber.App,
        getMyUserHandler GetMe,
        authMiddleware middleware.AuthMiddleware,
) <span class="cov0" title="0">{
        // Api group
        api := server.Group("api")
        // Api version V1
        v1 := api.Group("v1")
        user := v1.Group("user", authMiddleware)
        user.Get("/me", getMyUserHandler)
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package user

import (
        "context"

        "github.com/Beigelman/nossas-despesas/internal/modules/user/controller"
        "github.com/Beigelman/nossas-despesas/internal/modules/user/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/user/usecase"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
)

var Module = eon.NewModule("User", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        di.Provide(c, postgres.NewUserRepository)
        di.Provide(c, usecase.NewCreateUser)
        di.Provide(c, postgres.NewGetUserByID)
        di.Provide(c, controller.NewGetMe)

        lc.OnBooted(eon.HookOrders.PREPEND, func() error </span><span class="cov0" title="0">{
                return di.Call(c, controller.Router)
        }</span>)
})
</pre>
		
		<pre class="file" id="file91" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/lib/pq"
)

type User struct {
        ID             int            `db:"id" json:"id"`
        Name           string         `db:"name" json:"name"`
        Email          string         `db:"email" json:"email"`
        GroupID        *int           `db:"group_id" json:"group_id,omitempty"`
        ProfilePicture *string        `db:"profile_picture" json:"profile_picture,omitempty"`
        Flags          pq.StringArray `db:"flags"`
        CreatedAt      string         `db:"created_at" json:"created_at"`
        UpdatedAt      string         `db:"updated_at" json:"updated_at"`
}

type GetUserByID func(ctx context.Context, userID int) (*User, error)

func NewGetUserByID(db *db.Client) GetUserByID <span class="cov0" title="0">{
        dbClient := db.Conn()
        return func(ctx context.Context, userID int) (*User, error) </span><span class="cov0" title="0">{
                var user User
                if err := dbClient.GetContext(ctx, &amp;user, `
                        select id, name, email, profile_picture, group_id, flags, created_at, updated_at
                        from users
                        where id = $1        
                `, userID); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                                return nil, except.NotFoundError("user not found")
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("db.GetContext: %w", err)</span>
                }

                <span class="cov0" title="0">return &amp;user, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package postgres

import (
        "database/sql"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
        "github.com/lib/pq"
)

func toEntity(model UserModel) *user.User <span class="cov5" title="2">{
        var profilePicture *string
        if model.ProfilePicture.Valid </span><span class="cov0" title="0">{
                profilePicture = &amp;model.ProfilePicture.String
        }</span>

        <span class="cov5" title="2">var deletedAt *time.Time
        if model.DeletedAt.Valid </span><span class="cov0" title="0">{
                deletedAt = &amp;model.DeletedAt.Time
        }</span>

        <span class="cov5" title="2">var groupID *group.ID
        if model.GroupID.Valid </span><span class="cov0" title="0">{
                groupID = &amp;group.ID{Value: int(model.GroupID.Int64)}
        }</span>

        <span class="cov5" title="2">flags := []user.Flag{}
        for _, f := range model.Flags </span><span class="cov8" title="3">{
                flags = append(flags, user.Flag(f))
        }</span>

        <span class="cov5" title="2">return &amp;user.User{
                Entity: ddd.Entity[user.ID]{
                        ID:        user.ID{Value: model.ID},
                        CreatedAt: model.CreatedAt,
                        UpdatedAt: model.UpdatedAt,
                        DeletedAt: deletedAt,
                        Version:   model.Version,
                },
                GroupID:        groupID,
                Name:           model.Name,
                Email:          model.Email,
                Flags:          flags,
                ProfilePicture: profilePicture,
        }</span>
}

func toModel(entity *user.User) UserModel <span class="cov10" title="4">{
        profilePicture := sql.NullString{String: "", Valid: false}
        if entity.ProfilePicture != nil </span><span class="cov0" title="0">{
                profilePicture = sql.NullString{String: *entity.ProfilePicture, Valid: true}
        }</span>
        <span class="cov10" title="4">deletedAt := sql.NullTime{Time: time.Time{}, Valid: false}
        if entity.DeletedAt != nil </span><span class="cov0" title="0">{
                deletedAt = sql.NullTime{Time: *entity.DeletedAt, Valid: true}
        }</span>

        <span class="cov10" title="4">groupID := sql.NullInt64{Int64: 0, Valid: false}
        if entity.GroupID != nil </span><span class="cov0" title="0">{
                groupID = sql.NullInt64{Int64: int64(entity.GroupID.Value), Valid: true}
        }</span>

        <span class="cov10" title="4">flags := pq.StringArray{}
        for _, f := range entity.Flags </span><span class="cov10" title="4">{
                flags = append(flags, string(f))
        }</span>

        <span class="cov10" title="4">return UserModel{
                ID:             entity.ID.Value,
                Name:           entity.Name,
                Email:          entity.Email,
                GroupID:        groupID,
                ProfilePicture: profilePicture,
                Flags:          flags,
                CreatedAt:      entity.CreatedAt,
                UpdatedAt:      entity.UpdatedAt,
                DeletedAt:      deletedAt,
                Version:        entity.Version,
        }</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"

        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
)

type UserRepository struct {
        db *sqlx.DB
}

func NewUserRepository(db *db.Client) user.Repository <span class="cov1" title="1">{
        return &amp;UserRepository{db: db.Conn()}
}</span>

// GetNextID implements user.UserRepository.
func (repo *UserRepository) GetNextID() user.ID <span class="cov8" title="3">{
        var nextValue int

        if err := repo.db.QueryRowx("SELECT nextval('users_id_seq');").Scan(&amp;nextValue); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("db.Select: %w", err))</span>
        }

        <span class="cov8" title="3">return user.ID{Value: nextValue}</span>
}

// GetByID implements user.UserRepository.
func (repo *UserRepository) GetByID(ctx context.Context, id user.ID) (*user.User, error) <span class="cov1" title="1">{
        var model UserModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, email, profile_picture, group_id, flags, created_at, updated_at, deleted_at, version
                FROM users WHERE id = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, id.Value).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return toEntity(model), nil</span>
}

func (repo *UserRepository) GetByEmail(ctx context.Context, email string) (*user.User, error) <span class="cov1" title="1">{
        var model UserModel

        if err := repo.db.QueryRowxContext(ctx, `
                SELECT id, name, email, profile_picture, group_id, flags, created_at, updated_at, deleted_at, version
                FROM users WHERE email = $1
                AND deleted_at IS NULL
                ORDER BY version DESC
                LIMIT 1
        `, email).StructScan(&amp;model); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("db.Select: %w", err)</span>
        }

        <span class="cov1" title="1">return toEntity(model), nil</span>
}

// Store implements user.UserRepository.
func (repo *UserRepository) Store(ctx context.Context, entity *user.User) error <span class="cov10" title="4">{
        model := toModel(entity)
        if err := repo.create(ctx, model); err != nil </span><span class="cov1" title="1">{
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") </span><span class="cov1" title="1">{
                        if err := repo.update(ctx, model); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("repo.update: %w", err)
                        }</span>
                        <span class="cov1" title="1">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("repo.create: %w", err)</span>
        }

        <span class="cov8" title="3">return nil</span>
}

func (repo *UserRepository) create(ctx context.Context, model UserModel) error <span class="cov10" title="4">{
        if _, err := repo.db.NamedExecContext(ctx, `
                INSERT INTO users (id, name, email, group_id, profile_picture, flags, created_at, updated_at, deleted_at, version)
    VALUES (:id, :name, :email, :group_id, :profile_picture, :flags, :created_at, :updated_at, :deleted_at, :version)
        `, model); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("db.Insert: %w", err)
        }</span>

        <span class="cov8" title="3">return nil</span>
}

func (repo *UserRepository) update(ctx context.Context, model UserModel) error <span class="cov1" title="1">{
        result, err := repo.db.NamedExecContext(ctx, `
    UPDATE users SET name = :name, group_id = :group_id, profile_picture = :profile_picture, flags = :flags, updated_at = now(), deleted_at = :deleted_at, version = version + 1
                WHERE id = :id and version = :version
        `, model)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("db.Update: sql: no rows affected")
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package usecase

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
)

type CreateUserParams struct {
        Name             string
        Email            string
        ProfilePicture   *string
        AuthenticationID *string
        GroupID          *group.ID
}

type CreateUser func(ctx context.Context, p CreateUserParams) (*user.User, error)

func NewCreateUser(userRepo user.Repository) CreateUser <span class="cov1" title="1">{
        return func(ctx context.Context, p CreateUserParams) (*user.User, error) </span><span class="cov10" title="4">{
                alreadyExists, err := userRepo.GetByEmail(ctx, p.Email)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.GetByName: %w", err)
                }</span>

                <span class="cov8" title="3">if alreadyExists != nil </span><span class="cov1" title="1">{
                        return nil, except.ConflictError("email already exists")
                }</span>

                <span class="cov5" title="2">usr := user.New(user.Attributes{
                        ID:             userRepo.GetNextID(),
                        Name:           p.Name,
                        Email:          p.Email,
                        ProfilePicture: p.ProfilePicture,
                        GroupID:        p.GroupID,
                })

                if err := userRepo.Store(ctx, usr); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("userRepo.Store: %w", err)
                }</span>

                <span class="cov1" title="1">return usr, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package user

import (
        "context"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/pkg/ddd"
)

type ID struct{ Value int }

type User struct {
        ddd.Entity[ID]
        Name           string
        Email          string
        ProfilePicture *string
        GroupID        *group.ID
        Flags          []Flag
}

type Attributes struct {
        ID             ID
        Name           string
        Email          string
        ProfilePicture *string
        GroupID        *group.ID
}

func New(p Attributes) *User <span class="cov10" title="20">{
        return &amp;User{
                Entity: ddd.Entity[ID]{
                        ID:        p.ID,
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                        Version:   0,
                },
                Name:           p.Name,
                Email:          p.Email,
                ProfilePicture: p.ProfilePicture,
                GroupID:        p.GroupID,
                Flags:          []Flag{},
        }
}</span>

func (u *User) HasFlag(flag Flag) bool <span class="cov0" title="0">{
        for _, f := range u.Flags </span><span class="cov0" title="0">{
                if f == flag </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (u *User) AddFlag(flag Flag) <span class="cov5" title="5">{
        u.Flags = append(u.Flags, flag)
}</span>

func (u *User) RemoveFlag(flag Flag) <span class="cov1" title="1">{
        filtredFlags := u.Flags[:0]
        for _, f := range u.Flags </span><span class="cov4" title="3">{
                if f == flag </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov3" title="2">filtredFlags = append(filtredFlags, f)</span>
        }

        <span class="cov1" title="1">u.Flags = filtredFlags</span>
}

func (u *User) SetEmail(email string) <span class="cov0" title="0">{
        u.Email = email
}</span>

func (u *User) AssignGroup(g group.ID) <span class="cov5" title="4">{
        u.GroupID = &amp;g
}</span>

type Repository interface {
        ddd.Repository[ID, User]
        GetByEmail(ctx context.Context, email string) (*User, error)
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package api

import (
        "errors"
        "fmt"
        "log/slog"
        "net/http"

        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/gofiber/fiber/v2"
)

func ErrorHandler(ctx *fiber.Ctx, err error) error <span class="cov0" title="0">{
        requestId, ok := ctx.Locals("requestid").(string)
        if !ok </span><span class="cov0" title="0">{
                requestId = "unknown"
        }</span>

        <span class="cov0" title="0">code := http.StatusInternalServerError
        message := http.StatusText(code)
        errMsg := ""
        var e *except.HTTPError
        if errors.As(err, &amp;e) </span><span class="cov0" title="0">{
                code = e.Code
                message = e.Message.(string)
                errMsg = e.Error()
        }</span>

        <span class="cov0" title="0">slog.Error(
                fmt.Sprintf("Error calling %s %s", ctx.Method(), ctx.Path()),
                slog.String("request_id", requestId),
                slog.Int("status_code", code),
                slog.String("error", err.Error()),
        )

        ctx.Set("Content-Type", "\"text/plain; charset=utf-8\"")

        return ctx.Status(code).JSON(ErrorResponse{
                StatusCode: code,
                Message:    message,
                Error:      errMsg,
        })</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package api

import (
        "context"
        "errors"
        "fmt"
        "log"
        "log/slog"
        "net/http"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/config"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
        "github.com/Beigelman/nossas-despesas/internal/shared/middleware"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/fiber/v2/middleware/requestid"
)

var Module = eon.NewModule("Server", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        var server *fiber.App

        di.Provide(c, middleware.NewAuthMiddleware)

        di.Provide(c, func(cfg *config.Config) *fiber.App </span><span class="cov0" title="0">{
                server = fiber.New(fiber.Config{
                        AppName:      info.ServiceName,
                        ReadTimeout:  5 * time.Second,
                        ErrorHandler: ErrorHandler,
                })

                server.Use(cors.New())
                server.Use(recover.New())
                server.Use(requestid.New())
                server.Use(middleware.LogRequest(cfg.Env, info.ServiceName))

                server.Get("health-check", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{ return c.SendString("OK") }</span>)

                <span class="cov0" title="0">return server</span>
        })

        <span class="cov0" title="0">lc.OnReady(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        cfg := di.Resolve[*config.Config](c)
                        if err := server.Listen(fmt.Sprintf(":%s", cfg.Port)); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                                log.Fatal(fmt.Errorf("server.Listen: %w", err))
                        }</span>
                }()

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">lc.OnDisposing(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{
                if server != nil </span><span class="cov0" title="0">{
                        slog.Info("Shutting down server")
                        if err := server.Shutdown(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("server.Shutdown: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
})
</pre>
		
		<pre class="file" id="file98" style="display: none">package api

import "time"

type Response[T any] struct {
        StatusCode int       `json:"status_code"`
        Data       T         `json:"data"`
        Date       time.Time `json:"date"`
}

func NewResponse[T any](statusCode int, data T) Response[T] <span class="cov0" title="0">{
        return Response[T]{
                StatusCode: statusCode,
                Data:       data,
                Date:       time.Now(),
        }
}</span>

type ErrorResponse struct {
        StatusCode int    `json:"status_code"`
        Message    string `json:"message"`
        Error      string `json:"error,omitempty"`
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package config

import (
        "fmt"
        "reflect"

        "github.com/spf13/viper"
)

func bindStructEnv(v *viper.Viper, obj any) error <span class="cov0" title="0">{
        // Get the reflection Value of the struct
        val := reflect.ValueOf(obj)
        // Check if the passed interface is a struct
        if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fmt.Errorf("provided interface is not a struct")
        }</span>

        // Iterate over the fields of the struct
        <span class="cov0" title="0">for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
                // Get the field type
                key := val.Type().Field(i).Tag.Get("mapstructure")
                if err := bindEnv(v, key); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("config.bindStructEnv: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func bindEnv(v *viper.Viper, key string) error <span class="cov0" title="0">{
        if err := v.BindEnv(key); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config.bindEnv: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package config

import (
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/spf13/viper"
)

type Db struct {
        Host             string        `mapstructure:"DB_HOST"`
        Port             string        `mapstructure:"DB_PORT"`
        Name             string        `mapstructure:"DB_NAME"`
        User             string        `mapstructure:"DB_USER"`
        Password         string        `mapstructure:"DB_PASSWORD"`
        ConnectionString string        `mapstructure:"DB_CONNECTION_STRING"`
        MigrationPath    string        `mapstructure:"DB_MIGRATION_PATH"`
        MaxIdleConns     int           `mapstructure:"DB_MAX_IDLE_CONNS"`
        MaxOpenConns     int           `mapstructure:"DB_MAX_OPEN_CONNS"`
        MaxLifeTime      time.Duration `mapstructure:"DB_MAX_LIFE_TIME"`
        MaxIdleTime      time.Duration `mapstructure:"DB_MAX_IDLE_TIME"`
}

type Mail struct {
        SandBoxID string `mapstructure:"MAIL_SANDBOX_ID"`
        ApiKey    string `mapstructure:"MAIL_API_KEY"`
}

type Config struct {
        loader      *viper.Viper
        Env         env.Environment `mapstructure:"ENV"`
        ServiceName string          `mapstructure:"SERVICE_NAME"`
        Port        string          `mapstructure:"PORT"`
        LogLevel    string          `mapstructure:"LOG_LEVEL"`
        JWTSecret   string          `mapstructure:"JWT_SECRET"`
        Mail        Mail            `mapstructure:",squash"`
        Db          Db              `mapstructure:",squash"`
}

func New(env env.Environment) Config <span class="cov0" title="0">{
        return Config{
                loader:   viper.New(),
                Env:      env,
                Port:     "8080",
                LogLevel: "INFO",
                Db: Db{
                        MaxOpenConns: 4,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package config

import (
        "fmt"
        "path/filepath"
        "strings"
)

func (c *Config) SetConfigPath(path string) <span class="cov0" title="0">{
        extension := filepath.Ext(path)                       // eg: .yml
        filename := filepath.Base(path)                       // eg: config.yml
        configName := strings.TrimSuffix(filename, extension) // eg: config
        c.loader.SetConfigName(configName)                    // viper takes filename without extension

        if len(extension) &gt; 1 </span><span class="cov0" title="0">{
                configType := extension[1:]
                c.loader.SetConfigType(configType)
        }</span>

        <span class="cov0" title="0">configDir := filepath.Dir(path) // eg: /app or .
        c.loader.AddConfigPath(configDir)</span>
}

func (c *Config) LoadConfig() error <span class="cov0" title="0">{
        if err := c.loader.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("loader.ReadInConfig: %w", err)
        }</span>

        <span class="cov0" title="0">envLoader := c.loader.Sub(c.Env.String())

        if err := bindEnv(envLoader, "PORT"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("bindEnv: %w", err)
        }</span>
        <span class="cov0" title="0">if err := bindEnv(envLoader, "LOG_LEVEL"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("bindEnv: %w", err)
        }</span>
        <span class="cov0" title="0">if err := bindStructEnv(envLoader, c.Db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("bindStructEnv: %w", err)
        }</span>
        <span class="cov0" title="0">if err := bindStructEnv(envLoader, c.Mail); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("bindStructEnv: %w", err)
        }</span>
        <span class="cov0" title="0">if err := envLoader.Unmarshal(&amp;c); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("envLoader.Unmarshal: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Config) DBConnectionString() string <span class="cov0" title="0">{
        if c.Db.ConnectionString != "" </span><span class="cov0" title="0">{
                return c.Db.ConnectionString
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("host=%s port=%s user=%s dbname=%s password=%s sslmode=disable", c.Db.Host, c.Db.Port, c.Db.User, c.Db.Name, c.Db.Password)</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package config

import (
        "context"
        "fmt"
        "log/slog"
        "os"

        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
        "github.com/Beigelman/nossas-despesas/internal/pkg/logger"
)

const configPath = "./internal/pkg/config/config.yml"

var Module = eon.NewModule("Config", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        di.Provide(c, func() (*Config, error) </span><span class="cov0" title="0">{
                environment, err := env.Parse(os.Getenv("ENV"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("env.Parse: %w", err)
                }</span>

                <span class="cov0" title="0">cfg := New(environment)
                cfg.SetConfigPath(configPath)
                if err := cfg.LoadConfig(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cfg.LoadConfig: %w", err)
                }</span>

                <span class="cov0" title="0">cfg.ServiceName = info.ServiceName

                return &amp;cfg, nil</span>
        })

        <span class="cov0" title="0">lc.OnBooted(eon.HookOrders.PREPEND, func() error </span><span class="cov0" title="0">{
                cfg := di.Resolve[*Config](c)
                if cfg.Env == env.Development </span><span class="cov0" title="0">{
                        slog.SetDefault(logger.NewDevelopment(cfg.LogLevel))
                }</span> else<span class="cov0" title="0"> {
                        slog.SetDefault(logger.NewProduction(cfg.LogLevel))
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
})
</pre>
		
		<pre class="file" id="file103" style="display: none">package db

import (
        "fmt"
        "regexp"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
)

type Client struct {
        conn            *sqlx.DB
        env             env.Environment
        name            string
        migrateClient   *migrate.Migrate
        migrationPath   string
        maxIdleConns    int
        maxOpenConns    int
        connMaxIdleTime time.Duration
        connMaxLifeTime time.Duration
}

func defaultClient() *Client <span class="cov7" title="9">{
        return &amp;Client{
                maxIdleConns:    DefaultMaxIdleConns,
                maxOpenConns:    DefaultMaxOpenConn,
                connMaxIdleTime: DefaultConnMaxIdleTime,
                connMaxLifeTime: DefaultConnMaxLifeTime,
        }
}</span>

func NewClient(connString string, options ...Option) (*Client, error) <span class="cov7" title="9">{
        client := defaultClient()
        for _, opt := range options </span><span class="cov7" title="9">{
                if err := opt(client); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("apply option: %w", err)
                }</span>
        }

        <span class="cov7" title="9">conn, err := sqlx.Connect("pgx", connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sqlx.Connect: %w", err)
        }</span>

        <span class="cov7" title="9">conn.SetMaxIdleConns(client.maxIdleConns)
        conn.SetMaxOpenConns(client.maxOpenConns)
        conn.SetConnMaxIdleTime(client.connMaxIdleTime)
        conn.SetConnMaxLifetime(client.connMaxLifeTime)

        client.conn = conn
        client.name = getDBName(connString)

        return client, nil</span>
}

func (sql *Client) Conn() *sqlx.DB <span class="cov10" title="21">{
        return sql.conn
}</span>

func (sql *Client) Close() error <span class="cov7" title="9">{
        if sql.conn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov7" title="9">return sql.conn.Close()</span>
}

func getDBName(connectionString string) string <span class="cov7" title="9">{
        re := regexp.MustCompile(`dbname=([^\s]+)`)
        matches := re.FindStringSubmatch(connectionString)
        if len(matches) &gt; 1 </span><span class="cov7" title="9">{
                return matches[1]
        }</span>

        <span class="cov0" title="0">return "default"</span>
}

func (sql *Client) Clean(tables ...string) error <span class="cov7" title="10">{
        if len(tables) == 0 </span><span class="cov0" title="0">{
                rows, err := sql.conn.Queryx(`
                        SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' and table_type = 'BASE TABLE' and table_name != 'schema_migrations';
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get DB tables: %w", err)
                }</span>

                <span class="cov0" title="0">var tableName string
                for rows.Next() </span><span class="cov0" title="0">{
                        err := rows.Scan(&amp;tableName)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to scan %s: %w", tableName, err)
                        }</span>

                        <span class="cov0" title="0">if _, err = sql.conn.Exec(fmt.Sprintf("TRUNCATE TABLE %s;", tableName)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to truncate table %s: %w", tableName, err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov7" title="10">for _, table := range tables </span><span class="cov7" title="10">{
                if _, err := sql.conn.Exec(fmt.Sprintf("TRUNCATE TABLE %s;", table)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to truncate table %s: %w", table, err)
                }</span>
        }

        <span class="cov7" title="10">return nil</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package db

import (
        "context"
        "fmt"

        "github.com/docker/go-connections/nat"
        testcontainers "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/log"
        "github.com/testcontainers/testcontainers-go/wait"
)

// ContainerConfig represents the configuration for a Postgres container.
// It contains the image, database name, user, password, port and logger disabled option.
type ContainerConfig struct {
        Image          string
        DBName         string
        User           string
        Password       string
        Port           string
        LoggerDisabled bool
}

// PostgresContainer represents a Postgres container.
// It contains the container, the host, port, user, password and database name.

type PostgresContainer struct {
        testcontainers.Container
        Host     string
        Port     string
        User     string
        Password string
        DBName   string
}

// ConnString returns the connection string to the database.
func (c PostgresContainer) ConnString() string <span class="cov6" title="9">{
        return fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", c.Host, c.Port, c.User, c.Password, c.DBName)
}</span>

// StartPostgres starts a new Postgres container.
// It returns a PostgresContainer or an error if the container fails to start.
// Example:
//
//        container, err := StartPostgres(ctx)
//        if err != nil {
//                log.Fatalf("failed to start postgres container: %v", err)
//        }
func StartPostgres(ctx context.Context) (*PostgresContainer, error) <span class="cov5" title="6">{
        return StartPostgresWithConfig(ctx, ContainerConfig{LoggerDisabled: true})
}</span>

// StartPostgresWithConfig starts a new Postgres container with a custom configuration.
// It returns a PostgresContainer or an error if the container fails to start.
// Example:
//
//        container, err := StartPostgresWithConfig(ctx, ContainerConfig{
//                Image: "postgres:16-alpine",
//        })
func StartPostgresWithConfig(ctx context.Context, cfg ContainerConfig) (*PostgresContainer, error) <span class="cov5" title="6">{
        var logger log.Logger
        if cfg.LoggerDisabled </span><span class="cov5" title="6">{
                logger = noopLogger{}
        }</span>

        <span class="cov5" title="6">req := configToContainerRequest(&amp;cfg)
        container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
                ContainerRequest: req,
                Started:          true,
                Logger:           logger,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">mappedPort, err := container.MappedPort(ctx, nat.Port(req.ExposedPorts[0]))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">hostIP, err := container.Host(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="6">return &amp;PostgresContainer{
                Container: container,
                Host:      hostIP,
                Port:      mappedPort.Port(),
                Password:  cfg.Password,
                User:      cfg.User,
                DBName:    cfg.DBName,
        }, nil</span>
}

func configToContainerRequest(cfg *ContainerConfig) testcontainers.ContainerRequest <span class="cov5" title="6">{
        if cfg.Image == "" </span><span class="cov5" title="6">{
                cfg.Image = "postgres:16-alpine"
        }</span>

        <span class="cov5" title="6">if cfg.Port == "" </span><span class="cov5" title="6">{
                cfg.Port = fmt.Sprintf("%s/tcp", "5432")
        }</span> else<span class="cov0" title="0"> {
                cfg.Port = fmt.Sprintf("%s/tcp", cfg.Port)
        }</span>

        <span class="cov5" title="6">if cfg.User == "" </span><span class="cov5" title="6">{
                cfg.User = "root"
        }</span>

        <span class="cov5" title="6">if cfg.Password == "" </span><span class="cov5" title="6">{
                cfg.Password = "root"
        }</span>

        <span class="cov5" title="6">if cfg.DBName == "" </span><span class="cov5" title="6">{
                cfg.DBName = "default"
        }</span>

        <span class="cov5" title="6">return testcontainers.ContainerRequest{
                Image:        cfg.Image,
                ExposedPorts: []string{cfg.Port},
                WaitingFor: wait.ForAll(
                        wait.ForLog("database system is ready to accept connections"),
                        wait.ForSQL(nat.Port(cfg.Port), "postgres", func(host string, port nat.Port) string </span><span class="cov5" title="6">{
                                return fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", cfg.User, cfg.Password, host, port.Port(), cfg.DBName)
                        }</span>),
                ),
                Env: map[string]string{
                        "POSTGRES_USER":     cfg.User,
                        "POSTGRES_PASSWORD": cfg.Password,
                        "POSTGRES_DB":       cfg.DBName,
                },
        }
}

type noopLogger struct{}

func (l noopLogger) Printf(_ string, _ ...interface{}) {<span class="cov10" title="42">}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package db

import (
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
)

func (sql *Client) MigrateUp() error <span class="cov10" title="9">{
        migrateClient, err := sql.getMigrateClient()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get migrate client: %w", err)
        }</span>

        <span class="cov10" title="9">err = migrateClient.Up()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to perform migration: %w", err)
        }</span>
        <span class="cov10" title="9">return nil</span>
}

func (sql *Client) MigrateDown() error <span class="cov0" title="0">{
        if sql.env == env.Production </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">migrateClient, err := sql.getMigrateClient()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get migrate client: %w", err)
        }</span>

        <span class="cov0" title="0">err = migrateClient.Down()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to perform migration down: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sql *Client) getMigrateClient() (*migrate.Migrate, error) <span class="cov10" title="9">{
        if sql.migrateClient != nil </span><span class="cov0" title="0">{
                return sql.migrateClient, nil
        }</span>

        <span class="cov10" title="9">driver, err := postgres.WithInstance(sql.conn.DB, &amp;postgres.Config{
                DatabaseName: sql.name,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get DB instance: %w", err)
        }</span>

        <span class="cov10" title="9">migrateClient, err := migrate.NewWithDatabaseInstance(sql.migrationPath, "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create migrate client: %w", err)
        }</span>

        <span class="cov10" title="9">return migrateClient, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package db

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/Beigelman/nossas-despesas/internal/pkg/config"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
)

var Module = eon.NewModule("Database", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        di.Provide(c, func(cfg *config.Config) (*Client, error) </span><span class="cov0" title="0">{
                dbClient, err := NewClient(
                        cfg.DBConnectionString(),
                        WithConnMaxIdleTime(cfg.Db.MaxIdleTime),
                        WithConnMaxLifeTime(cfg.Db.MaxLifeTime),
                        WithMaxIdleConns(cfg.Db.MaxIdleConns),
                        WithMaxOpenConns(cfg.Db.MaxOpenConns),
                        WithMigrationPath(cfg.Db.MigrationPath),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("db.New: %w", err)
                }</span>

                <span class="cov0" title="0">return dbClient, nil</span>
        })

        <span class="cov0" title="0">lc.OnDisposing(eon.HookOrders.PREPEND, func() error </span><span class="cov0" title="0">{
                slog.Info("Closing db connection")
                dbClient := di.Resolve[*Client](c)
                if err := dbClient.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dbClient.Close: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
})
</pre>
		
		<pre class="file" id="file107" style="display: none">package db

import (
        "fmt"
        "os"
        "path/filepath"
        "time"
)

type Option func(c *Client) error

const (
        DefaultMaxIdleConns    = 1
        DefaultMaxOpenConn     = 3
        DefaultConnMaxLifeTime = 1 * time.Minute
        DefaultConnMaxIdleTime = 5 * time.Minute
)

// WithMaxIdleConns sets the maximum number of idle connections to the database.
// It returns an Option that can be used to configure the client.
//
// Example:
//
//        client, err := NewClient("host=localhost port=5432 user=postgres password=postgres dbname=postgres sslmode=disable", sqldb.WithMaxIdleConns(10))
//        if err != nil {
//                log.Fatalf("failed to create client: %v", err)
//        }
func WithMaxIdleConns(max int) Option <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.maxIdleConns = max
                return nil
        }</span>
}

// WithMaxOpenConns sets the maximum number of open connections to the database.
// It returns an Option that can be used to configure the client.
//
// Example:
//
//        client, err := NewClient("host=localhost port=5432 user=postgres password=postgres dbname=postgres sslmode=disable", sqldb.WithMaxOpenConns(10))
//        if err != nil {
//                log.Fatalf("failed to create client: %v", err)
//        }
func WithMaxOpenConns(max int) Option <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.maxOpenConns = max
                return nil
        }</span>
}

// WithConnMaxLifeTime sets the maximum lifetime of a connection to the database.
// It returns an Option that can be used to configure the client.
//
// Example:
//
//        client, err := NewClient("host=localhost port=5432 user=postgres password=postgres dbname=postgres sslmode=disable", sqldb.WithConnMaxLifeTime(10 * time.Second))
//        if err != nil {
//                log.Fatalf("failed to create client: %v", err)
//        }
func WithConnMaxLifeTime(max time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.connMaxLifeTime = max
                return nil
        }</span>
}

// WithConnMaxIdleTime sets the maximum idle time of a connection to the database.
// It returns an Option that can be used to configure the client.
//
// Example:
//
//        client, err := NewClient("host=localhost port=5432 user=postgres password=postgres dbname=postgres sslmode=disable", sqldb.WithConnMaxIdleTime(10 * time.Second))
//        if err != nil {
//                log.Fatalf("failed to create client: %v", err)
//        }
func WithConnMaxIdleTime(max time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) error </span><span class="cov0" title="0">{
                c.connMaxIdleTime = max
                return nil
        }</span>
}

// WithMigrationPath sets the path to the migrations files.
// It returns an Option that can be used to configure the client usually used in tests environment.
// For production environment, it's recommended to use run migrations with a CI/CD pipeline.
//
// Example:
//
//        client, err := NewClient("host=localhost port=5432 user=postgres password=postgres dbname=postgres sslmode=disable", sqldb.WithMigrationPath("database/migrations"))
//        if err != nil {
//                log.Fatalf("failed to create client: %v", err)
//        }
func WithMigrationPath(path string) Option <span class="cov6" title="9">{
        return func(c *Client) error </span><span class="cov6" title="9">{
                wrkDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("os.Getwd: %w", err)
                }</span>

                <span class="cov6" title="9">rootDir, err := findGoModRoot(wrkDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("find root dir: %w", err)
                }</span>

                <span class="cov6" title="9">c.migrationPath = fmt.Sprintf("file://%s/%s", rootDir, path)

                return nil</span>
        }
}

func findGoModRoot(startDir string) (string, error) <span class="cov6" title="9">{
        dir := startDir
        for </span><span class="cov10" title="45">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov6" title="9">{
                        return dir, nil // Found go.mod, return the directory
                }</span> else<span class="cov9" title="36"> if os.IsNotExist(err) </span><span class="cov9" title="36">{
                        parentDir := filepath.Dir(dir)
                        if parentDir == dir </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("go.mod not found")
                        }</span>
                        <span class="cov9" title="36">dir = parentDir</span> // Move up one directory
                } else<span class="cov0" title="0"> {
                        return "", err
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package db

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/jmoiron/sqlx"
)

// IsolationLevel defines the isolation levels for database transactions.
type IsolationLevel int

const (
        // DefaultIsolationLevel uses the default isolation level.
        DefaultIsolationLevel IsolationLevel = iota
        // ReadUncommittedIsolationLevel allows dirty reads.
        ReadUncommittedIsolationLevel
        // ReadCommittedIsolationLevel ensures a transaction only reads committed data.
        ReadCommittedIsolationLevel
        // WriteCommittedIsolationLevel is typically not used in most databases.
        WriteCommittedIsolationLevel
        // RepeatableReadIsolationLevel ensures consistent reads during a transaction.
        RepeatableReadIsolationLevel
        // SnapshotIsolationLevel provides snapshot isolation.
        SnapshotIsolationLevel
        // SerializableIsolationLevel is the strictest isolation level.
        SerializableIsolationLevel
        // LinearizableIsolationLevel is the strongest isolation level with total order of all operations.
        LinearizableIsolationLevel
)

// TxOptions represents the options for a transaction.
type TxOptions struct {
        ReadOnly  bool
        Isolation IsolationLevel
}

// TransactionFunction defines the function type for operations within a transaction.
// The function receives a context and a transaction object, and returns an error if any operation fails.
type TransactionFunction func(ctx context.Context, tx *sqlx.Tx) error

// NewTransactionManager creates a new TransactionManager for the Client.
// The manager handles the lifecycle of a transaction, including committing or rolling back
// depending on whether the transaction function returns an error or a panic occurs.
//
// Returns:
//   - TransactionManager: A function that manages a transaction, executing the given transaction function.
func (sql *Client) Transaction(ctx context.Context, txFn TransactionFunction, opts ...TxOptions) (err error) <span class="cov10" title="4">{
        var txOptions *TxOptions
        if len(opts) &gt; 0 </span><span class="cov0" title="0">{
                txOptions = &amp;opts[0]
        }</span> else<span class="cov10" title="4"> {
                txOptions = nil
        }</span>

        <span class="cov10" title="4">tx, err := sql.conn.BeginTxx(ctx, convertTxOptions(txOptions))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction: %w", err)
        }</span>

        <span class="cov10" title="4">defer func() </span><span class="cov10" title="4">{
                r := recover()
                if r == nil &amp;&amp; err == nil </span><span class="cov10" title="4">{
                        return
                }</span>

                <span class="cov0" title="0">if rollbackErr := tx.Rollback(); rollbackErr != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("roll back transaction: %w, err: %w", rollbackErr, err)
                }</span>

                <span class="cov0" title="0">if r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("panic: %v, err: %w", r, err)
                }</span>
        }()

        <span class="cov10" title="4">err = txFn(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("run transaction: %w", err)
        }</span>

        <span class="cov10" title="4">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit transaction: %w", err)
        }</span>

        <span class="cov10" title="4">return nil</span>
}

func convertTxOptions(txOptions *TxOptions) *sql.TxOptions <span class="cov10" title="4">{
        if txOptions == nil </span><span class="cov10" title="4">{
                return &amp;sql.TxOptions{
                        Isolation: sql.LevelDefault,
                        ReadOnly:  false,
                }
        }</span>

        <span class="cov0" title="0">var level sql.IsolationLevel

        switch txOptions.Isolation </span>{
        case ReadUncommittedIsolationLevel:<span class="cov0" title="0">
                level = sql.LevelReadUncommitted</span>
        case ReadCommittedIsolationLevel:<span class="cov0" title="0">
                level = sql.LevelReadCommitted</span>
        case WriteCommittedIsolationLevel:<span class="cov0" title="0">
                level = sql.LevelWriteCommitted</span>
        case RepeatableReadIsolationLevel:<span class="cov0" title="0">
                level = sql.LevelRepeatableRead</span>
        case SnapshotIsolationLevel:<span class="cov0" title="0">
                level = sql.LevelSnapshot</span>
        case SerializableIsolationLevel:<span class="cov0" title="0">
                level = sql.LevelSerializable</span>
        case LinearizableIsolationLevel:<span class="cov0" title="0">
                level = sql.LevelLinearizable</span>
        case DefaultIsolationLevel:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                level = sql.LevelDefault</span>
        }

        <span class="cov0" title="0">return &amp;sql.TxOptions{
                Isolation: level,
                ReadOnly:  txOptions.ReadOnly,
        }</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package dbtest

import (
        "context"
        "fmt"
        "sync"
        "testing"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/jmoiron/sqlx"
        "github.com/stretchr/testify/require"
)

var (
        container *db.PostgresContainer
        once      sync.Once
        dbCounter int
        mutex     sync.Mutex
)

func Setup(ctx context.Context, t *testing.T) *db.Client <span class="cov10" title="9">{
        t.Helper()

        var err error
        once.Do(func() </span><span class="cov8" title="6">{
                container, err = db.StartPostgres(ctx)
                require.NoError(t, err)
        }</span>)

        // Generate a unique database name for this test
        <span class="cov10" title="9">dbName := generateUniqueDBName()

        defaultDB, err := sqlx.Connect("pgx", container.ConnString())
        require.NoError(t, err)

        // Create the new test database
        err = createDatabase(defaultDB, dbName)
        require.NoError(t, err)

        // Create connection string for the new test database
        testConnString := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                container.Host, container.Port, container.User, container.Password, dbName)

        // Create client for the test database
        testDB, err := db.NewClient(testConnString, db.WithMigrationPath("database/migrations"))
        require.NoError(t, err)

        require.NoError(t, testDB.MigrateUp())

        t.Cleanup(func() </span><span class="cov10" title="9">{
                require.NoError(t, testDB.Close())
                require.NoError(t, dropDatabase(defaultDB, dbName))
                require.NoError(t, defaultDB.Close())
        }</span>)

        <span class="cov10" title="9">return testDB</span>
}

// generateUniqueDBName generates a unique database name for each test
func generateUniqueDBName() string <span class="cov10" title="9">{
        mutex.Lock()
        defer mutex.Unlock()

        dbCounter++
        return fmt.Sprintf("test_db_%d_%d", time.Now().Unix(), dbCounter)
}</span>

// createDatabase creates a new database with the given name.
// It connects to the default 'postgres' database to create the new database.
func createDatabase(conn *sqlx.DB, dbName string) error <span class="cov10" title="9">{
        if _, err := conn.Exec(fmt.Sprintf("CREATE DATABASE %s", dbName)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database %s: %w", dbName, err)
        }</span>
        <span class="cov10" title="9">return nil</span>
}

// dropDatabase drops the database with the given name.
// It connects to the default 'postgres' database to drop the target database.
func dropDatabase(conn *sqlx.DB, dbName string) error <span class="cov10" title="9">{
        terminateQuery := fmt.Sprintf(`
        SELECT pg_terminate_backend(pid)
        FROM pg_stat_activity
        WHERE datname = '%s' AND pid &lt;&gt; pg_backend_pid()`, dbName)

        _, err := conn.Exec(terminateQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to terminate connections to database %s: %w", dbName, err)
        }</span>

        <span class="cov10" title="9">if _, err := conn.Exec(fmt.Sprintf("DROP DATABASE IF EXISTS %s", dbName)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop database %s: %w", dbName, err)
        }</span>

        <span class="cov10" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Package di is a lightweight yet powerful IoC container for Go projects.
// It provides an easy-to-use interface and performance-in-mind container to be your ultimate requirement.
package di

import (
        "errors"
        "fmt"
        "reflect"
        "unsafe"
)

// binding holds a resolver and a concrete (if already resolved).
// It is the break for the Container wall!
type binding struct {
        resolver    interface{} // resolver is the function that is responsible for making the concrete.
        concrete    interface{} // concrete is the stored instance for singleton bindings.
        isSingleton bool        // isSingleton is true if the binding is a singleton.
}

// make resolves the binding if needed and returns the resolved concrete.
func (b *binding) make(c *Container) (interface{}, error) <span class="cov9" title="24">{
        if b.concrete != nil </span><span class="cov2" title="2">{
                return b.concrete, nil
        }</span>

        <span class="cov9" title="22">retVal, err := c.invoke(b.resolver)
        if b.isSingleton </span><span class="cov8" title="20">{
                b.concrete = retVal
        }</span>

        <span class="cov8" title="20">return retVal, err</span>
}

// Container holds the bindings and provides methods to interact with them.
// It is the entry point in the package.
type Container struct {
        father   *Container
        bindings map[reflect.Type]map[string]*binding
}

type NamedParam string

// New creates a new concrete of the Container.
func New() *Container <span class="cov4" title="4">{
        return &amp;Container{
                father:   nil,
                bindings: make(map[reflect.Type]map[string]*binding),
        }
}</span>

// Child creates a child container that contains all the fathers bindings.
func (c *Container) Child() *Container <span class="cov0" title="0">{
        return &amp;Container{
                father:   c,
                bindings: make(map[reflect.Type]map[string]*binding),
        }
}</span>

// bind maps an abstraction to concrete and instantiates if it is a singleton binding.
func (c *Container) bind(resolver interface{}, name string, isSingleton bool, isLazy bool) error <span class="cov9" title="27">{
        reflectedResolver := reflect.TypeOf(resolver)
        if reflectedResolver.Kind() != reflect.Func </span><span class="cov1" title="1">{
                return errors.New("container: the resolver must be a function")
        }</span>

        <span class="cov9" title="26">if reflectedResolver.NumOut() &gt; 0 </span><span class="cov9" title="25">{
                if _, exist := c.bindings[reflectedResolver.Out(0)]; !exist </span><span class="cov7" title="14">{
                        c.bindings[reflectedResolver.Out(0)] = make(map[string]*binding)
                }</span>
        }

        <span class="cov9" title="26">if err := c.validateResolverFunction(reflectedResolver); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov9" title="24">var concrete interface{}
        if !isLazy </span><span class="cov0" title="0">{
                var err error
                concrete, err = c.invoke(resolver)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov9" title="24">if isSingleton </span><span class="cov9" title="24">{
                c.bindings[reflectedResolver.Out(0)][name] = &amp;binding{resolver: resolver, concrete: concrete, isSingleton: isSingleton}
        }</span> else<span class="cov0" title="0"> {
                c.bindings[reflectedResolver.Out(0)][name] = &amp;binding{resolver: resolver, isSingleton: isSingleton}
        }</span>

        <span class="cov9" title="24">return nil</span>
}

func (c *Container) validateResolverFunction(funcType reflect.Type) error <span class="cov9" title="26">{
        retCount := funcType.NumOut()

        if retCount == 0 || retCount &gt; 2 </span><span class="cov1" title="1">{
                return errors.New("container: resolver function signature is invalid - it must return abstract, or abstract and error")
        }</span>

        <span class="cov9" title="25">resolveType := funcType.Out(0)
        for i := 0; i &lt; funcType.NumIn(); i++ </span><span class="cov2" title="2">{
                if funcType.In(i) == resolveType </span><span class="cov1" title="1">{
                        return fmt.Errorf("container: resolver function signature is invalid - depends on abstract it returns")
                }</span>
        }

        <span class="cov9" title="24">return nil</span>
}

// invoke calls a function and its returned values.
// It only accepts one value and an optional error.
func (c *Container) invoke(function interface{}) (interface{}, error) <span class="cov9" title="22">{
        arguments, err := c.arguments(function)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="22">values := reflect.ValueOf(function).Call(arguments)
        if len(values) == 2 &amp;&amp; values[1].CanInterface() </span><span class="cov1" title="1">{
                if err, ok := values[1].Interface().(error); ok </span><span class="cov1" title="1">{
                        return values[0].Interface(), err
                }</span>
        }
        <span class="cov8" title="19">return values[0].Interface(), nil</span>
}

func (c *Container) findConcrete(abstraction reflect.Type, name string) (interface{}, error) <span class="cov10" title="32">{
        ctnr := c
        for ctnr != nil </span><span class="cov10" title="32">{
                if concrete, exist := ctnr.bindings[abstraction][name]; exist </span><span class="cov9" title="24">{
                        instance, err := concrete.make(ctnr)
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("container: encountered error while making concrete for: %s. Error encountered: %w", abstraction.String(), err)
                        }</span>

                        <span class="cov8" title="21">return instance, nil</span>
                }
                <span class="cov6" title="8">ctnr = ctnr.father</span>
        }

        <span class="cov6" title="8">return nil, errors.New("container: no concrete found for: " + abstraction.String())</span>
}

// arguments returns the list of resolved arguments for a function.
func (c *Container) arguments(function interface{}) ([]reflect.Value, error) <span class="cov10" title="32">{
        reflectedFunction := reflect.TypeOf(function)
        argumentsCount := reflectedFunction.NumIn()
        arguments := make([]reflect.Value, argumentsCount)

        for i := 0; i &lt; argumentsCount; i++ </span><span class="cov7" title="12">{
                abstraction := reflectedFunction.In(i)
                if i+1 &gt;= argumentsCount || reflectedFunction.In(i+1).Kind() != reflect.String </span><span class="cov7" title="12">{
                        instance, err := c.findConcrete(abstraction, "")
                        if err != nil </span><span class="cov1" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov6" title="10">arguments[i] = reflect.ValueOf(instance)</span>
                } else<span class="cov0" title="0"> {
                        abstractionName := reflectedFunction.In(i + 1)
                        instance, err := c.findConcrete(abstraction, abstractionName.String())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">arguments[i] = reflect.ValueOf(instance)
                        i++</span>
                }
        }

        <span class="cov9" title="30">return arguments, nil</span>
}

// Reset deletes all the existing bindings and empties the container.
func (c *Container) reset() <span class="cov5" title="6">{
        for k := range c.bindings </span><span class="cov6" title="9">{
                delete(c.bindings, k)
        }</span>
}

// Call takes a receiver function with one or more arguments of the abstractions (interfaces).
// It invokes the receiver function and passes the related concretes.
func (c *Container) call(function interface{}) error <span class="cov7" title="11">{
        receiverType := reflect.TypeOf(function)
        if receiverType == nil || receiverType.Kind() != reflect.Func </span><span class="cov1" title="1">{
                return errors.New("container: invalid function")
        }</span>

        <span class="cov6" title="10">arguments, err := c.arguments(function)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="8">result := reflect.ValueOf(function).Call(arguments)

        if len(result) == 0 </span><span class="cov5" title="5">{
                return nil
        }</span> else<span class="cov3" title="3"> if len(result) == 1 &amp;&amp; result[0].CanInterface() </span><span class="cov2" title="2">{
                if result[0].IsNil() </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov1" title="1">if err, ok := result[0].Interface().(error); ok </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return errors.New("container: receiver function signature is invalid")</span>
}

// Resolve takes an abstraction (reference of an interface type) and fills it with the related concrete.
func (c *Container) resolve(abstraction interface{}) error <span class="cov6" title="8">{
        return c.namedResolve(abstraction, "")
}</span>

// NamedResolve takes abstraction and its name and fills it with the related concrete.
func (c *Container) namedResolve(abstraction interface{}, name string) error <span class="cov6" title="10">{
        receiverType := reflect.TypeOf(abstraction)
        if receiverType == nil </span><span class="cov0" title="0">{
                return errors.New("container: invalid abstraction")
        }</span>

        <span class="cov6" title="10">if receiverType.Kind() == reflect.Pointer </span><span class="cov6" title="10">{
                elem := receiverType.Elem()

                instance, err := c.findConcrete(elem, name)
                if err != nil </span><span class="cov5" title="6">{
                        return err
                }</span>

                <span class="cov4" title="4">reflect.ValueOf(abstraction).Elem().Set(reflect.ValueOf(instance))
                return nil</span>
        }

        <span class="cov0" title="0">return errors.New("container: invalid abstraction")</span>
}

// Fill takes a struct and resolves the fields with the tag `container:"inject"`
func (c *Container) fill(structure interface{}) error <span class="cov6" title="8">{
        receiverType := reflect.TypeOf(structure)
        if receiverType == nil </span><span class="cov1" title="1">{
                return errors.New("container: invalid structure")
        }</span>

        <span class="cov6" title="7">if receiverType.Kind() == reflect.Pointer </span><span class="cov6" title="7">{
                elem := receiverType.Elem()
                if elem.Kind() == reflect.Struct </span><span class="cov5" title="6">{
                        s := reflect.ValueOf(structure).Elem()

                        for i := 0; i &lt; s.NumField(); i++ </span><span class="cov7" title="13">{
                                f := s.Field(i)

                                if t, exist := s.Type().Field(i).Tag.Lookup("container"); exist </span><span class="cov7" title="11">{
                                        var name string

                                        switch t </span>{
                                        case "type":<span class="cov5" title="6">
                                                name = ""</span>
                                        case "name":<span class="cov4" title="4">
                                                name = s.Type().Field(i).Name</span>
                                        default:<span class="cov1" title="1">
                                                return fmt.Errorf("container: %v has an invalid struct tag", s.Type().Field(i).Name)</span>
                                        }

                                        <span class="cov6" title="10">instance, err := c.findConcrete(f.Type(), name)
                                        if err != nil </span><span class="cov2" title="2">{
                                                return fmt.Errorf("container: cannot make %v field: %w", s.Type().Field(i).Name, err)
                                        }</span>

                                        <span class="cov6" title="7">ptr := reflect.NewAt(f.Type(), unsafe.Pointer(f.UnsafeAddr())).Elem()
                                        ptr.Set(reflect.ValueOf(instance))</span>
                                }
                        }

                        <span class="cov2" title="2">return nil</span>
                }
        }

        <span class="cov1" title="1">return errors.New("container: invalid structure")</span>
}

// SingletonLazy binds an abstraction to concrete lazily in singleton mode.
// The concrete is resolved only when the abstraction is resolved for the first time.
// It takes a resolver function that returns the concrete, and its return type matches the abstraction (interface).
// The resolver function can have arguments of abstraction that have been declared in the Container already.
func (c *Container) singletonLazy(resolver interface{}) error <span class="cov9" title="23">{
        return c.bind(resolver, "", true, true)
}</span>

// NamedSingleton binds a named abstraction to concrete lazily in singleton mode.
// The concrete is resolved only when the abstraction is resolved for the first time.
func (c *Container) namedSingletonLazy(name string, resolver interface{}) error <span class="cov4" title="4">{
        return c.bind(resolver, name, true, true)
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package di

// Reset deletes all the existing bindings and empties the container.
func Reset(ctnr *Container) <span class="cov6" title="6">{
        ctnr.reset()
}</span>

// Provide binds an abstraction to concrete lazily in singleton mode.
// The concrete is resolved only when the abstraction is resolved for the first time.
// It takes a resolver function that returns the concrete, and its return type matches the abstraction (interface).
// The resolver function can have arguments of abstraction that have been declared in the Container already.
func Provide(ctnr *Container, resolver any) <span class="cov10" title="23">{
        err := ctnr.singletonLazy(resolver)
        if err != nil </span><span class="cov4" title="3">{
                panic(err)</span>
        }
}

// ProvideNamed binds a named abstraction to concrete lazily in singleton mode.
// The concrete is resolved only when the abstraction is resolved for the first time.
func ProvideNamed(ctnr *Container, name string, resolver any) <span class="cov4" title="4">{
        err := ctnr.namedSingletonLazy(name, resolver)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// NamedResolve takes abstraction and its name and fills it with the related concrete.
func NamedResolve[T any](ctnr *Container, name string) T <span class="cov2" title="2">{
        var obj T
        err := ctnr.namedResolve(&amp;obj, name)
        if err != nil </span><span class="cov1" title="1">{
                panic(err)</span>
        }

        <span class="cov1" title="1">return obj</span>
}

// Resolve takes an abstraction (reference of an interface type) and fills it with the related concrete.
func Resolve[T any](ctnr *Container) T <span class="cov6" title="8">{
        var obj T
        err := ctnr.resolve(&amp;obj)
        if err != nil </span><span class="cov5" title="5">{
                panic(err)</span>
        }

        <span class="cov4" title="3">return obj</span>
}

// Fill takes a struct and resolves the fields with the tag `container:"inject"`
func Fill(ctnr *Container, structure any) <span class="cov6" title="8">{
        err := ctnr.fill(structure)
        if err != nil </span><span class="cov5" title="5">{
                panic(err)</span>
        }
}

// Call takes a receiver function with one or more arguments of the abstractions (interfaces).
// It invokes the receiver function and passes the related concretes.
func Call(ctnr *Container, function any) error <span class="cov7" title="11">{
        return ctnr.call(function)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package env

import (
        "fmt"
)

type Environment string

func (e Environment) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

const (
        Production  Environment = "prd"
        Development Environment = "development"
        Staging     Environment = "stg"
)

func Parse(env string) (Environment, error) <span class="cov0" title="0">{
        switch env </span>{
        case "prd", "production":<span class="cov0" title="0">
                return Production, nil</span>
        case "stg", "staging":<span class="cov0" title="0">
                return Staging, nil</span>
        case "dev", "development":<span class="cov0" title="0">
                return Development, nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("undefined environment: %s", env)</span>
}

func MustParse(env string) Environment <span class="cov0" title="0">{
        parsed, err := Parse(env)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return parsed</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Package eon is a micro framework that aims to make the processe of bootstrapping a new application quick and easy.The Tino APP will provide you a set of two important tools:
// - A dependency injection container
// - A life cycle manager for your application
package eon

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
)

type Application struct {
        ctnr         *di.Container
        shutdownTime time.Duration
        lfcm         *lifeCycleManager
        logger       Logger
        ctx          context.Context
        serviceName  string
}

func (app *Application) BootStrap(modules ...Module) *Application <span class="cov4" title="2">{
        var bootOrder []HookFn
        for i := range modules </span><span class="cov10" title="5">{
                module := modules[i]
                hookFn := func() error </span><span class="cov10" title="5">{
                        app.logger.Info(fmt.Sprintf("[EON] Booting %s", module.name))
                        module.bootFn(
                                app.ctx,
                                app.ctnr,
                                app.lfcm,
                                Info{
                                        ServiceName: app.serviceName,
                                },
                        )
                        return nil
                }</span>
                <span class="cov10" title="5">bootOrder = append(bootOrder, hookFn)</span>
        }

        <span class="cov4" title="2">app.lfcm.OnBooting(HookOrders.APPEND, bootOrder...)

        return app</span>
}

func (app *Application) Start() error <span class="cov0" title="0">{
        if err := app.lfcm.start(); err != nil </span><span class="cov0" title="0">{
                app.logger.Error("[EON] Error starting the application", "err", err)
                return fmt.Errorf("starting the application: %w", err)
        }</span>

        <span class="cov0" title="0">signals := []os.Signal{
                syscall.SIGINT,
                syscall.SIGTERM,
                os.Interrupt,
                os.Kill,
        }

        ctx, stop := signal.NotifyContext(app.ctx, signals...)
        defer stop()
        // Waits for stop signal
        &lt;-ctx.Done()
        app.lfcm.shutdown()

        return nil</span>
}

func (app *Application) StartTest() error <span class="cov4" title="2">{
        if err := app.lfcm.start(); err != nil </span><span class="cov0" title="0">{
                app.logger.Error("[EON] Error starting the application", "err", err)
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (app *Application) Stop() error <span class="cov0" title="0">{
        if err := app.lfcm.stop(); err != nil </span><span class="cov0" title="0">{
                app.logger.Error("[EON] Failed to stop the application", "err", err)
                return fmt.Errorf("stopping the application: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package eon

import (
        "context"
        "log/slog"
        "os"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
)

type Logger interface {
        Info(msg string, fields ...any)
        Error(msg string, fields ...any)
        Warn(msg string, fields ...any)
        Debug(msg string, fields ...any)
}

type Options func(app *Application)

// New creates a new concrete of the eon Application.
// Eon APP is a micro framework that aims to make the processe of bootstrapping a new application quick and easy.
// The Tino APP will provide you a set of two important tools: a dependency injection container and a life cycle manager for your application
func New(serviceName string, opts ...Options) *Application <span class="cov10" title="6">{
        l := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))

        app := &amp;Application{
                serviceName:  serviceName,
                ctnr:         di.New(),
                ctx:          context.Background(),
                logger:       l,
                shutdownTime: 10 * time.Second,
                lfcm:         newLifeCycleManager(10*time.Second, l),
        }

        for _, opt := range opts </span><span class="cov9" title="5">{
                opt(app)
        }</span>

        <span class="cov10" title="6">return app</span>
}

func WithLogger(logger Logger) Options <span class="cov1" title="1">{
        return func(app *Application) </span><span class="cov1" title="1">{
                app.logger = logger
                app.lfcm = newLifeCycleManager(app.shutdownTime, logger)
        }</span>
}

func WithShutdownTime(shutdownTime time.Duration) Options <span class="cov6" title="3">{
        return func(app *Application) </span><span class="cov6" title="3">{
                app.shutdownTime = shutdownTime
                app.lfcm = newLifeCycleManager(shutdownTime, app.logger)
        }</span>
}

func WithIoC(ioc *di.Container) Options <span class="cov1" title="1">{
        return func(app *Application) </span><span class="cov1" title="1">{
                app.ctnr = ioc
        }</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package eon

// HookOrder HookStore
type HookOrder string

var HookOrders = struct {
        APPEND  HookOrder
        PREPEND HookOrder
}{
        APPEND:  "APPEND",
        PREPEND: "PREPEND",
}

type HookFn func() error

type hook string

var hooks = struct {
        BOOTING   hook
        BOOTED    hook
        READY     hook
        RUNNING   hook
        DISPOSING hook
        DISPOSED  hook
}{
        BOOTING:   "Booting",
        BOOTED:    "Booted",
        READY:     "Ready",
        RUNNING:   "Running",
        DISPOSING: "Disposing",
        DISPOSED:  "Disposed",
}

type hookStore struct {
        hooks map[hook][]HookFn
}

func newHookStore() *hookStore <span class="cov7" title="18">{
        return &amp;hookStore{
                hooks: map[hook][]HookFn{},
        }
}</span>

func (store *hookStore) get(lfc hook) []HookFn <span class="cov8" title="25">{
        return store.hooks[lfc]
}</span>

func (store *hookStore) append(lfc hook, fn ...HookFn) <span class="cov6" title="9">{
        store.hooks[lfc] = append(store.hooks[lfc], fn...)
}</span>

func (store *hookStore) prepend(lfc hook, fn ...HookFn) <span class="cov1" title="1">{
        store.hooks[lfc] = append(fn, store.hooks[lfc]...)
}</span>

func hooksChain(hooks ...HookFn) error <span class="cov9" title="31">{
        for _, fn := range hooks </span><span class="cov10" title="47">{
                err := fn()
                if err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>
        }
        <span class="cov8" title="27">return nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package eon

import (
        "errors"
        "fmt"
        "os"
        "strconv"
        "syscall"
        "time"
)

type appState string

var appStates = struct {
        IDLE     appState
        STARTING appState
        STARTED  appState
        STOPPING appState
        STOPPED  appState
}{
        IDLE:     "IDLE",
        STARTING: "STARTING",
        STARTED:  "STARTED",
        STOPPING: "STOPPING",
        STOPPED:  "STOPPED",
}

func newLifeCycleManager(shutdownTime time.Duration, logger Logger) *lifeCycleManager <span class="cov8" title="15">{
        return &amp;lifeCycleManager{
                state:         appStates.IDLE,
                hooks:         newHookStore(),
                logger:        logger,
                forceShutdown: false,
                shutdownTime:  shutdownTime,
        }
}</span>

type lifeCycleManager struct {
        state         appState
        hooks         *hookStore
        logger        Logger
        forceShutdown bool
        shutdownTime  time.Duration
}

func (lfcm *lifeCycleManager) status(newStatus appState) HookFn <span class="cov8" title="16">{
        return func() error </span><span class="cov8" title="14">{
                lfcm.logger.Info(fmt.Sprintf("[EON] Application %s", newStatus))
                lfcm.state = newStatus
                return nil
        }</span>
}

func (lfcm *lifeCycleManager) transition(lifeCycle hook) HookFn <span class="cov10" title="28">{
        return func() error </span><span class="cov9" title="23">{
                lfcm.logger.Info(fmt.Sprintf("[EON] Processing on%s", lifeCycle))
                if err := hooksChain(lfcm.hooks.get(lifeCycle)...); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("processing on%s: %w", lifeCycle, err)
                }</span>
                <span class="cov9" title="21">return nil</span>
        }
}

func (lfcm *lifeCycleManager) start() error <span class="cov6" title="7">{
        if lfcm.state != appStates.IDLE </span><span class="cov1" title="1">{
                lfcm.logger.Warn("[EON] The application has already started.")
                return errors.New("the application has already started")
        }</span>

        <span class="cov5" title="6">err := hooksChain(
                lfcm.status(appStates.STARTING),
                lfcm.transition(hooks.BOOTING),
                lfcm.transition(hooks.BOOTED),
                lfcm.transition(hooks.READY),
                lfcm.transition(hooks.RUNNING),
                lfcm.status(appStates.STARTED),
        )
        if err != nil </span><span class="cov1" title="1">{
                if stopErr := lfcm.stop(); stopErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("shutting down the application: %w", stopErr)
                }</span>

                <span class="cov1" title="1">return fmt.Errorf("transitioning the life cycles: %w", err)</span>
        }

        <span class="cov4" title="4">return nil</span>
}

func (lfcm *lifeCycleManager) stop() error <span class="cov3" title="3">{
        if lfcm.state == appStates.IDLE </span><span class="cov1" title="1">{
                lfcm.logger.Warn("[EON] The application is not running.")
                return errors.New("the application is not running")
        }</span>

        <span class="cov2" title="2">err := hooksChain(
                lfcm.status(appStates.STOPPING),
                lfcm.transition(hooks.DISPOSING),
                lfcm.transition(hooks.DISPOSED),
                lfcm.status(appStates.STOPPED),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("shutting down the application: %w", err)
        }</span>

        <span class="cov2" title="2">lfcm.logger.Info("[EON] Application exited with success")
        return nil</span>
}

func (lfcm *lifeCycleManager) OnBooting(order HookOrder, fn ...HookFn) <span class="cov5" title="5">{
        lfcm.on(hooks.BOOTING, order, fn...)
}</span>

func (lfcm *lifeCycleManager) OnBooted(order HookOrder, fn ...HookFn) <span class="cov1" title="1">{
        lfcm.on(hooks.BOOTED, order, fn...)
}</span>

func (lfcm *lifeCycleManager) OnReady(order HookOrder, fn ...HookFn) <span class="cov0" title="0">{
        lfcm.on(hooks.READY, order, fn...)
}</span>

func (lfcm *lifeCycleManager) OnRunning(order HookOrder, fn ...HookFn) <span class="cov0" title="0">{
        lfcm.on(hooks.RUNNING, order, fn...)
}</span>

func (lfcm *lifeCycleManager) OnDisposing(order HookOrder, fn ...HookFn) <span class="cov1" title="1">{
        lfcm.on(hooks.DISPOSING, order, fn...)
}</span>

func (lfcm *lifeCycleManager) OnDisposed(order HookOrder, fn ...HookFn) <span class="cov0" title="0">{
        lfcm.on(hooks.DISPOSED, order, fn...)
}</span>

func (lfcm *lifeCycleManager) on(lfc hook, order HookOrder, fn ...HookFn) <span class="cov6" title="7">{
        if order == HookOrders.APPEND </span><span class="cov6" title="7">{
                lfcm.hooks.append(lfc, fn...)
        }</span> else<span class="cov0" title="0"> {
                lfcm.hooks.prepend(lfc, fn...)
        }</span>
}

func (lfcm *lifeCycleManager) shutdown() <span class="cov0" title="0">{
        time.AfterFunc(lfcm.shutdownTime, func() </span><span class="cov0" title="0">{
                lfcm.logger.Warn("[EON] OK, my patience is over #ragequit")
                os.Exit(1)
        }</span>)

        <span class="cov0" title="0">if lfcm.state == appStates.STOPPING || lfcm.state == appStates.STOPPED </span><span class="cov0" title="0">{
                if lfcm.forceShutdown </span><span class="cov0" title="0">{
                        lfcm.terminate(syscall.SIGKILL)
                        return
                }</span>

                <span class="cov0" title="0">lfcm.logger.Warn("[EON] The application is yet to finishing the shutdown process. Repeat the command to force exit")
                lfcm.forceShutdown = true
                return</span>
        }

        <span class="cov0" title="0">if err := lfcm.stop(); err != nil </span><span class="cov0" title="0">{
                lfcm.logger.Error("[EON] Failed to stop the application", "err", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">os.Exit(0)</span>
}

func (lfcm *lifeCycleManager) terminate(signal syscall.Signal) <span class="cov0" title="0">{
        // first arg is the process id
        arg0 := os.Args[0]
        val0, _ := strconv.ParseInt(arg0, 10, 32)
        pid := int(val0)

        err := syscall.Kill(pid, signal)

        if err != nil </span><span class="cov0" title="0">{
                lfcm.logger.Error("[EON] Failed to kill the process", "err", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package eon

import (
        "context"

        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
)

type (
        // LifeCycleManager Both the boot and stopping processes are defined as a sequence of lifecycle events.
        // These events exist in order to make these processes explicit and allow the modules to hook into them and properly integrate them into the application execution.
        LifeCycleManager interface {
                // OnBooted When this event is dispatched it's a message to let the modules know that all the modules were already invoked and had already hooked into the other lifecycle events.
                // This is a good place to register error handlers because every module has already registered its routes when they were invoked.
                // Use this event to do anything you might need after all the module constructors are done running.
                OnBooted(order HookOrder, fn ...HookFn)
                // OnReady This lifecycle event happens after all the listeners for the booted event were run.
                // This is the proper place to actually start things, like starting the server or make queue consumers start listening to messages.
                OnReady(order HookOrder, fn ...HookFn)
                // OnRunning After everything from the ready event is done, the app is now actually running.
                // A good usage for this lifecycle event is to know if the app is already prepared to be accessed during the setup of an automated test or offer info about the process in the console.
                OnRunning(order HookOrder, fn ...HookFn)
                // OnDisposing It's during this lifecycle event that the cleanup functions returned by the modules will be run.
                // To make the cleanup process consistent, the cleanup functions are run in the inverse order their modules were passed to the bootstrap function. So if your app uses `bootstrap(database, server)`, during the disposing process the cleanup function of the server module will be called first and then the database one.
                // As an example, this is where the server is stopped and the database connections are closed.
                // It`s intended to be used to revert everything initialized during Booting lifecycle event.
                OnDisposing(order HookOrder, fn ...HookFn)
                // OnDisposed By the time Disposed event is dispatched, we expect that everything that keeps the process open is already finished, leaving it in a safe state to be terminated.
                // You could use this event to clean temporary files, for instance.
                OnDisposed(order HookOrder, fn ...HookFn)
        }

        Info struct {
                ServiceName string
        }

        BootFn func(ctx context.Context, c *di.Container, lc LifeCycleManager, info Info)

        // Module An Eon module is an encapsulated piece of code that is responsible for booting a specific part of the application.
        // It's expected to be used to separate the application in different parts, like the server, database, different bounded contexts, etc.
        // The function that is passed to the module is expected to receive the dependency injection container, the lifecycle manager and the application info.
        Module struct {
                name   string
                bootFn BootFn
        }
)

// NewModule creates an Eon module.
func NewModule(name string, bootFn BootFn) Module <span class="cov10" title="3">{
        return Module{
                name:   name,
                bootFn: bootFn,
        }
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">package except

import (
        "fmt"
        "net/http"
)

// HTTPError represents an error that occurred while handling a request.
type HTTPError struct {
        Code     int         `json:"-"`
        Message  interface{} `json:"message"`
        Internal error       `json:"-"`
}

// NewHTTPError creates a new HTTPError instance.
func NewHTTPError(code int, message ...interface{}) *HTTPError <span class="cov10" title="27">{
        he := &amp;HTTPError{Code: code, Message: http.StatusText(code)}
        if len(message) &gt; 0 </span><span class="cov10" title="27">{
                he.Message = message[0]
        }</span>
        <span class="cov10" title="27">return he</span>
}

// Error makes it compatible with `error` interface.
func (he *HTTPError) Error() string <span class="cov8" title="16">{
        if he.Internal == nil </span><span class="cov8" title="16">{
                return fmt.Sprintf("%v", he.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%v: internal=%v", he.Message, he.Internal)</span>
}

// SetInternal sets error to HTTPError.Internal
func (he *HTTPError) SetInternal(err error) *HTTPError <span class="cov1" title="1">{
        he.Internal = err
        return he
}</span>

// WithInternal returns clone of HTTPError with err set to HTTPError.Internal field
func (he *HTTPError) WithInternal(err error) *HTTPError <span class="cov0" title="0">{
        return &amp;HTTPError{
                Code:     he.Code,
                Message:  he.Message,
                Internal: err,
        }
}</span>

// Unwrap satisfies the Go 1.13 error wrapper interface.
func (he *HTTPError) Unwrap() error <span class="cov0" title="0">{
        return he.Internal
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package except

import "net/http"

func NotFoundError(message ...interface{}) *HTTPError <span class="cov10" title="12">{
        return NewHTTPError(http.StatusNotFound, message...)
}</span>

func BadRequestError(message ...interface{}) *HTTPError <span class="cov4" title="3">{
        return NewHTTPError(http.StatusBadRequest, message...)
}</span>

func UnprocessableEntityError(message ...interface{}) *HTTPError <span class="cov8" title="8">{
        return NewHTTPError(http.StatusUnprocessableEntity, message...)
}</span>

func UnauthorizedError(message ...interface{}) *HTTPError <span class="cov0" title="0">{
        return NewHTTPError(http.StatusUnauthorized, message...)
}</span>

func ForbiddenError(message ...interface{}) *HTTPError <span class="cov0" title="0">{
        return NewHTTPError(http.StatusForbidden, message...)
}</span>

func ConflictError(message ...interface{}) *HTTPError <span class="cov4" title="3">{
        return NewHTTPError(http.StatusConflict, message...)
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package logger

import (
        "log/slog"
        "os"
        "strings"
        "time"

        "github.com/lmittmann/tint"
)

func New(handler slog.Handler) *slog.Logger <span class="cov0" title="0">{
        return slog.New(handler)
}</span>

func NewProduction(logLevel ...string) *slog.Logger <span class="cov0" title="0">{
        return New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level:       getLogLevel(logLevel...),
                ReplaceAttr: attrMapper,
                AddSource:   true,
        }))
}</span>

func NewDevelopment(logLevel ...string) *slog.Logger <span class="cov0" title="0">{
        return New(tint.NewHandler(os.Stdout, &amp;tint.Options{
                Level:       getLogLevel(logLevel...),
                ReplaceAttr: attrMapper,
                TimeFormat:  time.DateTime,
        }))
}</span>

func getLogLevel(logLevel ...string) slog.Level <span class="cov0" title="0">{
        if len(logLevel) &gt; 0 </span><span class="cov0" title="0">{
                return LogLevelMap(logLevel[0])
        }</span>
        <span class="cov0" title="0">return slog.LevelInfo</span>
}

func attrMapper(_ []string, a slog.Attr) slog.Attr <span class="cov0" title="0">{
        if a.Key == "level" </span><span class="cov0" title="0">{
                return slog.Attr{Key: "severity", Value: a.Value}
        }</span>

        <span class="cov0" title="0">if a.Key == "msg" </span><span class="cov0" title="0">{
                return slog.Attr{Key: "message", Value: a.Value}
        }</span>

        <span class="cov0" title="0">if a.Key == "time" </span><span class="cov0" title="0">{
                return slog.Attr{Key: "timestamp", Value: a.Value}
        }</span>

        <span class="cov0" title="0">return a</span>
}

func LogLevelMap(level string) slog.Level <span class="cov0" title="0">{
        switch strings.ToUpper(level) </span>{
        case "DEBUG":<span class="cov0" title="0">
                return slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                return slog.LevelInfo</span>
        case "WARN":<span class="cov0" title="0">
                return slog.LevelWarn</span>
        case "ERROR":<span class="cov0" title="0">
                return slog.LevelError</span>
        default:<span class="cov0" title="0">
                return slog.LevelInfo</span>
        }
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package validator

import (
        "errors"
        "fmt"
        "strings"

        "github.com/go-playground/validator/v10"
)

type Validator struct {
        validate *validator.Validate
}

func New() *Validator <span class="cov0" title="0">{
        return &amp;Validator{validate: validator.New()}
}</span>

func (v *Validator) Validate(data any) error <span class="cov0" title="0">{
        errs := v.validate.Struct(data)
        if errs != nil </span><span class="cov0" title="0">{
                var errMsgs = make([]string, len(func() validator.ValidationErrors </span><span class="cov0" title="0">{
                        var target validator.ValidationErrors
                        _ = errors.As(errs, &amp;target)
                        return target
                }</span>()))
                <span class="cov0" title="0">for i, err := range func() validator.ValidationErrors </span><span class="cov0" title="0">{
                        var target validator.ValidationErrors
                        _ = errors.As(errs, &amp;target)
                        return target
                }</span>() <span class="cov0" title="0">{
                        errMsgs[i] = fmt.Sprintf(
                                "[%s]: '%v' | Needs to implement '%s'",
                                err.Field(),
                                err.Value(),
                                err.Tag(),
                        )
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("validation errors: %v", strings.Join(errMsgs, " and "))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package email

import (
        "context"
        "fmt"

        "github.com/go-resty/resty/v2"
)

type MailTrapEmailProvider struct {
        client *resty.Client
        apiKey string
}
type mailTrapEmail struct {
        Email string `json:"email"`
        Name  string `json:"name"`
}

type mailTrapBody struct {
        From    mailTrapEmail
        To      []mailTrapEmail
        Subject string
        Html    string
}

func NewMailTrapEmailProvider(apiKey string) *MailTrapEmailProvider <span class="cov0" title="0">{
        return &amp;MailTrapEmailProvider{client: resty.New(), apiKey: apiKey}
}</span>

func (p *MailTrapEmailProvider) Send(ctx context.Context, email Email) error <span class="cov0" title="0">{
        var to []mailTrapEmail
        for _, e := range email.To </span><span class="cov0" title="0">{
                to = append(to, mailTrapEmail{Email: e, Name: "test"})
        }</span>

        <span class="cov0" title="0">req, err := p.client.R().
                SetContext(ctx).
                SetHeader("Api-Token", p.apiKey).
                SetBody(&amp;mailTrapBody{
                        From: mailTrapEmail{
                                Email: email.From,
                                Name:  "Nossas Despesas",
                        },
                        To:      to,
                        Subject: email.Subject,
                        Html:    email.Html,
                }).Post("https://sandbox.api.mailtrap.io/api/send/2649128")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send email: %w", err)
        }</span>

        <span class="cov0" title="0">if req.StatusCode() != 200 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send email: %s", req.Body())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package email

import (
        "context"
        "fmt"

        "github.com/resend/resend-go/v2"
)

type ResendEmailProvider struct {
        client *resend.Client
}

func NewResendEmailProvider(apiKey string) *ResendEmailProvider <span class="cov0" title="0">{
        return &amp;ResendEmailProvider{client: resend.NewClient(apiKey)}
}</span>

func (p *ResendEmailProvider) Send(ctx context.Context, email Email) error <span class="cov0" title="0">{
        params := &amp;resend.SendEmailRequest{
                From:    email.From,
                To:      email.To,
                Html:    email.Html,
                Subject: email.Subject,
                Cc:      email.Cc,
                ReplyTo: email.ReplyTo,
        }

        if _, err := p.client.Emails.SendWithContext(ctx, params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("resend.Emails.SendWithContext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">// TODO: move this to auth package
package jwt

import (
        "fmt"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/golang-jwt/jwt/v5"
)

type Provider struct {
        secret             string
        tokenExpire        time.Duration
        refreshTokenExpire time.Duration
}

func NewJWTProvider(secret string) *Provider <span class="cov0" title="0">{
        return &amp;Provider{
                secret:             secret,
                tokenExpire:        time.Hour * 5,
                refreshTokenExpire: time.Hour * 24 * 30,
        }
}</span>

func (p *Provider) GenerateUserTokens(user user.User) (string, string, error) <span class="cov0" title="0">{
        tokenClaims := jwt.MapClaims{
                "user_id": user.ID.Value,
                "group_id": func() *int </span><span class="cov0" title="0">{
                        if user.GroupID == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return &amp;user.GroupID.Value</span>
                }(),
                "email": user.Email,
                "exp":   jwt.NewNumericDate(time.Now().Add(p.tokenExpire)),
                "iat":   jwt.NewNumericDate(time.Now()),
        }

        <span class="cov0" title="0">refreshTokenClaims := jwt.MapClaims{
                "user_id": user.ID.Value,
                "exp":     jwt.NewNumericDate(time.Now().Add(p.refreshTokenExpire)),
                "iat":     jwt.NewNumericDate(time.Now()),
        }

        token, err := jwt.NewWithClaims(jwt.SigningMethodHS256, tokenClaims).SignedString([]byte(p.secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("new jwt: %w", err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshTokenClaims).SignedString([]byte(p.secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("new refresh jwt: %w", err)
        }</span>

        <span class="cov0" title="0">return token, refreshToken, nil</span>
}

func (p *Provider) ParseToken(stringToken string) (*auth.Token, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(stringToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(p.secret), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse jwt: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jwt")
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jwt claims")
        }</span>

        <span class="cov0" title="0">userID, ok := claims["user_id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jwt claims")
        }</span>

        <span class="cov0" title="0">var groupID *int
        groupNumber, ok := claims["group_id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                groupID = nil
        }</span> else<span class="cov0" title="0"> {
                id := int(groupNumber)
                groupID = &amp;id
        }</span>

        <span class="cov0" title="0">email, ok := claims["email"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jwt claims")
        }</span>

        <span class="cov0" title="0">return &amp;auth.Token{
                Raw:     token.Raw,
                IsValid: token.Valid,
                Claims: auth.Claims{
                        UserID:  int(userID),
                        GroupID: groupID,
                        Email:   email,
                },
        }, nil</span>
}

func (p *Provider) ParseRefreshToken(stringToken string) (*auth.Token, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(stringToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(p.secret), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse jwt: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jwt")
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jwt claims")
        }</span>

        <span class="cov0" title="0">userID, ok := claims["user_id"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid jwt claims")
        }</span>

        <span class="cov0" title="0">return &amp;auth.Token{
                Raw:     token.Raw,
                IsValid: token.Valid,
                Claims: auth.Claims{
                        UserID: int(userID),
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package pubsub

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/ThreeDotsLabs/watermill"
        pubsubSql "github.com/ThreeDotsLabs/watermill-sql/v3/pkg/sql"
        "github.com/ThreeDotsLabs/watermill/message"
        "github.com/google/uuid"
)

type Publisher interface {
        Publish(ctx context.Context, topic string, event any) error
        Close() error
}

// SQL Publisher

type SqlPublisher struct {
        publisher *pubsubSql.Publisher
}

func NewSqlPublisher(db *db.Client) (Publisher, error) <span class="cov0" title="0">{
        logger := watermill.NewSlogLogger(nil)
        publisher, err := pubsubSql.NewPublisher(
                db.Conn(),
                pubsubSql.PublisherConfig{
                        SchemaAdapter:        pubsubSql.DefaultPostgreSQLSchema{},
                        AutoInitializeSchema: true,
                },
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pubsubSql.NewPublisher: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SqlPublisher{publisher: publisher}, nil</span>
}

func (p SqlPublisher) Publish(ctx context.Context, topic string, event any) error <span class="cov0" title="0">{
        messageData, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling event data: %w", err)
        }</span>

        <span class="cov0" title="0">if err := p.publisher.Publish(topic, message.NewMessage(uuid.NewString(), messageData)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error publishing event: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p SqlPublisher) Close() error <span class="cov0" title="0">{
        return p.publisher.Close()
}</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">package pubsub

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/ThreeDotsLabs/watermill"
        pubsubSql "github.com/ThreeDotsLabs/watermill-sql/v3/pkg/sql"
        "github.com/ThreeDotsLabs/watermill/message"
)

type Subscriber interface {
        Subscribe(ctx context.Context, topic string) (&lt;-chan *Message, error)
        Close() error
}

// SQL Subscriber

type SqlSubscriber struct {
        subscriber *pubsubSql.Subscriber
}

type Message = message.Message

func NewSqlSubscriber(db *db.Client) (Subscriber, error) <span class="cov0" title="0">{
        logger := watermill.NewSlogLogger(nil)

        subscriber, err := pubsubSql.NewSubscriber(db.Conn(), pubsubSql.SubscriberConfig{
                SchemaAdapter:    pubsubSql.DefaultPostgreSQLSchema{},
                OffsetsAdapter:   pubsubSql.DefaultPostgreSQLOffsetsAdapter{},
                InitializeSchema: true,
        }, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pubsubSql.NewSubscriber: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SqlSubscriber{subscriber: subscriber}, nil</span>
}

func (s SqlSubscriber) Subscribe(ctx context.Context, topic string) (&lt;-chan *Message, error) <span class="cov0" title="0">{
        return s.subscriber.Subscribe(ctx, topic)
}</span>

func (s SqlSubscriber) Close() error <span class="cov0" title="0">{
        return s.subscriber.Close()
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package middleware

import (
        "strings"

        "github.com/Beigelman/nossas-despesas/internal/pkg/except"
        "github.com/Beigelman/nossas-despesas/internal/shared/service"
        "github.com/gofiber/fiber/v2"
)

type AuthMiddleware func(ctx *fiber.Ctx) error

func NewAuthMiddleware(tokenProvider service.TokenProvider) AuthMiddleware <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                authorization := ctx.GetReqHeaders()["Authorization"]
                if len(authorization) == 0 </span><span class="cov0" title="0">{
                        return except.UnauthorizedError("invalid jwt format")
                }</span>

                <span class="cov0" title="0">bearerToken := strings.Split(authorization[0], " ")

                if len(bearerToken) != 2 </span><span class="cov0" title="0">{
                        return except.UnauthorizedError("invalid jwt format")
                }</span>

                <span class="cov0" title="0">prefix := bearerToken[0]
                token := bearerToken[1]

                if token == "" || prefix != "Bearer" </span><span class="cov0" title="0">{
                        return except.UnauthorizedError("invalid jwt format")
                }</span>

                <span class="cov0" title="0">tokenInfo, err := tokenProvider.ParseToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        return except.UnauthorizedError("invalid jwt").SetInternal(err)
                }</span>

                <span class="cov0" title="0">ctx.Locals("user_id", tokenInfo.Claims.UserID)
                ctx.Locals("email", tokenInfo.Claims.Email)
                if tokenInfo.Claims.GroupID != nil </span><span class="cov0" title="0">{
                        ctx.Locals("group_id", *tokenInfo.Claims.GroupID)
                }</span>

                <span class="cov0" title="0">return ctx.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package middleware

import (
        "fmt"
        "log/slog"
        "regexp"

        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/gofiber/fiber/v2"
)

func LogRequest(environment env.Environment, serviceName string) func(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                if environment == "test" </span><span class="cov0" title="0">{
                        return ctx.Next()
                }</span>

                <span class="cov0" title="0">requestId, ok := ctx.Locals("requestid").(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("request_id not found in context")</span>
                }

                <span class="cov0" title="0">if environment == "development" </span><span class="cov0" title="0">{
                        slog.Info(fmt.Sprintf("Calling %s %s", ctx.Method(), ctx.Path()), slog.String("request_id", requestId))
                        return ctx.Next()
                }</span>

                <span class="cov0" title="0">params := extractRequestParams(ctx)
                slog.Info(fmt.Sprintf("Calling %s %s", ctx.Method(), ctx.Path()),
                        slog.String("request_id", requestId),
                        slog.Group("http_request",
                                slog.String("ip", ctx.IP()),
                                slog.String("service", serviceName),
                                slog.String("method", ctx.Method()),
                                slog.Group("headers", params.headerParams...),
                                slog.Group("query", params.queryParams...),
                                slog.Group("body", params.bodyParams...),
                        ))
                return ctx.Next()</span>
        }
}

var secretRegex = regexp.MustCompile(`(?i)password|token|secret|key|authorization|session|jwt|auth`)

type requestParams struct {
        bodyParams   []any
        queryParams  []any
        headerParams []any
}

func extractRequestParams(ctx *fiber.Ctx) requestParams <span class="cov0" title="0">{
        queryParams := func() []any </span><span class="cov0" title="0">{
                var query []any
                for k, v := range ctx.Queries() </span><span class="cov0" title="0">{
                        query = append(query, slog.String(k, v))
                }</span>
                <span class="cov0" title="0">return query</span>
        }()

        <span class="cov0" title="0">headerParams := func() []any </span><span class="cov0" title="0">{
                var headers []any
                for k, v := range ctx.GetReqHeaders() </span><span class="cov0" title="0">{
                        value := v[0]
                        if secretRegex.MatchString(k) </span><span class="cov0" title="0">{
                                value = "***"
                        }</span>
                        <span class="cov0" title="0">headers = append(headers, slog.String(k, value))</span>
                }
                <span class="cov0" title="0">return headers</span>
        }()

        <span class="cov0" title="0">bodyParams := func() []any </span><span class="cov0" title="0">{
                var body map[string]any
                if err := ctx.BodyParser(&amp;body); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">var bodyParams []any
                for k, v := range body </span><span class="cov0" title="0">{
                        value := fmt.Sprintf("%s", v)
                        if secretRegex.MatchString(k) </span><span class="cov0" title="0">{
                                value = "***"
                        }</span>
                        <span class="cov0" title="0">bodyParams = append(bodyParams, slog.String(k, value))</span>
                }

                <span class="cov0" title="0">return bodyParams</span>
        }()

        <span class="cov0" title="0">return requestParams{
                bodyParams:   bodyParams,
                queryParams:  queryParams,
                headerParams: headerParams,
        }</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package shared

import (
        "context"
        "log/slog"

        "github.com/Beigelman/nossas-despesas/internal/pkg/config"
        "github.com/Beigelman/nossas-despesas/internal/pkg/di"
        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/email"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/jwt"
        "github.com/Beigelman/nossas-despesas/internal/shared/infra/pubsub"
        "github.com/Beigelman/nossas-despesas/internal/shared/service"
)

var Module = eon.NewModule("Shared Clients", func(ctx context.Context, c *di.Container, lc eon.LifeCycleManager, info eon.Info) <span class="cov0" title="0">{
        di.Provide(c, func(cfg *config.Config) service.TokenProvider </span><span class="cov0" title="0">{
                return jwt.NewJWTProvider(cfg.JWTSecret)
        }</span>)
        <span class="cov0" title="0">di.Provide(c, func(cfg *config.Config) service.EmailProvider </span><span class="cov0" title="0">{
                if cfg.Env == env.Development </span><span class="cov0" title="0">{
                        return email.NewMailTrapEmailProvider(cfg.Mail.ApiKey)
                }</span>
                <span class="cov0" title="0">return email.NewResendEmailProvider(cfg.Mail.ApiKey)</span>
        })
        <span class="cov0" title="0">di.Provide(c, pubsub.NewSqlPublisher)
        di.Provide(c, pubsub.NewSqlSubscriber)

        lc.OnDisposing(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{
                if publisher := di.Resolve[pubsub.Publisher](c); publisher != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(ctx, "Closing publisher connection")
                        return publisher.Close()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">lc.OnDisposing(eon.HookOrders.APPEND, func() error </span><span class="cov0" title="0">{
                if subscriber := di.Resolve[pubsub.Subscriber](c); subscriber != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(ctx, "Closing subscriber connection")
                        return subscriber.Close()
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
})
</pre>
		
		<pre class="file" id="file130" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        auth "github.com/Beigelman/nossas-despesas/internal/modules/auth"

        mock "github.com/stretchr/testify/mock"
)

// MockauthRepository is an autogenerated mock type for the Repository type
type MockauthRepository struct {
        mock.Mock
}

type MockauthRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockauthRepository) EXPECT() *MockauthRepository_Expecter <span class="cov10" title="20">{
        return &amp;MockauthRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetByEmail provides a mock function with given fields: ctx, email, authType
func (_m *MockauthRepository) GetByEmail(ctx context.Context, email string, authType auth.Type) (*auth.Auth, error) <span class="cov8" title="14">{
        ret := _m.Called(ctx, email, authType)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByEmail")</span>
        }

        <span class="cov8" title="14">var r0 *auth.Auth
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, auth.Type) (*auth.Auth, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, authType)
        }</span>
        <span class="cov8" title="14">if rf, ok := ret.Get(0).(func(context.Context, string, auth.Type) *auth.Auth); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, authType)
        }</span> else<span class="cov8" title="14"> {
                if ret.Get(0) != nil </span><span class="cov8" title="14">{
                        r0 = ret.Get(0).(*auth.Auth)
                }</span>
        }

        <span class="cov8" title="14">if rf, ok := ret.Get(1).(func(context.Context, string, auth.Type) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, authType)
        }</span> else<span class="cov8" title="14"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="14">return r0, r1</span>
}

// MockauthRepository_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockauthRepository_GetByEmail_Call struct {
        *mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - authType auth.Type
func (_e *MockauthRepository_Expecter) GetByEmail(ctx interface{}, email interface{}, authType interface{}) *MockauthRepository_GetByEmail_Call <span class="cov8" title="14">{
        return &amp;MockauthRepository_GetByEmail_Call{Call: _e.mock.On("GetByEmail", ctx, email, authType)}
}</span>

func (_c *MockauthRepository_GetByEmail_Call) Run(run func(ctx context.Context, email string, authType auth.Type)) *MockauthRepository_GetByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(auth.Type))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockauthRepository_GetByEmail_Call) Return(_a0 *auth.Auth, _a1 error) *MockauthRepository_GetByEmail_Call <span class="cov8" title="14">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockauthRepository_GetByEmail_Call) RunAndReturn(run func(context.Context, string, auth.Type) (*auth.Auth, error)) *MockauthRepository_GetByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockauthRepository) GetByID(ctx context.Context, id auth.ID) (*auth.Auth, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *auth.Auth
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, auth.ID) (*auth.Auth, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, auth.ID) *auth.Auth); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*auth.Auth)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, auth.ID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockauthRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockauthRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id auth.ID
func (_e *MockauthRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockauthRepository_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockauthRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockauthRepository_GetByID_Call) Run(run func(ctx context.Context, id auth.ID)) *MockauthRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(auth.ID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockauthRepository_GetByID_Call) Return(_a0 *auth.Auth, _a1 error) *MockauthRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockauthRepository_GetByID_Call) RunAndReturn(run func(context.Context, auth.ID) (*auth.Auth, error)) *MockauthRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockauthRepository) GetNextID() auth.ID <span class="cov4" title="3">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov4" title="3">var r0 auth.ID
        if rf, ok := ret.Get(0).(func() auth.ID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Get(0).(auth.ID)
        }</span>

        <span class="cov4" title="3">return r0</span>
}

// MockauthRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockauthRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockauthRepository_Expecter) GetNextID() *MockauthRepository_GetNextID_Call <span class="cov4" title="3">{
        return &amp;MockauthRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockauthRepository_GetNextID_Call) Run(run func()) *MockauthRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockauthRepository_GetNextID_Call) Return(_a0 auth.ID) *MockauthRepository_GetNextID_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockauthRepository_GetNextID_Call) RunAndReturn(run func() auth.ID) *MockauthRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockauthRepository) Store(ctx context.Context, entity *auth.Auth) error <span class="cov4" title="3">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov4" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *auth.Auth) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="3">return r0</span>
}

// MockauthRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockauthRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *auth.Auth
func (_e *MockauthRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockauthRepository_Store_Call <span class="cov4" title="3">{
        return &amp;MockauthRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockauthRepository_Store_Call) Run(run func(ctx context.Context, entity *auth.Auth)) *MockauthRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*auth.Auth))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockauthRepository_Store_Call) Return(_a0 error) *MockauthRepository_Store_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockauthRepository_Store_Call) RunAndReturn(run func(context.Context, *auth.Auth) error) *MockauthRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockauthRepository creates a new instance of MockauthRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockauthRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockauthRepository <span class="cov3" title="2">{
        mock := &amp;MockauthRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov3" title="2">{ mock.AssertExpectations(t) }</span>)

        <span class="cov3" title="2">return mock</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        category "github.com/Beigelman/nossas-despesas/internal/modules/category"

        mock "github.com/stretchr/testify/mock"
)

// MockcategoryGroupRepository is an autogenerated mock type for the GroupRepository type
type MockcategoryGroupRepository struct {
        mock.Mock
}

type MockcategoryGroupRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockcategoryGroupRepository) EXPECT() *MockcategoryGroupRepository_Expecter <span class="cov10" title="8">{
        return &amp;MockcategoryGroupRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockcategoryGroupRepository) GetByID(ctx context.Context, id category.GroupID) (*category.Group, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *category.Group
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, category.GroupID) (*category.Group, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, category.GroupID) *category.Group); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*category.Group)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, category.GroupID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockcategoryGroupRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockcategoryGroupRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id category.GroupID
func (_e *MockcategoryGroupRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockcategoryGroupRepository_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockcategoryGroupRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockcategoryGroupRepository_GetByID_Call) Run(run func(ctx context.Context, id category.GroupID)) *MockcategoryGroupRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(category.GroupID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryGroupRepository_GetByID_Call) Return(_a0 *category.Group, _a1 error) *MockcategoryGroupRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockcategoryGroupRepository_GetByID_Call) RunAndReturn(run func(context.Context, category.GroupID) (*category.Group, error)) *MockcategoryGroupRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByName provides a mock function with given fields: ctx, name
func (_m *MockcategoryGroupRepository) GetByName(ctx context.Context, name string) (*category.Group, error) <span class="cov7" title="4">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByName")</span>
        }

        <span class="cov7" title="4">var r0 *category.Group
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*category.Group, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov7" title="4">if rf, ok := ret.Get(0).(func(context.Context, string) *category.Group); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov7" title="4"> {
                if ret.Get(0) != nil </span><span class="cov7" title="4">{
                        r0 = ret.Get(0).(*category.Group)
                }</span>
        }

        <span class="cov7" title="4">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov7" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="4">return r0, r1</span>
}

// MockcategoryGroupRepository_GetByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByName'
type MockcategoryGroupRepository_GetByName_Call struct {
        *mock.Call
}

// GetByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockcategoryGroupRepository_Expecter) GetByName(ctx interface{}, name interface{}) *MockcategoryGroupRepository_GetByName_Call <span class="cov7" title="4">{
        return &amp;MockcategoryGroupRepository_GetByName_Call{Call: _e.mock.On("GetByName", ctx, name)}
}</span>

func (_c *MockcategoryGroupRepository_GetByName_Call) Run(run func(ctx context.Context, name string)) *MockcategoryGroupRepository_GetByName_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryGroupRepository_GetByName_Call) Return(_a0 *category.Group, _a1 error) *MockcategoryGroupRepository_GetByName_Call <span class="cov7" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockcategoryGroupRepository_GetByName_Call) RunAndReturn(run func(context.Context, string) (*category.Group, error)) *MockcategoryGroupRepository_GetByName_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockcategoryGroupRepository) GetNextID() category.GroupID <span class="cov4" title="2">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov4" title="2">var r0 category.GroupID
        if rf, ok := ret.Get(0).(func() category.GroupID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov4" title="2"> {
                r0 = ret.Get(0).(category.GroupID)
        }</span>

        <span class="cov4" title="2">return r0</span>
}

// MockcategoryGroupRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockcategoryGroupRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockcategoryGroupRepository_Expecter) GetNextID() *MockcategoryGroupRepository_GetNextID_Call <span class="cov4" title="2">{
        return &amp;MockcategoryGroupRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockcategoryGroupRepository_GetNextID_Call) Run(run func()) *MockcategoryGroupRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryGroupRepository_GetNextID_Call) Return(_a0 category.GroupID) *MockcategoryGroupRepository_GetNextID_Call <span class="cov4" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockcategoryGroupRepository_GetNextID_Call) RunAndReturn(run func() category.GroupID) *MockcategoryGroupRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockcategoryGroupRepository) Store(ctx context.Context, entity *category.Group) error <span class="cov4" title="2">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov4" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *category.Group) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov4" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="2">return r0</span>
}

// MockcategoryGroupRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockcategoryGroupRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *category.Group
func (_e *MockcategoryGroupRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockcategoryGroupRepository_Store_Call <span class="cov4" title="2">{
        return &amp;MockcategoryGroupRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockcategoryGroupRepository_Store_Call) Run(run func(ctx context.Context, entity *category.Group)) *MockcategoryGroupRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*category.Group))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryGroupRepository_Store_Call) Return(_a0 error) *MockcategoryGroupRepository_Store_Call <span class="cov4" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockcategoryGroupRepository_Store_Call) RunAndReturn(run func(context.Context, *category.Group) error) *MockcategoryGroupRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockcategoryGroupRepository creates a new instance of MockcategoryGroupRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockcategoryGroupRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockcategoryGroupRepository <span class="cov1" title="1">{
        mock := &amp;MockcategoryGroupRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov1" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov1" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        category "github.com/Beigelman/nossas-despesas/internal/modules/category"

        mock "github.com/stretchr/testify/mock"
)

// MockcategoryRepository is an autogenerated mock type for the Repository type
type MockcategoryRepository struct {
        mock.Mock
}

type MockcategoryRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockcategoryRepository) EXPECT() *MockcategoryRepository_Expecter <span class="cov10" title="19">{
        return &amp;MockcategoryRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockcategoryRepository) GetByID(ctx context.Context, id category.ID) (*category.Category, error) <span class="cov8" title="11">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov8" title="11">var r0 *category.Category
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, category.ID) (*category.Category, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov8" title="11">if rf, ok := ret.Get(0).(func(context.Context, category.ID) *category.Category); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="11"> {
                if ret.Get(0) != nil </span><span class="cov8" title="11">{
                        r0 = ret.Get(0).(*category.Category)
                }</span>
        }

        <span class="cov8" title="11">if rf, ok := ret.Get(1).(func(context.Context, category.ID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="11"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="11">return r0, r1</span>
}

// MockcategoryRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockcategoryRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id category.ID
func (_e *MockcategoryRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockcategoryRepository_GetByID_Call <span class="cov8" title="11">{
        return &amp;MockcategoryRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockcategoryRepository_GetByID_Call) Run(run func(ctx context.Context, id category.ID)) *MockcategoryRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(category.ID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryRepository_GetByID_Call) Return(_a0 *category.Category, _a1 error) *MockcategoryRepository_GetByID_Call <span class="cov8" title="11">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockcategoryRepository_GetByID_Call) RunAndReturn(run func(context.Context, category.ID) (*category.Category, error)) *MockcategoryRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByName provides a mock function with given fields: ctx, name
func (_m *MockcategoryRepository) GetByName(ctx context.Context, name string) (*category.Category, error) <span class="cov5" title="4">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByName")</span>
        }

        <span class="cov5" title="4">var r0 *category.Category
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*category.Category, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov5" title="4">if rf, ok := ret.Get(0).(func(context.Context, string) *category.Category); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov5" title="4"> {
                if ret.Get(0) != nil </span><span class="cov5" title="4">{
                        r0 = ret.Get(0).(*category.Category)
                }</span>
        }

        <span class="cov5" title="4">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov5" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="4">return r0, r1</span>
}

// MockcategoryRepository_GetByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByName'
type MockcategoryRepository_GetByName_Call struct {
        *mock.Call
}

// GetByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockcategoryRepository_Expecter) GetByName(ctx interface{}, name interface{}) *MockcategoryRepository_GetByName_Call <span class="cov5" title="4">{
        return &amp;MockcategoryRepository_GetByName_Call{Call: _e.mock.On("GetByName", ctx, name)}
}</span>

func (_c *MockcategoryRepository_GetByName_Call) Run(run func(ctx context.Context, name string)) *MockcategoryRepository_GetByName_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryRepository_GetByName_Call) Return(_a0 *category.Category, _a1 error) *MockcategoryRepository_GetByName_Call <span class="cov5" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockcategoryRepository_GetByName_Call) RunAndReturn(run func(context.Context, string) (*category.Category, error)) *MockcategoryRepository_GetByName_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockcategoryRepository) GetNextID() category.ID <span class="cov3" title="2">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov3" title="2">var r0 category.ID
        if rf, ok := ret.Get(0).(func() category.ID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov3" title="2"> {
                r0 = ret.Get(0).(category.ID)
        }</span>

        <span class="cov3" title="2">return r0</span>
}

// MockcategoryRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockcategoryRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockcategoryRepository_Expecter) GetNextID() *MockcategoryRepository_GetNextID_Call <span class="cov3" title="2">{
        return &amp;MockcategoryRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockcategoryRepository_GetNextID_Call) Run(run func()) *MockcategoryRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryRepository_GetNextID_Call) Return(_a0 category.ID) *MockcategoryRepository_GetNextID_Call <span class="cov3" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockcategoryRepository_GetNextID_Call) RunAndReturn(run func() category.ID) *MockcategoryRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockcategoryRepository) Store(ctx context.Context, entity *category.Category) error <span class="cov3" title="2">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov3" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *category.Category) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov3" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov3" title="2">return r0</span>
}

// MockcategoryRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockcategoryRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *category.Category
func (_e *MockcategoryRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockcategoryRepository_Store_Call <span class="cov3" title="2">{
        return &amp;MockcategoryRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockcategoryRepository_Store_Call) Run(run func(ctx context.Context, entity *category.Category)) *MockcategoryRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*category.Category))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockcategoryRepository_Store_Call) Return(_a0 error) *MockcategoryRepository_Store_Call <span class="cov3" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockcategoryRepository_Store_Call) RunAndReturn(run func(context.Context, *category.Category) error) *MockcategoryRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockcategoryRepository creates a new instance of MockcategoryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockcategoryRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockcategoryRepository <span class="cov4" title="3">{
        mock := &amp;MockcategoryRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov4" title="3">{ mock.AssertExpectations(t) }</span>)

        <span class="cov4" title="3">return mock</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        expense "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        group "github.com/Beigelman/nossas-despesas/internal/modules/group"

        mock "github.com/stretchr/testify/mock"

        time "time"
)

// MockexpenseRepository is an autogenerated mock type for the Repository type
type MockexpenseRepository struct {
        mock.Mock
}

type MockexpenseRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockexpenseRepository) EXPECT() *MockexpenseRepository_Expecter <span class="cov10" title="28">{
        return &amp;MockexpenseRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// BulkStore provides a mock function with given fields: ctx, expenses
func (_m *MockexpenseRepository) BulkStore(ctx context.Context, expenses []expense.Expense) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, expenses)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BulkStore")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, []expense.Expense) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, expenses)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockexpenseRepository_BulkStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkStore'
type MockexpenseRepository_BulkStore_Call struct {
        *mock.Call
}

// BulkStore is a helper method to define mock.On call
//   - ctx context.Context
//   - expenses []expense.Expense
func (_e *MockexpenseRepository_Expecter) BulkStore(ctx interface{}, expenses interface{}) *MockexpenseRepository_BulkStore_Call <span class="cov0" title="0">{
        return &amp;MockexpenseRepository_BulkStore_Call{Call: _e.mock.On("BulkStore", ctx, expenses)}
}</span>

func (_c *MockexpenseRepository_BulkStore_Call) Run(run func(ctx context.Context, expenses []expense.Expense)) *MockexpenseRepository_BulkStore_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].([]expense.Expense))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockexpenseRepository_BulkStore_Call) Return(_a0 error) *MockexpenseRepository_BulkStore_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockexpenseRepository_BulkStore_Call) RunAndReturn(run func(context.Context, []expense.Expense) error) *MockexpenseRepository_BulkStore_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByGroupDate provides a mock function with given fields: ctx, groupId, date
func (_m *MockexpenseRepository) GetByGroupDate(ctx context.Context, groupId group.ID, date time.Time) ([]expense.Expense, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, groupId, date)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByGroupDate")</span>
        }

        <span class="cov0" title="0">var r0 []expense.Expense
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, group.ID, time.Time) ([]expense.Expense, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, groupId, date)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, group.ID, time.Time) []expense.Expense); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, groupId, date)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]expense.Expense)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, group.ID, time.Time) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, groupId, date)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockexpenseRepository_GetByGroupDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByGroupDate'
type MockexpenseRepository_GetByGroupDate_Call struct {
        *mock.Call
}

// GetByGroupDate is a helper method to define mock.On call
//   - ctx context.Context
//   - groupId group.ID
//   - date time.Time
func (_e *MockexpenseRepository_Expecter) GetByGroupDate(ctx interface{}, groupId interface{}, date interface{}) *MockexpenseRepository_GetByGroupDate_Call <span class="cov0" title="0">{
        return &amp;MockexpenseRepository_GetByGroupDate_Call{Call: _e.mock.On("GetByGroupDate", ctx, groupId, date)}
}</span>

func (_c *MockexpenseRepository_GetByGroupDate_Call) Run(run func(ctx context.Context, groupId group.ID, date time.Time)) *MockexpenseRepository_GetByGroupDate_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(group.ID), args[2].(time.Time))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockexpenseRepository_GetByGroupDate_Call) Return(_a0 []expense.Expense, _a1 error) *MockexpenseRepository_GetByGroupDate_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockexpenseRepository_GetByGroupDate_Call) RunAndReturn(run func(context.Context, group.ID, time.Time) ([]expense.Expense, error)) *MockexpenseRepository_GetByGroupDate_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockexpenseRepository) GetByID(ctx context.Context, id expense.ID) (*expense.Expense, error) <span class="cov8" title="15">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov8" title="15">var r0 *expense.Expense
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, expense.ID) (*expense.Expense, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov8" title="15">if rf, ok := ret.Get(0).(func(context.Context, expense.ID) *expense.Expense); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="15"> {
                if ret.Get(0) != nil </span><span class="cov8" title="15">{
                        r0 = ret.Get(0).(*expense.Expense)
                }</span>
        }

        <span class="cov8" title="15">if rf, ok := ret.Get(1).(func(context.Context, expense.ID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="15"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="15">return r0, r1</span>
}

// MockexpenseRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockexpenseRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id expense.ID
func (_e *MockexpenseRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockexpenseRepository_GetByID_Call <span class="cov8" title="15">{
        return &amp;MockexpenseRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockexpenseRepository_GetByID_Call) Run(run func(ctx context.Context, id expense.ID)) *MockexpenseRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(expense.ID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockexpenseRepository_GetByID_Call) Return(_a0 *expense.Expense, _a1 error) *MockexpenseRepository_GetByID_Call <span class="cov8" title="15">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockexpenseRepository_GetByID_Call) RunAndReturn(run func(context.Context, expense.ID) (*expense.Expense, error)) *MockexpenseRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockexpenseRepository) GetNextID() expense.ID <span class="cov4" title="4">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov4" title="4">var r0 expense.ID
        if rf, ok := ret.Get(0).(func() expense.ID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov4" title="4"> {
                r0 = ret.Get(0).(expense.ID)
        }</span>

        <span class="cov4" title="4">return r0</span>
}

// MockexpenseRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockexpenseRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockexpenseRepository_Expecter) GetNextID() *MockexpenseRepository_GetNextID_Call <span class="cov4" title="4">{
        return &amp;MockexpenseRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockexpenseRepository_GetNextID_Call) Run(run func()) *MockexpenseRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockexpenseRepository_GetNextID_Call) Return(_a0 expense.ID) *MockexpenseRepository_GetNextID_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockexpenseRepository_GetNextID_Call) RunAndReturn(run func() expense.ID) *MockexpenseRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockexpenseRepository) Store(ctx context.Context, entity *expense.Expense) error <span class="cov6" title="9">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov6" title="9">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *expense.Expense) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov6" title="9"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov6" title="9">return r0</span>
}

// MockexpenseRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockexpenseRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *expense.Expense
func (_e *MockexpenseRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockexpenseRepository_Store_Call <span class="cov6" title="9">{
        return &amp;MockexpenseRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockexpenseRepository_Store_Call) Run(run func(ctx context.Context, entity *expense.Expense)) *MockexpenseRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*expense.Expense))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockexpenseRepository_Store_Call) Return(_a0 error) *MockexpenseRepository_Store_Call <span class="cov6" title="9">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockexpenseRepository_Store_Call) RunAndReturn(run func(context.Context, *expense.Expense) error) *MockexpenseRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockexpenseRepository creates a new instance of MockexpenseRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockexpenseRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockexpenseRepository <span class="cov3" title="3">{
        mock := &amp;MockexpenseRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov3" title="3">{ mock.AssertExpectations(t) }</span>)

        <span class="cov3" title="3">return mock</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        group "github.com/Beigelman/nossas-despesas/internal/modules/group"
        mock "github.com/stretchr/testify/mock"
)

// MockgroupInviteRepository is an autogenerated mock type for the InviteRepository type
type MockgroupInviteRepository struct {
        mock.Mock
}

type MockgroupInviteRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockgroupInviteRepository) EXPECT() *MockgroupInviteRepository_Expecter <span class="cov10" title="14">{
        return &amp;MockgroupInviteRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockgroupInviteRepository) GetByID(ctx context.Context, id group.InviteID) (*group.Invite, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *group.Invite
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, group.InviteID) (*group.Invite, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, group.InviteID) *group.Invite); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*group.Invite)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, group.InviteID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockgroupInviteRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockgroupInviteRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id group.InviteID
func (_e *MockgroupInviteRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockgroupInviteRepository_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockgroupInviteRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockgroupInviteRepository_GetByID_Call) Run(run func(ctx context.Context, id group.InviteID)) *MockgroupInviteRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(group.InviteID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupInviteRepository_GetByID_Call) Return(_a0 *group.Invite, _a1 error) *MockgroupInviteRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockgroupInviteRepository_GetByID_Call) RunAndReturn(run func(context.Context, group.InviteID) (*group.Invite, error)) *MockgroupInviteRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByToken provides a mock function with given fields: ctx, token
func (_m *MockgroupInviteRepository) GetByToken(ctx context.Context, token string) (*group.Invite, error) <span class="cov7" title="6">{
        ret := _m.Called(ctx, token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByToken")</span>
        }

        <span class="cov7" title="6">var r0 *group.Invite
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*group.Invite, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, token)
        }</span>
        <span class="cov7" title="6">if rf, ok := ret.Get(0).(func(context.Context, string) *group.Invite); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, token)
        }</span> else<span class="cov7" title="6"> {
                if ret.Get(0) != nil </span><span class="cov7" title="6">{
                        r0 = ret.Get(0).(*group.Invite)
                }</span>
        }

        <span class="cov7" title="6">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, token)
        }</span> else<span class="cov7" title="6"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="6">return r0, r1</span>
}

// MockgroupInviteRepository_GetByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByToken'
type MockgroupInviteRepository_GetByToken_Call struct {
        *mock.Call
}

// GetByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockgroupInviteRepository_Expecter) GetByToken(ctx interface{}, token interface{}) *MockgroupInviteRepository_GetByToken_Call <span class="cov7" title="6">{
        return &amp;MockgroupInviteRepository_GetByToken_Call{Call: _e.mock.On("GetByToken", ctx, token)}
}</span>

func (_c *MockgroupInviteRepository_GetByToken_Call) Run(run func(ctx context.Context, token string)) *MockgroupInviteRepository_GetByToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupInviteRepository_GetByToken_Call) Return(_a0 *group.Invite, _a1 error) *MockgroupInviteRepository_GetByToken_Call <span class="cov7" title="6">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockgroupInviteRepository_GetByToken_Call) RunAndReturn(run func(context.Context, string) (*group.Invite, error)) *MockgroupInviteRepository_GetByToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetGroupInvitesByEmail provides a mock function with given fields: ctx, groupID, email
func (_m *MockgroupInviteRepository) GetGroupInvitesByEmail(ctx context.Context, groupID group.ID, email string) ([]group.Invite, error) <span class="cov5" title="4">{
        ret := _m.Called(ctx, groupID, email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetGroupInvitesByEmail")</span>
        }

        <span class="cov5" title="4">var r0 []group.Invite
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, group.ID, string) ([]group.Invite, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, groupID, email)
        }</span>
        <span class="cov5" title="4">if rf, ok := ret.Get(0).(func(context.Context, group.ID, string) []group.Invite); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, groupID, email)
        }</span> else<span class="cov5" title="4"> {
                if ret.Get(0) != nil </span><span class="cov5" title="4">{
                        r0 = ret.Get(0).([]group.Invite)
                }</span>
        }

        <span class="cov5" title="4">if rf, ok := ret.Get(1).(func(context.Context, group.ID, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, groupID, email)
        }</span> else<span class="cov5" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="4">return r0, r1</span>
}

// MockgroupInviteRepository_GetGroupInvitesByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupInvitesByEmail'
type MockgroupInviteRepository_GetGroupInvitesByEmail_Call struct {
        *mock.Call
}

// GetGroupInvitesByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID group.ID
//   - email string
func (_e *MockgroupInviteRepository_Expecter) GetGroupInvitesByEmail(ctx interface{}, groupID interface{}, email interface{}) *MockgroupInviteRepository_GetGroupInvitesByEmail_Call <span class="cov5" title="4">{
        return &amp;MockgroupInviteRepository_GetGroupInvitesByEmail_Call{Call: _e.mock.On("GetGroupInvitesByEmail", ctx, groupID, email)}
}</span>

func (_c *MockgroupInviteRepository_GetGroupInvitesByEmail_Call) Run(run func(ctx context.Context, groupID group.ID, email string)) *MockgroupInviteRepository_GetGroupInvitesByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(group.ID), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupInviteRepository_GetGroupInvitesByEmail_Call) Return(_a0 []group.Invite, _a1 error) *MockgroupInviteRepository_GetGroupInvitesByEmail_Call <span class="cov5" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockgroupInviteRepository_GetGroupInvitesByEmail_Call) RunAndReturn(run func(context.Context, group.ID, string) ([]group.Invite, error)) *MockgroupInviteRepository_GetGroupInvitesByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockgroupInviteRepository) GetNextID() group.InviteID <span class="cov3" title="2">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov3" title="2">var r0 group.InviteID
        if rf, ok := ret.Get(0).(func() group.InviteID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov3" title="2"> {
                r0 = ret.Get(0).(group.InviteID)
        }</span>

        <span class="cov3" title="2">return r0</span>
}

// MockgroupInviteRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockgroupInviteRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockgroupInviteRepository_Expecter) GetNextID() *MockgroupInviteRepository_GetNextID_Call <span class="cov3" title="2">{
        return &amp;MockgroupInviteRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockgroupInviteRepository_GetNextID_Call) Run(run func()) *MockgroupInviteRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupInviteRepository_GetNextID_Call) Return(_a0 group.InviteID) *MockgroupInviteRepository_GetNextID_Call <span class="cov3" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockgroupInviteRepository_GetNextID_Call) RunAndReturn(run func() group.InviteID) *MockgroupInviteRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockgroupInviteRepository) Store(ctx context.Context, entity *group.Invite) error <span class="cov3" title="2">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov3" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *group.Invite) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov3" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov3" title="2">return r0</span>
}

// MockgroupInviteRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockgroupInviteRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *group.Invite
func (_e *MockgroupInviteRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockgroupInviteRepository_Store_Call <span class="cov3" title="2">{
        return &amp;MockgroupInviteRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockgroupInviteRepository_Store_Call) Run(run func(ctx context.Context, entity *group.Invite)) *MockgroupInviteRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*group.Invite))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupInviteRepository_Store_Call) Return(_a0 error) *MockgroupInviteRepository_Store_Call <span class="cov3" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockgroupInviteRepository_Store_Call) RunAndReturn(run func(context.Context, *group.Invite) error) *MockgroupInviteRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockgroupInviteRepository creates a new instance of MockgroupInviteRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockgroupInviteRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockgroupInviteRepository <span class="cov3" title="2">{
        mock := &amp;MockgroupInviteRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov3" title="2">{ mock.AssertExpectations(t) }</span>)

        <span class="cov3" title="2">return mock</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        group "github.com/Beigelman/nossas-despesas/internal/modules/group"
        mock "github.com/stretchr/testify/mock"
)

// MockgroupRepository is an autogenerated mock type for the Repository type
type MockgroupRepository struct {
        mock.Mock
}

type MockgroupRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockgroupRepository) EXPECT() *MockgroupRepository_Expecter <span class="cov10" title="23">{
        return &amp;MockgroupRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockgroupRepository) GetByID(ctx context.Context, id group.ID) (*group.Group, error) <span class="cov9" title="17">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov9" title="17">var r0 *group.Group
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, group.ID) (*group.Group, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov9" title="17">if rf, ok := ret.Get(0).(func(context.Context, group.ID) *group.Group); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov9" title="17"> {
                if ret.Get(0) != nil </span><span class="cov9" title="17">{
                        r0 = ret.Get(0).(*group.Group)
                }</span>
        }

        <span class="cov9" title="17">if rf, ok := ret.Get(1).(func(context.Context, group.ID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov9" title="17"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov9" title="17">return r0, r1</span>
}

// MockgroupRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockgroupRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id group.ID
func (_e *MockgroupRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockgroupRepository_GetByID_Call <span class="cov9" title="17">{
        return &amp;MockgroupRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockgroupRepository_GetByID_Call) Run(run func(ctx context.Context, id group.ID)) *MockgroupRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(group.ID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupRepository_GetByID_Call) Return(_a0 *group.Group, _a1 error) *MockgroupRepository_GetByID_Call <span class="cov9" title="17">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockgroupRepository_GetByID_Call) RunAndReturn(run func(context.Context, group.ID) (*group.Group, error)) *MockgroupRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByName provides a mock function with given fields: ctx, name
func (_m *MockgroupRepository) GetByName(ctx context.Context, name string) (*group.Group, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByName")</span>
        }

        <span class="cov0" title="0">var r0 *group.Group
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*group.Group, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *group.Group); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*group.Group)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockgroupRepository_GetByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByName'
type MockgroupRepository_GetByName_Call struct {
        *mock.Call
}

// GetByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockgroupRepository_Expecter) GetByName(ctx interface{}, name interface{}) *MockgroupRepository_GetByName_Call <span class="cov0" title="0">{
        return &amp;MockgroupRepository_GetByName_Call{Call: _e.mock.On("GetByName", ctx, name)}
}</span>

func (_c *MockgroupRepository_GetByName_Call) Run(run func(ctx context.Context, name string)) *MockgroupRepository_GetByName_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupRepository_GetByName_Call) Return(_a0 *group.Group, _a1 error) *MockgroupRepository_GetByName_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockgroupRepository_GetByName_Call) RunAndReturn(run func(context.Context, string) (*group.Group, error)) *MockgroupRepository_GetByName_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockgroupRepository) GetNextID() group.ID <span class="cov4" title="3">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov4" title="3">var r0 group.ID
        if rf, ok := ret.Get(0).(func() group.ID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Get(0).(group.ID)
        }</span>

        <span class="cov4" title="3">return r0</span>
}

// MockgroupRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockgroupRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockgroupRepository_Expecter) GetNextID() *MockgroupRepository_GetNextID_Call <span class="cov4" title="3">{
        return &amp;MockgroupRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockgroupRepository_GetNextID_Call) Run(run func()) *MockgroupRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupRepository_GetNextID_Call) Return(_a0 group.ID) *MockgroupRepository_GetNextID_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockgroupRepository_GetNextID_Call) RunAndReturn(run func() group.ID) *MockgroupRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockgroupRepository) Store(ctx context.Context, entity *group.Group) error <span class="cov4" title="3">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov4" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *group.Group) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov4" title="3"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="3">return r0</span>
}

// MockgroupRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockgroupRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *group.Group
func (_e *MockgroupRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockgroupRepository_Store_Call <span class="cov4" title="3">{
        return &amp;MockgroupRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockgroupRepository_Store_Call) Run(run func(ctx context.Context, entity *group.Group)) *MockgroupRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*group.Group))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockgroupRepository_Store_Call) Return(_a0 error) *MockgroupRepository_Store_Call <span class="cov4" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockgroupRepository_Store_Call) RunAndReturn(run func(context.Context, *group.Group) error) *MockgroupRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockgroupRepository creates a new instance of MockgroupRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockgroupRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockgroupRepository <span class="cov4" title="3">{
        mock := &amp;MockgroupRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov4" title="3">{ mock.AssertExpectations(t) }</span>)

        <span class="cov4" title="3">return mock</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        income "github.com/Beigelman/nossas-despesas/internal/modules/income"
        mock "github.com/stretchr/testify/mock"

        time "time"

        user "github.com/Beigelman/nossas-despesas/internal/modules/user"
)

// MockincomeRepository is an autogenerated mock type for the Repository type
type MockincomeRepository struct {
        mock.Mock
}

type MockincomeRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockincomeRepository) EXPECT() *MockincomeRepository_Expecter <span class="cov10" title="4">{
        return &amp;MockincomeRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockincomeRepository) GetByID(ctx context.Context, id income.ID) (*income.Income, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *income.Income
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, income.ID) (*income.Income, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, income.ID) *income.Income); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*income.Income)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, income.ID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockincomeRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockincomeRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id income.ID
func (_e *MockincomeRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockincomeRepository_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockincomeRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockincomeRepository_GetByID_Call) Run(run func(ctx context.Context, id income.ID)) *MockincomeRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(income.ID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockincomeRepository_GetByID_Call) Return(_a0 *income.Income, _a1 error) *MockincomeRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockincomeRepository_GetByID_Call) RunAndReturn(run func(context.Context, income.ID) (*income.Income, error)) *MockincomeRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockincomeRepository) GetNextID() income.ID <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov0" title="0">var r0 income.ID
        if rf, ok := ret.Get(0).(func() income.ID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(income.ID)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockincomeRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockincomeRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockincomeRepository_Expecter) GetNextID() *MockincomeRepository_GetNextID_Call <span class="cov0" title="0">{
        return &amp;MockincomeRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockincomeRepository_GetNextID_Call) Run(run func()) *MockincomeRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockincomeRepository_GetNextID_Call) Return(_a0 income.ID) *MockincomeRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockincomeRepository_GetNextID_Call) RunAndReturn(run func() income.ID) *MockincomeRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserMonthlyIncomes provides a mock function with given fields: ctx, userID, date
func (_m *MockincomeRepository) GetUserMonthlyIncomes(ctx context.Context, userID user.ID, date *time.Time) ([]income.Income, error) <span class="cov10" title="4">{
        ret := _m.Called(ctx, userID, date)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserMonthlyIncomes")</span>
        }

        <span class="cov10" title="4">var r0 []income.Income
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, user.ID, *time.Time) ([]income.Income, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userID, date)
        }</span>
        <span class="cov10" title="4">if rf, ok := ret.Get(0).(func(context.Context, user.ID, *time.Time) []income.Income); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userID, date)
        }</span> else<span class="cov10" title="4"> {
                if ret.Get(0) != nil </span><span class="cov10" title="4">{
                        r0 = ret.Get(0).([]income.Income)
                }</span>
        }

        <span class="cov10" title="4">if rf, ok := ret.Get(1).(func(context.Context, user.ID, *time.Time) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userID, date)
        }</span> else<span class="cov10" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov10" title="4">return r0, r1</span>
}

// MockincomeRepository_GetUserMonthlyIncomes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserMonthlyIncomes'
type MockincomeRepository_GetUserMonthlyIncomes_Call struct {
        *mock.Call
}

// GetUserMonthlyIncomes is a helper method to define mock.On call
//   - ctx context.Context
//   - userID user.ID
//   - date *time.Time
func (_e *MockincomeRepository_Expecter) GetUserMonthlyIncomes(ctx interface{}, userID interface{}, date interface{}) *MockincomeRepository_GetUserMonthlyIncomes_Call <span class="cov10" title="4">{
        return &amp;MockincomeRepository_GetUserMonthlyIncomes_Call{Call: _e.mock.On("GetUserMonthlyIncomes", ctx, userID, date)}
}</span>

func (_c *MockincomeRepository_GetUserMonthlyIncomes_Call) Run(run func(ctx context.Context, userID user.ID, date *time.Time)) *MockincomeRepository_GetUserMonthlyIncomes_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(user.ID), args[2].(*time.Time))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockincomeRepository_GetUserMonthlyIncomes_Call) Return(_a0 []income.Income, _a1 error) *MockincomeRepository_GetUserMonthlyIncomes_Call <span class="cov10" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockincomeRepository_GetUserMonthlyIncomes_Call) RunAndReturn(run func(context.Context, user.ID, *time.Time) ([]income.Income, error)) *MockincomeRepository_GetUserMonthlyIncomes_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockincomeRepository) Store(ctx context.Context, entity *income.Income) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *income.Income) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockincomeRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockincomeRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *income.Income
func (_e *MockincomeRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockincomeRepository_Store_Call <span class="cov0" title="0">{
        return &amp;MockincomeRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockincomeRepository_Store_Call) Run(run func(ctx context.Context, entity *income.Income)) *MockincomeRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*income.Income))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockincomeRepository_Store_Call) Return(_a0 error) *MockincomeRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockincomeRepository_Store_Call) RunAndReturn(run func(context.Context, *income.Income) error) *MockincomeRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockincomeRepository creates a new instance of MockincomeRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockincomeRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockincomeRepository <span class="cov5" title="2">{
        mock := &amp;MockincomeRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov5" title="2">{ mock.AssertExpectations(t) }</span>)

        <span class="cov5" title="2">return mock</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        email "github.com/Beigelman/nossas-despesas/internal/shared/infra/email"
        mock "github.com/stretchr/testify/mock"
)

// MockserviceEmailProvider is an autogenerated mock type for the EmailProvider type
type MockserviceEmailProvider struct {
        mock.Mock
}

type MockserviceEmailProvider_Expecter struct {
        mock *mock.Mock
}

func (_m *MockserviceEmailProvider) EXPECT() *MockserviceEmailProvider_Expecter <span class="cov0" title="0">{
        return &amp;MockserviceEmailProvider_Expecter{mock: &amp;_m.Mock}
}</span>

// Send provides a mock function with given fields: ctx, _a1
func (_m *MockserviceEmailProvider) Send(ctx context.Context, _a1 email.Email) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Send")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, email.Email) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockserviceEmailProvider_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockserviceEmailProvider_Send_Call struct {
        *mock.Call
}

// Send is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 email.Email
func (_e *MockserviceEmailProvider_Expecter) Send(ctx interface{}, _a1 interface{}) *MockserviceEmailProvider_Send_Call <span class="cov0" title="0">{
        return &amp;MockserviceEmailProvider_Send_Call{Call: _e.mock.On("Send", ctx, _a1)}
}</span>

func (_c *MockserviceEmailProvider_Send_Call) Run(run func(ctx context.Context, _a1 email.Email)) *MockserviceEmailProvider_Send_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(email.Email))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockserviceEmailProvider_Send_Call) Return(_a0 error) *MockserviceEmailProvider_Send_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockserviceEmailProvider_Send_Call) RunAndReturn(run func(context.Context, email.Email) error) *MockserviceEmailProvider_Send_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockserviceEmailProvider creates a new instance of MockserviceEmailProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockserviceEmailProvider(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockserviceEmailProvider <span class="cov8" title="1">{
        mock := &amp;MockserviceEmailProvider{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        auth "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        mock "github.com/stretchr/testify/mock"

        user "github.com/Beigelman/nossas-despesas/internal/modules/user"
)

// MockserviceTokenProvider is an autogenerated mock type for the TokenProvider type
type MockserviceTokenProvider struct {
        mock.Mock
}

type MockserviceTokenProvider_Expecter struct {
        mock *mock.Mock
}

func (_m *MockserviceTokenProvider) EXPECT() *MockserviceTokenProvider_Expecter <span class="cov10" title="11">{
        return &amp;MockserviceTokenProvider_Expecter{mock: &amp;_m.Mock}
}</span>

// GenerateUserTokens provides a mock function with given fields: _a0
func (_m *MockserviceTokenProvider) GenerateUserTokens(_a0 user.User) (string, string, error) <span class="cov7" title="6">{
        ret := _m.Called(_a0)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GenerateUserTokens")</span>
        }

        <span class="cov7" title="6">var r0 string
        var r1 string
        var r2 error
        if rf, ok := ret.Get(0).(func(user.User) (string, string, error)); ok </span><span class="cov0" title="0">{
                return rf(_a0)
        }</span>
        <span class="cov7" title="6">if rf, ok := ret.Get(0).(func(user.User) string); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0)
        }</span> else<span class="cov7" title="6"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov7" title="6">if rf, ok := ret.Get(1).(func(user.User) string); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0)
        }</span> else<span class="cov7" title="6"> {
                r1 = ret.Get(1).(string)
        }</span>

        <span class="cov7" title="6">if rf, ok := ret.Get(2).(func(user.User) error); ok </span><span class="cov0" title="0">{
                r2 = rf(_a0)
        }</span> else<span class="cov7" title="6"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov7" title="6">return r0, r1, r2</span>
}

// MockserviceTokenProvider_GenerateUserTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateUserTokens'
type MockserviceTokenProvider_GenerateUserTokens_Call struct {
        *mock.Call
}

// GenerateUserTokens is a helper method to define mock.On call
//   - _a0 user.User
func (_e *MockserviceTokenProvider_Expecter) GenerateUserTokens(_a0 interface{}) *MockserviceTokenProvider_GenerateUserTokens_Call <span class="cov7" title="6">{
        return &amp;MockserviceTokenProvider_GenerateUserTokens_Call{Call: _e.mock.On("GenerateUserTokens", _a0)}
}</span>

func (_c *MockserviceTokenProvider_GenerateUserTokens_Call) Run(run func(_a0 user.User)) *MockserviceTokenProvider_GenerateUserTokens_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(user.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockserviceTokenProvider_GenerateUserTokens_Call) Return(_a0 string, _a1 string, _a2 error) *MockserviceTokenProvider_GenerateUserTokens_Call <span class="cov7" title="6">{
        _c.Call.Return(_a0, _a1, _a2)
        return _c
}</span>

func (_c *MockserviceTokenProvider_GenerateUserTokens_Call) RunAndReturn(run func(user.User) (string, string, error)) *MockserviceTokenProvider_GenerateUserTokens_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ParseRefreshToken provides a mock function with given fields: token
func (_m *MockserviceTokenProvider) ParseRefreshToken(token string) (*auth.Token, error) <span class="cov7" title="5">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ParseRefreshToken")</span>
        }

        <span class="cov7" title="5">var r0 *auth.Token
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*auth.Token, error)); ok </span><span class="cov0" title="0">{
                return rf(token)
        }</span>
        <span class="cov7" title="5">if rf, ok := ret.Get(0).(func(string) *auth.Token); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov7" title="5"> {
                if ret.Get(0) != nil </span><span class="cov7" title="5">{
                        r0 = ret.Get(0).(*auth.Token)
                }</span>
        }

        <span class="cov7" title="5">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(token)
        }</span> else<span class="cov7" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="5">return r0, r1</span>
}

// MockserviceTokenProvider_ParseRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseRefreshToken'
type MockserviceTokenProvider_ParseRefreshToken_Call struct {
        *mock.Call
}

// ParseRefreshToken is a helper method to define mock.On call
//   - token string
func (_e *MockserviceTokenProvider_Expecter) ParseRefreshToken(token interface{}) *MockserviceTokenProvider_ParseRefreshToken_Call <span class="cov7" title="5">{
        return &amp;MockserviceTokenProvider_ParseRefreshToken_Call{Call: _e.mock.On("ParseRefreshToken", token)}
}</span>

func (_c *MockserviceTokenProvider_ParseRefreshToken_Call) Run(run func(token string)) *MockserviceTokenProvider_ParseRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockserviceTokenProvider_ParseRefreshToken_Call) Return(_a0 *auth.Token, _a1 error) *MockserviceTokenProvider_ParseRefreshToken_Call <span class="cov7" title="5">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockserviceTokenProvider_ParseRefreshToken_Call) RunAndReturn(run func(string) (*auth.Token, error)) *MockserviceTokenProvider_ParseRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ParseToken provides a mock function with given fields: token
func (_m *MockserviceTokenProvider) ParseToken(token string) (*auth.Token, error) <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ParseToken")</span>
        }

        <span class="cov0" title="0">var r0 *auth.Token
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*auth.Token, error)); ok </span><span class="cov0" title="0">{
                return rf(token)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *auth.Token); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*auth.Token)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockserviceTokenProvider_ParseToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseToken'
type MockserviceTokenProvider_ParseToken_Call struct {
        *mock.Call
}

// ParseToken is a helper method to define mock.On call
//   - token string
func (_e *MockserviceTokenProvider_Expecter) ParseToken(token interface{}) *MockserviceTokenProvider_ParseToken_Call <span class="cov0" title="0">{
        return &amp;MockserviceTokenProvider_ParseToken_Call{Call: _e.mock.On("ParseToken", token)}
}</span>

func (_c *MockserviceTokenProvider_ParseToken_Call) Run(run func(token string)) *MockserviceTokenProvider_ParseToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockserviceTokenProvider_ParseToken_Call) Return(_a0 *auth.Token, _a1 error) *MockserviceTokenProvider_ParseToken_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockserviceTokenProvider_ParseToken_Call) RunAndReturn(run func(string) (*auth.Token, error)) *MockserviceTokenProvider_ParseToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockserviceTokenProvider creates a new instance of MockserviceTokenProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockserviceTokenProvider(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockserviceTokenProvider <span class="cov5" title="3">{
        mock := &amp;MockserviceTokenProvider{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov5" title="3">{ mock.AssertExpectations(t) }</span>)

        <span class="cov5" title="3">return mock</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        user "github.com/Beigelman/nossas-despesas/internal/modules/user"
        mock "github.com/stretchr/testify/mock"
)

// MockuserRepository is an autogenerated mock type for the Repository type
type MockuserRepository struct {
        mock.Mock
}

type MockuserRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockuserRepository) EXPECT() *MockuserRepository_Expecter <span class="cov10" title="80">{
        return &amp;MockuserRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetByEmail provides a mock function with given fields: ctx, email
func (_m *MockuserRepository) GetByEmail(ctx context.Context, email string) (*user.User, error) <span class="cov7" title="26">{
        ret := _m.Called(ctx, email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByEmail")</span>
        }

        <span class="cov7" title="26">var r0 *user.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*user.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email)
        }</span>
        <span class="cov7" title="26">if rf, ok := ret.Get(0).(func(context.Context, string) *user.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email)
        }</span> else<span class="cov7" title="26"> {
                if ret.Get(0) != nil </span><span class="cov7" title="26">{
                        r0 = ret.Get(0).(*user.User)
                }</span>
        }

        <span class="cov7" title="26">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email)
        }</span> else<span class="cov7" title="26"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="26">return r0, r1</span>
}

// MockuserRepository_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockuserRepository_GetByEmail_Call struct {
        *mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockuserRepository_Expecter) GetByEmail(ctx interface{}, email interface{}) *MockuserRepository_GetByEmail_Call <span class="cov7" title="26">{
        return &amp;MockuserRepository_GetByEmail_Call{Call: _e.mock.On("GetByEmail", ctx, email)}
}</span>

func (_c *MockuserRepository_GetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockuserRepository_GetByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockuserRepository_GetByEmail_Call) Return(_a0 *user.User, _a1 error) *MockuserRepository_GetByEmail_Call <span class="cov7" title="26">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockuserRepository_GetByEmail_Call) RunAndReturn(run func(context.Context, string) (*user.User, error)) *MockuserRepository_GetByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockuserRepository) GetByID(ctx context.Context, id user.ID) (*user.User, error) <span class="cov8" title="46">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov8" title="46">var r0 *user.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, user.ID) (*user.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov8" title="46">if rf, ok := ret.Get(0).(func(context.Context, user.ID) *user.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="46"> {
                if ret.Get(0) != nil </span><span class="cov8" title="46">{
                        r0 = ret.Get(0).(*user.User)
                }</span>
        }

        <span class="cov8" title="46">if rf, ok := ret.Get(1).(func(context.Context, user.ID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="46"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="46">return r0, r1</span>
}

// MockuserRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockuserRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id user.ID
func (_e *MockuserRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockuserRepository_GetByID_Call <span class="cov8" title="46">{
        return &amp;MockuserRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockuserRepository_GetByID_Call) Run(run func(ctx context.Context, id user.ID)) *MockuserRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(user.ID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockuserRepository_GetByID_Call) Return(_a0 *user.User, _a1 error) *MockuserRepository_GetByID_Call <span class="cov8" title="46">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockuserRepository_GetByID_Call) RunAndReturn(run func(context.Context, user.ID) (*user.User, error)) *MockuserRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetNextID provides a mock function with given fields:
func (_m *MockuserRepository) GetNextID() user.ID <span class="cov2" title="2">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetNextID")</span>
        }

        <span class="cov2" title="2">var r0 user.ID
        if rf, ok := ret.Get(0).(func() user.ID); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(user.ID)
        }</span>

        <span class="cov2" title="2">return r0</span>
}

// MockuserRepository_GetNextID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextID'
type MockuserRepository_GetNextID_Call struct {
        *mock.Call
}

// GetNextID is a helper method to define mock.On call
func (_e *MockuserRepository_Expecter) GetNextID() *MockuserRepository_GetNextID_Call <span class="cov2" title="2">{
        return &amp;MockuserRepository_GetNextID_Call{Call: _e.mock.On("GetNextID")}
}</span>

func (_c *MockuserRepository_GetNextID_Call) Run(run func()) *MockuserRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockuserRepository_GetNextID_Call) Return(_a0 user.ID) *MockuserRepository_GetNextID_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockuserRepository_GetNextID_Call) RunAndReturn(run func() user.ID) *MockuserRepository_GetNextID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Store provides a mock function with given fields: ctx, entity
func (_m *MockuserRepository) Store(ctx context.Context, entity *user.User) error <span class="cov4" title="6">{
        ret := _m.Called(ctx, entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Store")</span>
        }

        <span class="cov4" title="6">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *user.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, entity)
        }</span> else<span class="cov4" title="6"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov4" title="6">return r0</span>
}

// MockuserRepository_Store_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Store'
type MockuserRepository_Store_Call struct {
        *mock.Call
}

// Store is a helper method to define mock.On call
//   - ctx context.Context
//   - entity *user.User
func (_e *MockuserRepository_Expecter) Store(ctx interface{}, entity interface{}) *MockuserRepository_Store_Call <span class="cov4" title="6">{
        return &amp;MockuserRepository_Store_Call{Call: _e.mock.On("Store", ctx, entity)}
}</span>

func (_c *MockuserRepository_Store_Call) Run(run func(ctx context.Context, entity *user.User)) *MockuserRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*user.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockuserRepository_Store_Call) Return(_a0 error) *MockuserRepository_Store_Call <span class="cov4" title="6">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockuserRepository_Store_Call) RunAndReturn(run func(context.Context, *user.User) error) *MockuserRepository_Store_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockuserRepository creates a new instance of MockuserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockuserRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockuserRepository <span class="cov5" title="9">{
        mock := &amp;MockuserRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov5" title="9">{ mock.AssertExpectations(t) }</span>)

        <span class="cov5" title="9">return mock</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package main

import (
        "log"
        "log/slog"
        "os"

        auth "github.com/Beigelman/nossas-despesas/internal/modules/auth/module"
        category "github.com/Beigelman/nossas-despesas/internal/modules/category/module"
        expense "github.com/Beigelman/nossas-despesas/internal/modules/expense/module"
        group "github.com/Beigelman/nossas-despesas/internal/modules/group/module"
        income "github.com/Beigelman/nossas-despesas/internal/modules/income/module"
        user "github.com/Beigelman/nossas-despesas/internal/modules/user/module"
        "github.com/Beigelman/nossas-despesas/internal/pkg/api"
        "github.com/Beigelman/nossas-despesas/internal/pkg/config"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/Beigelman/nossas-despesas/internal/pkg/eon"
        "github.com/Beigelman/nossas-despesas/internal/pkg/logger"
        "github.com/Beigelman/nossas-despesas/internal/shared"
)

func main() <span class="cov0" title="0">{
        environment := env.MustParse(os.Getenv("ENV"))

        var lgr *slog.Logger
        if environment == env.Development </span><span class="cov0" title="0">{
                lgr = logger.NewDevelopment()
        }</span> else<span class="cov0" title="0"> {
                lgr = logger.NewProduction()
        }</span>

        <span class="cov0" title="0">app := eon.New("Nossas Despesas", eon.WithLogger(lgr))

        if err := app.BootStrap(
                // Common Modules
                config.Module,
                db.Module,
                api.Module,
                shared.Module,
                // Domain Modules
                auth.Module,
                category.Module,
                expense.Module,
                group.Module,
                income.Module,
                user.Module,
        ).Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to start application: ", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package createusers

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/auth"
        authrepo "github.com/Beigelman/nossas-despesas/internal/modules/auth/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        grouprepo "github.com/Beigelman/nossas-despesas/internal/modules/group/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        userrepo "github.com/Beigelman/nossas-despesas/internal/modules/user/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/config"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/spf13/cobra"
)

var (
        environment string
        password    string
)

var cmd = &amp;cobra.Command{
        Use: "create-users",
        Run: run,
}

func run(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
        ctx := context.Background()

        cfg := config.New(env.Environment(environment))
        cfg.SetConfigPath("./internal/config/config.yml")
        if err := cfg.LoadConfig(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("cfg.LoadConfig: %w", err))</span>
        }

        <span class="cov0" title="0">database, err := db.NewClient(cfg.DBConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">groupRepo := grouprepo.NewGroupRepository(database)
        usersRepo := userrepo.NewUserRepository(database)
        authRepo := authrepo.NewAuthRepository(database)

        grp := group.New(group.Attributes{
                ID:   groupRepo.GetNextID(),
                Name: "Luiel",
        })

        if err := groupRepo.Store(ctx, grp); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error saving group: %w", err))</span>
        }

        <span class="cov0" title="0">dan := user.New(user.Attributes{
                ID:      usersRepo.GetNextID(),
                Name:    "Daniel Beigelman",
                Email:   "daniel.b.beigelman@gmail.com",
                GroupID: &amp;grp.ID,
        })

        if err := usersRepo.Store(ctx, dan); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error saving user: %w", err))</span>
        }

        <span class="cov0" title="0">danCreds, _ := auth.NewCredentialAuth(auth.CredentialsAttributes{
                ID:       authRepo.GetNextID(),
                Email:    dan.Email,
                Password: password,
        })

        if err := authRepo.Store(ctx, danCreds); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error saving user credentials: %w", err))</span>
        }

        <span class="cov0" title="0">lu := user.New(user.Attributes{
                ID:      usersRepo.GetNextID(),
                Name:    "Luza Brito",
                Email:   "brito.luiza27@gmail.com",
                GroupID: &amp;grp.ID,
        })

        if err := usersRepo.Store(ctx, lu); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error saving user: %w", err))</span>
        }

        <span class="cov0" title="0">luCreds, _ := auth.NewCredentialAuth(auth.CredentialsAttributes{
                ID:       authRepo.GetNextID(),
                Email:    lu.Email,
                Password: password,
        })

        if err := authRepo.Store(ctx, luCreds); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error saving user credentials: %w", err))</span>
        }

        <span class="cov0" title="0">if err := database.Close(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(fmt.Errorf("error closing database %w", err))
        }</span>
}

func init() <span class="cov0" title="0">{
        cmd.Flags().StringVarP(&amp;environment, "env", "e", "development", "environment to run the script (local, dev, prod, etc)")
        cmd.Flags().StringVarP(&amp;password, "password", "p", "12345678", "password for the users created")
}</span>

func Cmd() *cobra.Command <span class="cov0" title="0">{
        return cmd
}</span>
</pre>
		
		<pre class="file" id="file142" style="display: none">package importincomes

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/income"
        "github.com/Beigelman/nossas-despesas/internal/modules/income/postgres"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
        "github.com/Beigelman/nossas-despesas/internal/pkg/config"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/Beigelman/nossas-despesas/scripts/utils"
        "github.com/schollz/progressbar/v3"
        "github.com/spf13/cobra"
)

var cmd = &amp;cobra.Command{
        Use: "import-incomes",
        Run: run,
}

var (
        danId, luId int
        environment string
)

func run(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
        ctx := context.Background()

        cfg := config.New(env.Environment(environment))
        cfg.SetConfigPath("./internal/config/config.yml")
        if err := cfg.LoadConfig(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("cfg.LoadConfig: %w", err))</span>
        }

        <span class="cov0" title="0">database, err := db.NewClient(cfg.DBConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">incomesRepo := postgres.NewIncomeRepository(database)

        file, err := utils.ReadCSVFile("./scripts/data/incomes.csv")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error reading csv file %w", err))</span>
        }
        <span class="cov0" title="0">bar := progressbar.Default(int64(len(file)))
        for _, line := range file </span><span class="cov0" title="0">{
                // Data                        Daniel Beigelman                Luza Brito
                // 2023-06-01        100000                                        12000
                date, err := time.Parse("2006/01/02", line[0])
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("error parsing date: %w", err))</span>
                }

                <span class="cov0" title="0">offsetDate := date.Add(12 * time.Hour)

                danAmount, err := strconv.ParseFloat(line[1], 64)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("error parsing amount %w", err))</span>
                }
                <span class="cov0" title="0">danIncomeCents := int(100 * danAmount)

                luAmount, err := strconv.ParseFloat(line[2], 64)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("error parsing amount %w", err))</span>
                }
                <span class="cov0" title="0">luIncomeCents := int(100 * luAmount)

                danIncome := income.New(income.Attributes{
                        ID:        incomesRepo.GetNextID(),
                        UserID:    user.ID{Value: danId},
                        Amount:    danIncomeCents,
                        Type:      income.Types.Salary,
                        CreatedAt: &amp;offsetDate,
                })

                luIncome := income.New(income.Attributes{
                        ID:        incomesRepo.GetNextID(),
                        UserID:    user.ID{Value: luId},
                        Amount:    luIncomeCents,
                        Type:      income.Types.Salary,
                        CreatedAt: &amp;offsetDate,
                })

                if err := incomesRepo.Store(ctx, danIncome); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(fmt.Errorf("error storing expense %w", err))
                }</span>

                <span class="cov0" title="0">if err := incomesRepo.Store(ctx, luIncome); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(fmt.Errorf("error storing expense %w", err))
                }</span>

                <span class="cov0" title="0">if err := bar.Add(1); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(fmt.Errorf("error incrementing progress bar %w", err))
                }</span>
        }

        <span class="cov0" title="0">if err := database.Close(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(fmt.Errorf("error closing database %w", err))
        }</span>
}

func Cmd() *cobra.Command <span class="cov0" title="0">{
        return cmd
}</span>

func init() <span class="cov0" title="0">{
        cmd.Flags().IntVarP(&amp;danId, "dan-id", "d", 1, "dan id")
        cmd.Flags().IntVarP(&amp;luId, "lu-id", "l", 2, "lu id")
        cmd.Flags().StringVarP(&amp;environment, "env", "e", "development", "environment to run the script (dev, stg, prd)")
}</span>
</pre>
		
		<pre class="file" id="file143" style="display: none">package importsplit

func SplitCategoryToCategory(category string) int <span class="cov0" title="0">{ //nolint:funlen
        switch category </span>{
        case "Geral":<span class="cov0" title="0">
                return 64</span>
        case "Mercado":<span class="cov0" title="0">
                return 16</span>
        case "Jantar fora":<span class="cov0" title="0">
                return 17</span>
        case "Txi":<span class="cov0" title="0">
                return 34</span>
        case "Seguro":<span class="cov0" title="0">
                return 45</span>
        case "Hotel":<span class="cov0" title="0">
                return 57</span>
        case "Filmes":<span class="cov0" title="0">
                return 22</span>
        case "Bebidas alcolicas":<span class="cov0" title="0">
                return 19</span>
        case "Entretenimento - Outros":<span class="cov0" title="0">
                return 29</span>
        case "Combustvel":<span class="cov0" title="0">
                return 30</span>
        case "Presents":<span class="cov0" title="0">
                return 43</span>
        case "Transporte - Outros":<span class="cov0" title="0">
                return 39</span>
        case "Estacionamento":<span class="cov0" title="0">
                return 31</span>
        case "Casa - Outros":<span class="cov0" title="0">
                return 14</span>
        case "Vida - Outros":<span class="cov0" title="0">
                return 43</span>
        case "Produtos de limpeza":<span class="cov0" title="0">
                return 15</span>
        case "Aluguel":<span class="cov0" title="0">
                return 1</span>
        case "TV/Telefone/Internet":<span class="cov0" title="0">
                return 6</span>
        case "Manuteno":<span class="cov0" title="0">
                return 8</span>
        case "Eletricidade":<span class="cov0" title="0">
                return 4</span>
        case "Aquecimento/gs":<span class="cov0" title="0">
                return 5</span>
        case "Vesturio":<span class="cov0" title="0">
                return 44</span>
        case "Despesas mdicas":<span class="cov0" title="0">
                return 51</span>
        case "Animais de estimao":<span class="cov0" title="0">
                return 9</span>
        case "Mveis":<span class="cov0" title="0">
                return 11</span>
        case "Carro":<span class="cov0" title="0">
                return 39</span>
        case "Eletrnicos":<span class="cov0" title="0">
                return 10</span>
        case "Comidas e bebidas - Outros":<span class="cov0" title="0">
                return 21</span>
        case "Esports":<span class="cov0" title="0">
                return 40</span>
        case "Servios":<span class="cov0" title="0">
                return 12</span>
        case "Servios pblicos - Outros":<span class="cov0" title="0">
                return 15</span>
        case "nibus/trem":<span class="cov0" title="0">
                return 33</span>
        case "Avio":<span class="cov0" title="0">
                return 56</span>
        case "Educao":<span class="cov0" title="0">
                return 42</span>
        case "Limpeza":<span class="cov0" title="0">
                return 13</span>
        case "Msica":<span class="cov0" title="0">
                return 26</span>
        case "Jogos":<span class="cov0" title="0">
                return 24</span>
        case "Impostos":<span class="cov0" title="0">
                return 63</span>
        default:<span class="cov0" title="0">
                return 64</span>
        }
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package importsplit

import (
        "context"
        "fmt"

        "github.com/Beigelman/nossas-despesas/internal/modules/expense/postgres"
        "github.com/Beigelman/nossas-despesas/internal/pkg/config"
        "github.com/Beigelman/nossas-despesas/internal/pkg/db"
        "github.com/Beigelman/nossas-despesas/internal/pkg/env"
        "github.com/Beigelman/nossas-despesas/scripts/utils"
        "github.com/schollz/progressbar/v3"
        "github.com/spf13/cobra"
)

var cmd = &amp;cobra.Command{
        Use: "import-from-split-wize",
        Run: run,
}

var (
        danId, luId, groupId int
        environment          string
)

func run(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
        ctx := context.Background()

        cfg := config.New(env.Environment(environment))
        cfg.SetConfigPath("./internal/config/config.yml")
        if err := cfg.LoadConfig(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("cfg.LoadConfig: %w", err))</span>
        }

        <span class="cov0" title="0">database, err := db.NewClient(cfg.DBConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">expensesRepo := postgres.NewExpenseRepository(database)

        file, err := utils.ReadCSVFile("./scripts/data/luiel.csv")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error reading csv file %w", err))</span>
        }

        <span class="cov0" title="0">bar := progressbar.Default(int64(len(file)))
        for _, line := range file </span><span class="cov0" title="0">{
                expense, err := extractExpense(line, expensesRepo.GetNextID())
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(fmt.Errorf("error extracting expense %w", err))
                }</span>

                <span class="cov0" title="0">if err := expensesRepo.Store(ctx, expense); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(fmt.Errorf("error storing expense %w", err))
                }</span>

                <span class="cov0" title="0">if err := bar.Add(1); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(fmt.Errorf("error incrementing progress bar %w", err))
                }</span>
        }

        <span class="cov0" title="0">if err := database.Close(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(fmt.Errorf("error closing database %w", err))
        }</span>
}

func Cmd() *cobra.Command <span class="cov0" title="0">{
        return cmd
}</span>

func init() <span class="cov0" title="0">{
        cmd.Flags().IntVarP(&amp;danId, "dan-id", "d", 1, "dan id")
        cmd.Flags().IntVarP(&amp;luId, "lu-id", "l", 2, "lu id")
        cmd.Flags().IntVarP(&amp;groupId, "group-id", "g", 1, "group id")
        cmd.Flags().StringVarP(&amp;environment, "env", "e", "development", "environment to run the script (dev, stg, prd)")
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">package importsplit

import (
        "fmt"
        "math"
        "math/rand"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/Beigelman/nossas-despesas/internal/modules/category"
        "github.com/Beigelman/nossas-despesas/internal/modules/expense"
        "github.com/Beigelman/nossas-despesas/internal/modules/group"
        "github.com/Beigelman/nossas-despesas/internal/modules/user"
)

func extractExpense(line []string, id expense.ID) (*expense.Expense, error) <span class="cov0" title="0">{
        date, err := time.Parse("2006-01-02", line[0])
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("error parsing date: %w", err))</span>
        }

        <span class="cov0" title="0">name := line[1]
        categoryId := SplitCategoryToCategory(line[2])
        amount, err := strconv.ParseFloat(line[3], 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing amount %w", err)
        }</span>

        <span class="cov0" title="0">amountCents := int(100 * amount)
        danShare, err := strconv.ParseFloat(line[6], 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing dan share %w", err)
        }</span>

        <span class="cov0" title="0">ratio := danShare / amount
        var payerRatio, receiverRatio, payer, receiver int

        if ratio &gt; 0 </span><span class="cov0" title="0">{
                payer = danId
                receiver = luId
                receiverRatio = int(math.Round(ratio * 100))
                payerRatio = 100 - receiverRatio
        }</span> else<span class="cov0" title="0"> {
                payer = luId
                receiver = danId
                receiverRatio = int(math.Round(ratio * -100))
                payerRatio = 100 - receiverRatio
        }</span>

        <span class="cov0" title="0">splitRatio := expense.SplitRatio{
                Payer:    payerRatio,
                Receiver: receiverRatio,
        }

        var splitType expense.SplitType
        if payerRatio == 50 || receiverRatio == 50 </span><span class="cov0" title="0">{
                splitType = expense.SplitTypes.Equal
        }</span> else<span class="cov0" title="0"> if receiverRatio == 100 </span><span class="cov0" title="0">{
                splitType = expense.SplitTypes.Transfer
        }</span> else<span class="cov0" title="0"> {
                splitType = expense.SplitTypes.Proportional
        }</span>

        <span class="cov0" title="0">regex, _ := regexp.Compile(`reembolso|cashback|ajuste`)
        createdAt := date.Add(time.Hour*4 + time.Duration(int(rand.Float64()*86400))*time.Millisecond)
        description := "Imported from splitwise"
        if regex.FindAllString(strings.ToLower(name), -1) != nil </span><span class="cov0" title="0">{
                createdAt = time.Time{}
                description = fmt.Sprintf("Imported from splitwise. Essa  uma transao legado que tem o objetivo de manter o balano das contas. Data original: %s", date.Format("2006-01-02"))
        }</span>

        <span class="cov0" title="0">return expense.New(expense.Attributes{
                ID:          id,
                Name:        name,
                Amount:      amountCents,
                Description: description,
                GroupID:     group.ID{Value: groupId},
                CategoryID:  category.ID{Value: categoryId},
                SplitRatio:  splitRatio,
                SplitType:   splitType,
                PayerID:     user.ID{Value: payer},
                ReceiverID:  user.ID{Value: receiver},
                CreatedAt:   &amp;createdAt,
        })</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package cmd

import (
        "os"

        "github.com/Beigelman/nossas-despesas/scripts/cmd/createusers"
        "github.com/Beigelman/nossas-despesas/scripts/cmd/importincomes"
        "github.com/Beigelman/nossas-despesas/scripts/cmd/importsplit"
        "github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "nossas-despesas-scripts",
        Short: "Scripts para automatizar tarefas de importao de arquivos",
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(createusers.Cmd())
        rootCmd.AddCommand(importsplit.Cmd())
        rootCmd.AddCommand(importincomes.Cmd())
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package main

import "github.com/Beigelman/nossas-despesas/scripts/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">package utils

import (
        "encoding/csv"
        "fmt"
        "os"
)

func ReadCSVFile(filename string) ([][]string, error) <span class="cov0" title="0">{
        csvFile, err := os.Open(filename)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">csvLines, err := csv.NewReader(csvFile).ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := csvFile.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error closing file: %w", err)
        }</span>

        <span class="cov0" title="0">return csvLines, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
